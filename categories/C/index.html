<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>分类: C++ - Sandy&#39;s Blog</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="Sandy&#39;s Blog">
<meta property="og:url" content="https://sandychn.github.io/categories/C/index.html">
<meta property="og:site_name" content="Sandy&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sandychn.github.io/images/og_image.png">
<meta property="article:author" content="SandyChen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sandychn.github.io/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/avatar.jpg" alt="Sandy&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">文章</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/sandychn">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">C++</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-05-05T19:02:06.000Z">2020-05-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分钟 读完 (大约 924 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/05/stl-rb_tree/">STL中_Rb_tree的探索</a>
            
        </h1>
        <div class="content">
            <p>我们知道STL中我们常用的<code>set</code>与<code>multiset</code>和<code>map</code>与<code>multimap</code>都是基于红黑树。本文介绍了它们的在STL中的底层数据结构<code>_Rb_tree</code>的直接用法与部分函数。难点主要是<code>_Rb_tree</code>的各个参数的确定。</p>
<p>特别注意在如下代码的<code>Selector</code>类用于从<code>Node</code>中选出用于排序的key值，这个仿函数必须返回<code>const int&amp;</code>而不能是<code>int</code>，否则<code>less&lt;int&gt;::operator(const int&amp;, const int&amp;)</code>会抛出<code>segmentation fault</code>。一开始写成<code>int</code>，看了很多源码才发现是这个原因，一定要注意。（<strong>Update on 2020-5-6</strong>：通过对源码阅读，终于彻底明白为何出现写<code>int</code>会出现问题，见文末）</p>
<p>接下来是样例代码，里面都有注释了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原则上不要直接引用这个头文件，这里只是为了测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stl_tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> first, second;</span><br><span class="line">    Node(<span class="keyword">int</span> _first, <span class="keyword">int</span> _second) : first(_first), second(_second)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; outs, <span class="keyword">const</span> Node&amp; node) &#123;</span><br><span class="line">        outs &lt;&lt; <span class="string">'&#123;'</span> &lt;&lt; node.first &lt;&lt; <span class="string">','</span> &lt;&lt; node.second &lt;&lt; <span class="string">'&#125;'</span>;</span><br><span class="line">        <span class="keyword">return</span> outs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Selector</span> &#123;</span></span><br><span class="line">    <span class="comment">// MUST return const int&amp;, not int.</span></span><br><span class="line">    <span class="comment">// if return int, segmentation fault will occur.</span></span><br><span class="line">    <span class="comment">// I have spent much time because of this.</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; obj)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// _Rb_tree: red-black tree in STL.</span></span><br><span class="line">    <span class="keyword">using</span> tree_type = _Rb_tree&lt;<span class="keyword">int</span>, Node, Selector&lt;Node&gt;, less&lt;<span class="keyword">int</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">using</span> iterator_type = tree_type::iterator;</span><br><span class="line">    <span class="keyword">using</span> result_pair_type = pair&lt;tree_type::iterator, <span class="keyword">bool</span>&gt;;</span><br><span class="line">    tree_type tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素Node(1, 2)</span></span><br><span class="line">    result_pair_type res = tree._M_insert_unique(Node(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert address = "</span> &lt;&lt; res.first._M_node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert result = "</span> &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    iterator_type it = tree.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"begin address = "</span> &lt;&lt; it._M_node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    it = tree.find(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"address = "</span> &lt;&lt; it._M_node &lt;&lt; <span class="string">", value = "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再插入元素Node(1, 2)但是因为调用的是insert_unique</span></span><br><span class="line">    <span class="comment">// 它不会添加重复值，所以插入会被拒绝</span></span><br><span class="line">    res = tree._M_insert_unique(Node(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"insert result = "</span> &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再插入元素Node(1, 2)但这次调用insert_equal</span></span><br><span class="line">    <span class="comment">// multiset和multimap就是利用这个函数来插入重复值</span></span><br><span class="line">    <span class="comment">// 也就是这个函数允许重复值，所以插入成功</span></span><br><span class="line">    tree._M_insert_equal(Node(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size = "</span> &lt;&lt; tree.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 大小就变为2</span></span><br><span class="line"></span><br><span class="line">    pair&lt;iterator_type, iterator_type&gt; result = tree.equal_range(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (iterator_type ite = result.first; ite != result.second; ++ite) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"address = "</span> &lt;&lt; ite._M_node &lt;&lt; <span class="string">", value = "</span> &lt;&lt; *ite &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为（内存地址不定）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert address &#x3D; 0xf91be0</span><br><span class="line">insert result &#x3D; true</span><br><span class="line">begin address &#x3D; 0xf91be0</span><br><span class="line">address &#x3D; 0xf91be0, value &#x3D; &#123;1,2&#125;</span><br><span class="line">insert result &#x3D; false</span><br><span class="line">size &#x3D; 2</span><br><span class="line">address &#x3D; 0xf91be0, value &#x3D; &#123;1,2&#125;</span><br><span class="line">address &#x3D; 0xf91c10, value &#x3D; &#123;1,3&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Update on 2020-5-6</strong></p>
<p>当将<code>Selector::operator()</code>的返回值写为<code>int</code>时，执行时会在<code>main()</code>中的<code>it = tree.find(1)</code>时抛出<code>Segmentation Fault</code>。以下给出调用过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp, main()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    it = tree.find(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stl_tree.h, std::_Rb_tree::find(const _Key&amp;)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Val, <span class="keyword">typename</span> _KeyOfValue,</span><br><span class="line">         <span class="keyword">typename</span> _Compare, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::iterator</span><br><span class="line">    _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::</span><br><span class="line">    find(<span class="keyword">const</span> _Key&amp; __k) &#123;</span><br><span class="line">        iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);</span><br><span class="line">        <span class="keyword">return</span> (__j == end() || _M_impl._M_key_compare(__k,</span><br><span class="line">            _S_key(__j._M_node))) ? end() : __j;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stl_tree.h, std::_Rb_tree::_M_lower_bound(_Link_type, _Link_type, const _Key&amp;)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Val, <span class="keyword">typename</span> _KeyOfValue,</span><br><span class="line">         <span class="keyword">typename</span> _Compare, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">typename</span> _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::iterator</span><br><span class="line">    _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::</span><br><span class="line">    _M_lower_bound(_Link_type __x, _Link_type __y, <span class="keyword">const</span> _Key&amp; __k) &#123;</span><br><span class="line">        <span class="keyword">while</span> (__x != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (!_M_impl._M_key_compare(_S_key(__x), __k))</span><br><span class="line">                __y = __x, __x = _S_left(__x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                __x = _S_right(__x);</span><br><span class="line">        <span class="keyword">return</span> iterator(__y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在此处的 <code>_M_impl._M_key_compare</code> 也就是比较仿函数对象，在这里即<code>less&lt;int&gt;</code>对象。异常就是在这个函数里抛出的，可见问题出现在 <code>_S_key(__x)</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stl_tree.h, std::_Rb_tree::_S_key(_Const_Base_ptr)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> _Key&amp; _S_key(_Const_Base_ptr __x) &#123;</span><br><span class="line">    <span class="keyword">return</span> _KeyOfValue()(_S_value(__x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>_KeyOfValue()</code> 就是我们给的 <code>Selector</code> 了。所以在这里如果将 <code>operator()</code> 的返回值写为 <code>int</code> ，则这里将其以 <code>const _Key&amp;</code> 返回，就是<strong>返回局部对象的引用</strong>，后面又在 <code>less&lt;int&gt;::operator()</code> 里面使用了这个引用（这个引用实际上指向一个已过期的栈上数据： <code>_KeyOfValue()</code> 的返回值），这个行为导致了<code>Segmentation Fault</code>。</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-04-22T17:18:30.000Z">2020-04-23</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 381 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/04/cpp-rvalue-references/">C++右值引用</a>
            
        </h1>
        <div class="content">
            <h2 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h2><p>在C++0x中介绍了一种新的引用类型：右值引用，它帮助解决了不必要的拷贝问题和允许了完美转发的存在。当赋值的右手边（right-hand side）是一个右值时，左手边（left-hand side）的对象就可以<strong>偷走</strong>右手边对象的资源，而不是进行一次独立的分配，也就诞生了”移动语义“。</p>
<p>左值：可以出现在 <em>operator=</em> 左侧者。</p>
<p>右值：只能出现在 <em>operator=</em> 右侧者。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// a + b = 42; // error: lvalue required as left operand of assignment</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"World"</span>)</span></span>;</span><br><span class="line">    s1 + s2 = s2; <span class="comment">// s1 + s2 可以当做左值！</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span>() = <span class="string">"World"</span>; <span class="comment">// 可以对临时对象赋值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++在用户自定义类型中会产生一些细微的问题，这些问题有关于修改或赋值动作。这种问题就导致上面的定义不正确。</p>
<p>（但是仍然应把临时对象认为是右值。）</p>
<p>当右值出现在 <em>operator=</em> （拷贝赋值，copy assignment）的右侧，我们认为对资源进行偷取/搬移（move）而非拷贝（copy）是合理的。则</p>
<ol>
<li>必须有语法让我们在调用端告诉编译器“这是个右值”</li>
<li>必须有语法让我们在被调用端写出一个专门处理右值的所谓移动赋值（move assignment）函数</li>
</ol>

        </div>
        
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-04-21T16:43:00.000Z">2020-04-22</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    34 分钟 读完 (大约 5115 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/04/cpp-4-type-casts/">C++的4种类型转换</a>
            
        </h1>
        <div class="content">
            <h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>用隐式和用户定义转换的组合在类型间转换。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>static_cast &lt;new_type&gt; (expression)</code> 返回 <code>new_type</code> 类型的值。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>唯有下列转换能用 <code>static_cast</code> 执行，但<strong>若转换会转型走<em>常量性</em>或<em>易变性</em>则亦不允许</strong>。</p>
<ol>
<li><p>若存在从 <em>expression</em> 到 <em>new_type</em> 的<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">隐式转换序列</a>，或者若针对以 <em>expression</em> 到 <em>new_type</em> 类型的对象或引用所进行的<a href="https://zh.cppreference.com/w/cpp/language/direct_initialization">直接初始化</a>的重载决议，找到至少一个可行函数，则 <code>static_cast &lt;new_type&gt; (expression)</code> 返回如同以 <code>new_type Temp(expression);</code> 所初始化的一个虚构变量 <code>Temp</code>，它可能涉及<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">隐式转换</a>，对 <em>new_type</em> 的<a href="https://zh.cppreference.com/w/cpp/language/constructor">构造函数</a>的调用，或对<a href="https://zh.cppreference.com/w/cpp/language/cast_operator">用户定义转换运算符</a>的调用。<span style="color: gray">对于非引用的 <em>new_type</em>，static_cast 纯右值表达式的结果对象是其直接初始化的对象。 (C++17 起)</span></p>
</li>
<li><p>若 <em>new_type</em> 是某类类型 <code>D</code> 的左值或指向它的指针纯右值，而 <em>expression</em> 的类型是到其非虚基类 <code>B</code> 的指针或引用，则 <code>static_cast</code> 进行向下转型（downcast）。若 <code>B</code> 是 <code>D</code> 的有歧义、不可访问或虚的基类（或虚基类的基类），则此向下转型非良构。这种 <code>static_cast</code> 并不进行用以确保该对象的运行时类型确实是 <code>D</code> 的运行时检查，而且仅当这项前提条件由其他方法所保证时才能安全使用，例如在实现<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism">静多态</a>时。可以用 <code>dynamic_cast</code> 执行安全的向下转型。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line">D d;</span><br><span class="line">B&amp; br = d;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;D&amp;&gt;(br); <span class="comment">// 左值指代原初的 d 对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>(本条自C++11起)</em> 若 <em>new_type</em> 是右值引用类型，则 <code>static_cast</code> 将泛左值、类纯右值或数组纯右值 (C++17 前) <span style="color: gray">任何左值 (C++17 起)</span> <em>expression</em> 的值转换为与该表达式指代相同对象，或指代其基类子对象（取决于 <em>new_type</em>）的<em>亡值</em>。若目标类型是表达式的不可访问或有歧义基类，则程序非良构。若表达式是<a href="https://zh.cppreference.com/w/cpp/language/bit_field">位域</a>左值，则它首先被转换成底层类型的纯右值。这种 <code>static_cast</code> 用于在 <code>std::move</code> 中实现移动语义。</p>
</li>
<li><p>若 <em>new_type</em> 是（可为 cv 限定的）void 类型，则 <code>static_cast</code> 在<strong>求值 <em>expression</em> 后</strong>舍弃其值。</p>
</li>
<li><p>若存在从 <em>new_type</em> 到 <em>expression</em> 类型的<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">标准转换</a>序列，且它不包含左值到右值、数组到指针、函数到指针、空指针、空成员指针、<span style="color: gray">函数指针 (C++17 起)</span>或布尔转换，则 <code>static_cast</code> 能进行该隐式转换的逆转换。</p>
</li>
<li><p>若从 <em>expression</em> 到 <em>new_type</em> 涉及左值到右值、数组到指针或函数到指针转换，则能显式用 <code>static_cast</code> 进行。</p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/language/enum">有作用域枚举</a>类型(C++11)能转换成整数或浮点类型。</p>
<ol>
<li>当目标类型为 <em>cv</em> bool 时，若原值为零则结果为 false，而对所有其他值结果为 true。对于其余整型类型，若该枚举的值能以目标类型表示，则结果为其值，否则结果未指明。(C++20前)</li>
<li>其结果与从枚举的底层类型<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">隐式转换</a>成目标类型的结果相同。  (C++20 起)</li>
</ol>
</li>
<li><p>整数或枚举类型值可转换为任何完整枚举类型。</p>
<ul>
<li><p>若底层类型不固定，则当 <em>expression</em> 的值落在范围（范围是大到足以保有目标枚举的所有枚举项的最小位域的所有可能值）外时，结果未指明 (C++17 前) 或 为未定义行为 (C++17 起)。</p>
</li>
<li><p>若底层类型固定，则其结果与<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion#.E6.95.B4.E6.95.B0.E7.B1.BB.E5.9E.8B.E8.BD.AC.E6.8D.A2">转换</a>原值到枚举的底层类型再到该枚举类型的结果相同。</p>
<p>浮点类型的值也可转换为任何完整枚举类型。</p>
</li>
<li><p>其结果与<a href="https://zh.cppreference.com/w/cpp/language/implicit_cast#Floating.E2.80.93integral_conversions">转换</a>原值到枚举的底层类型再到该枚举类型的结果相同。</p>
</li>
</ul>
</li>
<li><p>指向某类 <code>D</code> 的成员的指针可以向上转型（upcast）为指向其无歧义、可访问的基类 <code>B</code> 的成员。这种 <code>static_cast</code> 不进行用以确保成员实际存在于所指向对象的运行时类型的检查。</p>
</li>
<li><p>指向（可有 cv 限定）void 的指针类型的纯右值可转换到指向任何对象的指针类型。若原<a href="https://zh.cppreference.com/w/cpp/language/pointer#.E6.8C.87.E9.92.88">指针值</a>所表示的内存中字节地址不满足目标类型的对齐要求，则结果指针值未指明。否则，若原指针值指向对象 <em>a</em>，且存在与 <em>a</em> <em>指针可互转换<em>（定义于下文）的目标类型的（忽略 cv 限定）对象 *b</em>，则结果为指向 *b</em> 的指针。否则指针值不改变。任何指针转换到 void 指针，再转换回原（或更为 cv 限定的）类型的指针，都保持其原值。</p>
</li>
</ol>
<p>同所有转型表达式，结果是：</p>
<ul>
<li>左值，若 <em>new_type</em> 是左值引用或到函数类型的右值引用；</li>
<li>亡值，若 <em>new_type</em> 是到对象类型的右值引用；</li>
<li>否则为纯右值。</li>
</ul>
<p>满足以下条件时，两个对象 <em>a</em> 与 <em>b</em> <em>指针可互转换（pointer-interconvertible）</em>：</p>
<ul>
<li>它们为同一对象，或</li>
<li>一个是 union 对象而另一个是该对象的非静态数据成员，或</li>
<li>一个是<a href="https://zh.cppreference.com/w/cpp/language/data_members#.E6.A0.87.E5.87.86.E5.B8.83.E5.B1.80">标准布局</a>类对象，而另一个是该对象的首个非静态数据成员，或若该对象无非静态数据成员，则为该对象的任何基类子对象，或</li>
<li>存在对象 <em>c</em> 使得 <em>a</em> 与 <em>c</em> 指针可互转换，而 <em>c</em> 与 <em>b</em> 指针可互转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123; <span class="keyword">int</span> a; <span class="keyword">double</span> b; &#125; u;</span><br><span class="line"><span class="keyword">void</span>* x = &amp;u;                        <span class="comment">// x 的值为“指向 u 的指针”</span></span><br><span class="line"><span class="keyword">double</span>* y = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(x); <span class="comment">// y 的值为“指向 u.b 的指针”</span></span><br><span class="line"><span class="keyword">char</span>* z = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);     <span class="comment">// z 的值为“指向 u 的指针”</span></span><br></pre></td></tr></table></figure>

<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p><code>static_cast</code> 亦可用于通过进行到指定类型的函数到指针转换，来消解函数重载的歧义。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::for_each(files.begin(), files.end(),</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::ostream&amp;(*)(<span class="built_in">std</span>::ostream&amp;)&gt;(<span class="built_in">std</span>::flush));</span><br></pre></td></tr></table></figure>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2020/04/cpp-4-type-casts/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-04-19T10:19:09.000Z">2020-04-19</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 443 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/04/cpp-optimizations-of-constructors/">C++构造函数的优化</a>
            
        </h1>
        <div class="content">
            <p>下面这段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"default ctor\n"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; b) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy ctor\n"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"dtor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上，它的运行结果应为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default ctor &#x2F;&#x2F; foo函数第一行的对象b的构造</span><br><span class="line">copy ctor    &#x2F;&#x2F; 对象b拷贝到返回值临时对象</span><br><span class="line">dtor         &#x2F;&#x2F; 对象b析构</span><br><span class="line">copy ctor    &#x2F;&#x2F; 返回值临时对象拷贝到main中对象a</span><br><span class="line">dtor         &#x2F;&#x2F; 返回值临时对象析构</span><br><span class="line">dtor         &#x2F;&#x2F; main对象析构</span><br></pre></td></tr></table></figure>

<p>然而，当我们实际编译并运行它时，运行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure>

<p>发现所有的拷贝构造和临时对象的析构都被优化掉了。这就是<strong>NRV优化</strong>带来的性能上的好处。</p>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2020/04/cpp-optimizations-of-constructors/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-12T07:27:47.000Z">2020-03-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    8 分钟 读完 (大约 1133 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/inside-the-cpp-object-model-notes/">《深度探索C++对象模型》学习笔记</a>
            
        </h1>
        <div class="content">
            <h2 id="1-关于对象"><a href="#1-关于对象" class="headerlink" title="1 关于对象"></a>1 关于对象</h2><h3 id="1-1-C-对象模式"><a href="#1-1-C-对象模式" class="headerlink" title="1.1 C++对象模式"></a>1.1 C++对象模式</h3><h4 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h4><p>非静态数据成员放置于每一个类对象中，静态数据成员则被存放在类对象之外。静态与非静态成员函数也被放在类对象之外。虚函数则以两个步骤支持：</p>
<ol>
<li>每一个类产生出一堆指向虚函数的指针，放在表格之中，此表称为虚表 (virtual table, vtbl)。</li>
<li>在每一个类对象中安插一个指针，指向相关的虚表。通常这个指针被称为 <strong>vptr</strong> 。它的设定与重置由每一个类的构造函数、析构函数、拷贝赋值运算符自动完成。每一个类所关联的 <code>type_info</code> 对象（用以支持runtime type identification, RTTI）也经由虚表指出，通常放在表格的第一个slot（位置）。</li>
</ol>
<h2 id="3-Data语义学"><a href="#3-Data语义学" class="headerlink" title="3 Data语义学"></a>3 Data语义学</h2><h3 id="3-0-综述"><a href="#3-0-综述" class="headerlink" title="3.0 综述"></a>3.0 综述</h3><ul>
<li>一个虚基类子对象只会在派生类中存在一份实例，不管它在继承体系中出现了多少次。</li>
<li>C++标准并不强制规定如“基类子对象的排列顺序“或”不同存取层级的数据成员的排列顺序“这种琐碎细节。它也不规定虚函数或虚基类的实现细节。C++标准说：那些细节由各家厂商自定。</li>
<li>C++对象模型把非静态数据成员直接存放在每一个类对象中，对于继承来的非静态数据成员（无论是虚继承还是非虚继承）也是如此。不过并没有强制定义其间的排列顺序。至于静态数据成员则被放置在程序的一个全局数据段（global data segment）中，不影响类对象的大小。</li>
</ul>
<h3 id="3-1-Data-Member-的绑定"><a href="#3-1-Data-Member-的绑定" class="headerlink" title="3.1 Data Member 的绑定"></a>3.1 Data Member 的绑定</h3><ol>
<li><p>有关数据成员的绑定问题，现在的C++已经解决了。</p>
</li>
<li><p>若一个 inline 函数在 class 声明之后立刻被定义，则还是对其评估求值。即对成员函数本体的分析会直到整个class的声明都出现了开始。因此在一个inline成员函数体之内的一个数据成员绑定操作，会在整个class声明完成之后才发生。（member scope resolution rules）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对于函数本体的分析将延迟直到class声明的右大括号出现才开始</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析在这里进行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然而这对于成员函数的参数列表并不为真。参数列表中的名称还是会在它们第一次遇到时被适当地决议（resolved）完成。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length; <span class="comment">// global typedef</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span></span>; <span class="comment">// length: int</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125; <span class="comment">// length: int</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length; <span class="comment">// nested typedef</span></span><br><span class="line">    length _val; <span class="comment">// length: float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于这种情况，请总是把“nested type声明”放在class的起始处。</p>
</li>
</ol>
<h3 id="3-2-Data-Member-的布局"><a href="#3-2-Data-Member-的布局" class="headerlink" title="3.2 Data Member 的布局"></a>3.2 Data Member 的布局</h3><h3 id="3-6-指向-Data-Members-的指针"><a href="#3-6-指向-Data-Members-的指针" class="headerlink" title="3.6 指向 Data Members 的指针"></a>3.6 指向 Data Members 的指针</h3><p>取一个非静态数据成员的地址将会得到它在类中的偏移量。</p>
<p>下面代码中数据成员指针的类型为：<code>float Point3d::*</code>。有些编译器返回的偏移量总是多1，因为考虑到不指向任何成员的指针应为0。如果不加1，有可能导致第一个数据成员成员的指针和不指向任何成员的指针相等，都为0。（此时说它是偏移量就有些不合适）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// G++ 8.1.0, 64-bit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Point3d() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Point3d origin;</span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2 &#123;</span><br><span class="line">    <span class="keyword">int</span> val3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point3d Point3d::origin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> show(ptrToDataMember) printf(#ptrToDataMember <span class="meta-string">" = %d\n"</span>, ptrToDataMember)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意不能用 cout &lt;&lt; &amp;Point3d::x，会匹配到 operator&lt;&lt;(bool)</span></span><br><span class="line">    <span class="comment">// 为了简便，这里定义宏（与书上不同）</span></span><br><span class="line">    show(&amp;Point3d::x);  <span class="comment">// 8</span></span><br><span class="line">    show(&amp;Point3d::y);  <span class="comment">// 12</span></span><br><span class="line">    show(&amp;Point3d::z);  <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    show(&amp;Base1::val1);    <span class="comment">// 0</span></span><br><span class="line">    show(&amp;Base2::val2);    <span class="comment">// 0</span></span><br><span class="line">    show(&amp;Derived::val1);  <span class="comment">// 0</span></span><br><span class="line">    show(&amp;Derived::val2);  <span class="comment">// 0（比较奇怪）</span></span><br><span class="line">    show(&amp;Derived::val3);  <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color: blue;">个人感觉，成员指针并不能拿来输出。所以输出什么值也只能作为参考，便于理解这个概念。事实上，我觉得cout给出了正确的行为。它将一个成员指针视为bool，以表示其是否真正有效。即</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Base1::* p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></span><br><span class="line">    p = &amp;Base1::val1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-07T10:40:01.000Z">2020-03-07</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 757 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/cpp-implementation-of-references/">C++引用的实现</a>
            
        </h1>
        <div class="content">
            <p>当我学习C++引用时，听到的第一句话是“引用是变量的别名，不像指针一样需要占用内存空间”。然而学到深处，发现此话并不完全正确。</p>
<p>本文主要介绍我如何通过实验来了解到C++引用的实现，其实<strong>引用的内部就是指针</strong>。当然这也于编译器有关，所以这里需要提及一下测试所用的编译器及环境。</p>
<p>测试环境是MinGW的g++ 8.1.0，64位编译器，64位的机子。所以指针的大小是8个字节，即64个bit。（注：因为目的是测试，所以测试时并没有处理对new操作符所产生对象的回收）</p>
<p>首先我写出了如下代码，试图通过指针偏移来获取有关引用的信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> x;</span><br><span class="line">    <span class="built_in">string</span>&amp; str = *<span class="keyword">new</span> <span class="built_in">string</span>();</span><br><span class="line">    <span class="keyword">int64_t</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str; <span class="comment">// 对引用做一次操作，避免编译器把变量优化掉</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这个程序的输出如下（str的输出忽略）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x61fe00</span><br><span class="line">0x61fdf8</span><br></pre></td></tr></table></figure>

<p>难道引用真的不占内存？编译器真的很聪明，可能优化掉了吧；经过一系列尝试，我写出了另外一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int64_t</span> q, <span class="built_in">string</span>&amp; s, <span class="keyword">int64_t</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;q: "</span> &lt;&lt; &amp;q &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;r: "</span> &lt;&lt; &amp;r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*(string**)(&amp;q + 1): "</span> &lt;&lt; *(<span class="built_in">string</span>**)(&amp;q + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>&amp; str = *<span class="keyword">new</span> <span class="built_in">string</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main(): "</span> &lt;&lt; &amp;str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    foo(<span class="number">0</span>, str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main(): 0x1e1bd0</span><br><span class="line">&amp;q: 0x61fde0</span><br><span class="line">&amp;r: 0x61fdf0</span><br><span class="line">*(string**)(&amp;q + 1): 0x1e1bd0</span><br></pre></td></tr></table></figure>

<p>可见，q的地址是<code>0x61fde0</code>，r的地址是<code>0x61fdf0</code>。两个地址间相差16个字节！这里引用占用的内存出来了。显然引用对应的指针存储在q的8个字节之后。我们可以将q的地址加1，也就是加上8个字节，这里存储的就是引用的信息。假设它就是指针，那么考虑：<code>(&amp;q + 1)</code>本身是一个指向<code>string*</code>的指针，也就是<code>string**</code>。所以若要获取指针的值，需要对这个值解一次引用，输出出来。（当然如果你想简单一点，可以直接把它转成<code>int64_t</code>然后用16进制输出亦可）</p>
<p>至此真相大白，程序输出的最后一行<code>0x1e1bd0</code>与主函数中new出来的对象的地址（见输出第一行）一致。所以得出结论：<strong>引用是用指针实现的。用户对引用的访问操作都内含一次解引用，而这对用户来说是透明的</strong>。</p>
<p>不过需要提及的是，回想本文的第一个测试，发现引用的指针空间被优化掉了。所以引用有时也不一定会在栈上真正以指针体现出来。</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-10T08:11:22.000Z">2020-02-10</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分钟 读完 (大约 2314 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/cpp-virtual-functions-override-polymorphism/">C++中的虚函数、重写与多态</a>
            
        </h1>
        <div class="content">
            <h2 id="在C-中顺利使用虚函数需知道的细节"><a href="#在C-中顺利使用虚函数需知道的细节" class="headerlink" title="在C++中顺利使用虚函数需知道的细节"></a>在C++中顺利使用虚函数需知道的细节</h2><ul>
<li>如函数在派生类中的定义有别于基类中的定义，而且你希望它成为虚函数，就要为基类的函数声明添加保留字<code>virtual</code>。在派生类的函数声明中，则可以不添加<code>virtual</code>。函数在基类中<code>virtual</code>，在派生类中自动<code>virtual</code>（但为了澄清，最好派生类中也将函数声明标记为<code>virtual</code>，尽管这非必须）。</li>
<li>保留字<code>virtual</code>在函数声明中添加，不要再函数定义中添加。</li>
<li>除非使用保留字<code>virtual</code>，否则不能获得虚函数，也不能获得虚函数的任何好处。</li>
<li>既然虚函数如此好用，为何不将所有成员函数都设为<code>virtual</code>？这似乎只有一个理由——效率。编译器和“运行时”环境要为虚函数做多得多的工作。所以，无谓地将成员函数为<code>virtual</code>会影响程序执行效率。</li>
</ul>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>虚函数定义在派生类中发生改变时我们说函数定义被重写。一些C++书籍区分了重定义（redefine）和重写（override）。两者都是在派生类更改函数定义。函数是虚函数，就称为重写。如果不是，就称为重定义。对于我们程序员而言，这种区分似乎有点无聊，因为程序员在两种情况下做的事情是一样的。不过，编译器对于这两种情况确定是区别对待的。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性是指借助晚期绑定技术，为一个函数名关联多种含义的能力。因此，多态性、晚期绑定和虚函数其实是同一个主题。</p>
<h2 id="虚函数和扩展类型兼容性、切割问题"><a href="#虚函数和扩展类型兼容性、切割问题" class="headerlink" title="虚函数和扩展类型兼容性、切割问题"></a>虚函数和扩展类型兼容性、切割问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">string</span> breed; <span class="comment">// 品种</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pet::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pet name: "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", breed: "</span> &lt;&lt; breed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pet vPet;</span><br><span class="line">    Dog vDog;</span><br><span class="line">    vDog.name = <span class="string">"Tiny"</span>;</span><br><span class="line">    vDog.breed = <span class="string">"Great Dane"</span>;</span><br><span class="line">    vPet = vDog;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; vPet.breed;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码<code>vPet = vDog;</code>的赋值是允许的，但赋给变量<code>vPet</code>的值会丢失其<code>breed</code>字段。这称为<strong>切割问题（slicing problem）</strong>。例如，<code>cout &lt;&lt; vPet.breed</code>会报错。</p>
<p><strong>切割问题</strong>：在将派生类对象赋给基类变量时，派生类对象有、基类没有的数据成员会在赋值过程中丢失，基类没有的成员函数也会丢失。在最终的基类对象中，将无法使用这些丢失的成员。</p>
<p>切割测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Demo(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s): str(s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Demo constructor called ("</span> + str + <span class="string">").\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Demo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Demo destructor called ("</span> + str + <span class="string">").\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo(<span class="keyword">const</span> Demo&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        str = other.str;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Demo copy constructor called ("</span> + str + <span class="string">").\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Demo&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        str = other.str;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Demo operator= called ("</span> + str + <span class="string">").\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Demo member1 = Demo(<span class="string">"member1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Demo member2 = Demo(<span class="string">"member2"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    Base base;</span><br><span class="line">    base = derived;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output</span></span><br><span class="line"><span class="comment">Demo constructor called (member1).</span></span><br><span class="line"><span class="comment">Demo constructor called (member2).</span></span><br><span class="line"><span class="comment">Demo constructor called (member1).</span></span><br><span class="line"><span class="comment">Demo operator= called (member1).</span></span><br><span class="line"><span class="comment">Demo destructor called (member1).</span></span><br><span class="line"><span class="comment">Demo destructor called (member2).</span></span><br><span class="line"><span class="comment">Demo destructor called (member1).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>幸好，C++提供了一种方式，允许在将一个<code>Dog</code>视为<code>Pet</code>的同时不丢失品种名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pet *pPet;</span><br><span class="line">Dog *pDog;</span><br><span class="line">pDog = <span class="keyword">new</span> Dog;</span><br><span class="line">pDog-&gt;name = <span class="string">"Tiny"</span>;</span><br><span class="line">pDog-&gt;breed = <span class="string">"Great Dane"</span>;</span><br><span class="line">pPet = pDog;</span><br><span class="line">pPet-&gt;print(); <span class="comment">// prints "Dog name: Tiny, breed: Great Dane"</span></span><br></pre></td></tr></table></figure>

<p><strong>基类<code>Pet</code>把<code>print()</code>声明为<code>virtual</code>。所以一旦编译器看到<code>pPet-&gt;print();</code>就会检查<code>Pet</code>和<code>Dog</code>的<code>virtual</code>表，判断<code>pPet</code>指向的是<code>Dog</code>类型的对象。</strong>因此，它会使用<code>Dog::print()</code>，而不是<code>Pet::print()</code>。</p>
<p>配合动态变量进行OOP是一种全然不同的编程方式。只要记住以下两条简单的规则，理解起来就容易得多。</p>
<ol>
<li><strong>如果指针<code>pAncestor</code>的域类型是指针<code>pDescendant</code>的域类型的基类，则以下指针赋值操作允许：<code>pAncestor = pDescendant;</code>。此外，<code>pDescendant</code>指向的动态变量的任何数据成员或成员函数都不会丢失。</strong></li>
<li><strong>虽然动态变量所有附加字段（成员）都没有丢，但要用<code>virtual</code>成员函数访问。</strong></li>
</ol>
<h2 id="视图对虚成员函数定义不齐全的类进行编译"><a href="#视图对虚成员函数定义不齐全的类进行编译" class="headerlink" title="视图对虚成员函数定义不齐全的类进行编译"></a>视图对虚成员函数定义不齐全的类进行编译</h2><p>编译前，如果还有任何尚未实现的<code>virtual</code>成员函数，编译就会失败，并产生形如<code>undefined reference to Class_Name virtual table</code>的错误信息。即使没有派生类，只有一个<code>virtual</code>成员，并且没有调用该虚函数，只要函数没有定义，就会产生这种形式的消息。此外，可能还会产生进一步的错误消息，声称程序对默认构造函数进行了未定义的引用，即使确实已定义了这些构造函数。</p>
<h2 id="始终-尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）"><a href="#始终-尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）" class="headerlink" title="始终/尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）"></a>始终/尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）</h2><p><span style="color: red"><strong>这里主要阐述让析构函数称为虚函数的好处，但实际上也有坏处。在《Effective C++》条款07中有提到具体内容，见本文后记。</strong></span></p>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2020/02/cpp-virtual-functions-override-polymorphism/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-13T08:14:15.000Z">2019-08-13</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分钟 读完 (大约 829 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/cpp-11-new/">C++11 新用法</a>
            
        </h1>
        <div class="content">
            <h2 id="基于哈希的-map-和-set"><a href="#基于哈希的-map-和-set" class="headerlink" title="基于哈希的 map 和 set"></a>基于哈希的 map 和 set</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>基于哈希的 <code>map</code> 和 <code>set</code> ，它们分别叫做 <code>unordered_map</code>, <code>unordered_set</code> 。数据分布越平均，性能相较 <code>map</code> 和 <code>set</code> 来说提升就更大。但由于它们基于哈希，所以并不像 <code>map</code> 和 <code>set</code> 一样能自动排序；它们都是无序的。</p>
<p>我做了一个测试：随机生成 $10^7$ 个 <code>int</code> 范围内的整数（平均分布），然后将其分别插入 <code>map</code> 和 <code>unordered_map</code>，再完整的做一次查询，查看时间和内存上的消耗。</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">总耗时</th>
<th align="center">插入耗时</th>
<th align="center">查询耗时</th>
<th align="center">内存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">map</td>
<td align="center">18,041 MS</td>
<td align="center">10,299 MS</td>
<td align="center">7,742 MS</td>
<td align="center">230.7 MB</td>
</tr>
<tr>
<td align="center">unordered_map</td>
<td align="center">7,138 MS</td>
<td align="center">5,426 MS</td>
<td align="center">1,712 MS</td>
<td align="center">212.0 MB</td>
</tr>
</tbody></table>
<p>当数据分布平均时，从时间上看，两者的性能差距约为 $7138 / 18041 \approx 40\%$</p>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2019/08/cpp-11-new/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-07T12:58:43.000Z">2019-08-07</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 分钟 读完 (大约 208 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/generate-random-data-in-high-efficiency-random-chrono/">高效随机数据生成-random与chrono</a>
            
        </h1>
        <div class="content">
            <p>请注意random库与chrono库均是C++11。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 [a, b] 范围内的整数</span></span><br><span class="line"><span class="comment">// 其中 INT_MIN &lt;= a &lt;= b &lt;= INT_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt;(a, b)(rng);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 [a, b] 范围内的整数</span></span><br><span class="line"><span class="comment">// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_INT_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">rand</span><span class="params">(<span class="keyword">unsigned</span> a, <span class="keyword">unsigned</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt;(a, b)(rng);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 [a, b] 范围内的整数</span></span><br><span class="line"><span class="comment">// 其中 LONG_LONG_MIN &lt;= a &lt;= b &lt;= LONG_LONG_MAX</span></span><br><span class="line"><span class="function">LL <span class="title">rand</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> uniform_int_distribution&lt;LL&gt;(a, b)(rng);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 [a, b] 范围内的整数</span></span><br><span class="line"><span class="comment">// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_LONG_LONG_MAX</span></span><br><span class="line"><span class="function">ULL <span class="title">rand</span><span class="params">(ULL a, ULL b)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> uniform_int_distribution&lt;ULL&gt;(a, b)(rng);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> LL MAX = <span class="number">1e10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rand(-MAX, MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        
        
    </div>
</div>









    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-06T07:57:34.000Z">2019-08-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/C/">C++</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 分钟 读完 (大约 424 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/bitset/">bitset</a>
            
        </h1>
        <div class="content">
            <h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>一含有特定二进制位数 <code>N</code> 的容器，相当于 <code>bool</code> 数组，但压缩内存至每一个二进制位。</p>
<h2 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h2><p><code>bitset&lt;N&gt; bset</code>，其中 <code>N</code> 为字面常量，表示 <code>bitset</code> 中的二进制位个数。如 <code>bitset&lt;10&gt; bset;</code></p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>bitset(unsigned long val)</code> 用 <code>val</code> 构造一个对应的 <code>bitset</code> (至 C++11 前)</p>
<p><code>bitset(unsigned long long val)</code> 用 <code>val</code> 构造一个对应的 <code>bitset</code> (自 C++11 始)</p>
<p><code>bitset(string val)</code> 用 <code>val</code> 构造一个对应的 <code>bitset</code></p>
<p><code>bool operator[]</code> 获取特定二进制位的值</p>
<p><code>bool test(pos)</code> 获取特定二进制位的值，但有越界检查：如果越界，抛出 <code>std::out_of_range</code> 异常。</p>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2019/08/bitset/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>










    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/categories/C/page/0/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/C/page/2/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/categories/C/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/C/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/avatar.jpg" alt="Sandy Chen">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Sandy Chen
                    </p>
                    
                    
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            30
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            10
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            12
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        
        
    </div>
</div>
    
        
    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Boost/">
            <span class="level-start">
                <span class="level-item">Boost</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/C/">
            <span class="level-start">
                <span class="level-item">C++</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">14</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Go/">
            <span class="level-start">
                <span class="level-item">Go</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Hexo/">
            <span class="level-start">
                <span class="level-item">Hexo</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/LeetCode/">
            <span class="level-start">
                <span class="level-item">LeetCode</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Linux/">
            <span class="level-start">
                <span class="level-item">Linux</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/MySQL/">
            <span class="level-start">
                <span class="level-item">MySQL</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Python/">
            <span class="level-start">
                <span class="level-item">Python</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/TCP-IP/">
            <span class="level-start">
                <span class="level-item">TCP/IP</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
            <span class="level-start">
                <span class="level-item">操作系统</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/ACM/" style="font-size: 13.33px;">ACM</a> <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/C-11/" style="font-size: 16.67px;">C++11</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Navicat/" style="font-size: 10px;">Navicat</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/STL/" style="font-size: 20px;">STL</a> <a href="/tags/VMware/" style="font-size: 10px;">VMware</a> <a href="/tags/Valgrind/" style="font-size: 10px;">Valgrind</a> <a href="/tags/memcheck/" style="font-size: 10px;">memcheck</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2021-06-05T11:12:37.000Z">2021-06-05</time></div>
                    <a href="/2021/06/boost-notes/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Boost学习笔记</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Boost/">Boost</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-10-28T13:10:26.000Z">2020-10-28</time></div>
                    <a href="/2020/10/vmware-notes/" class="title has-link-black-ter is-size-6 has-text-weight-normal">VMware使用相关</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-10-04T15:39:14.000Z">2020-10-04</time></div>
                    <a href="/2020/10/tcp-ip-transport-layer/" class="title has-link-black-ter is-size-6 has-text-weight-normal">TCP/IP学习笔记：传输层</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/TCP-IP/">TCP/IP</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-10-03T03:10:31.000Z">2020-10-03</time></div>
                    <a href="/2020/10/hexo-icarus-blog-problems-solutions/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Hexo与Icarus博客搭建遇到问题与解决</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Hexo/">Hexo</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-06-17T11:59:20.000Z">2020-06-17</time></div>
                    <a href="/2020/06/python-topic3/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Python知识点3</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Python/">Python</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            文章
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2021/06/">
                <span class="level-start">
                    <span class="level-item">六月 2021</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/10/">
                <span class="level-start">
                    <span class="level-item">十月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/06/">
                <span class="level-start">
                    <span class="level-item">六月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/05/">
                <span class="level-start">
                    <span class="level-item">五月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/04/">
                <span class="level-start">
                    <span class="level-item">四月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/03/">
                <span class="level-start">
                    <span class="level-item">三月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">9</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">二月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">5</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">三月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ACM/">
                        <span class="tag">ACM</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C/">
                        <span class="tag">C++</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/C-11/">
                        <span class="tag">C++11</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/MySQL/">
                        <span class="tag">MySQL</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Navicat/">
                        <span class="tag">Navicat</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/STL/">
                        <span class="tag">STL</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/VMware/">
                        <span class="tag">VMware</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Valgrind/">
                        <span class="tag">Valgrind</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/memcheck/">
                        <span class="tag">memcheck</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="tag">数据结构</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/avatar.jpg" alt="Sandy&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2021 SandyChen&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                <br>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="My GitHub" href="https://github.com/sandychn">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://sandychn.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>