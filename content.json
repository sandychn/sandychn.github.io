{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"C++中的虚函数、重写与多态","text":"在C++中顺利使用虚函数需知道的细节 如函数在派生类中的定义有别于基类中的定义，而且你希望它成为虚函数，就要为基类的函数声明添加保留字virtual。在派生类的函数声明中，则可以不添加virtual。函数在基类中virtual，在派生类中自动virtual（但为了澄清，最好派生类中也将函数声明标记为virtual，尽管这非必须）。 保留字virtual在函数声明中添加，不要再函数定义中添加。 除非使用保留字virtual，否则不能获得虚函数，也不能获得虚函数的任何好处。 既然虚函数如此好用，为何不将所有成员函数都设为virtual？这似乎只有一个理由——效率。编译器和“运行时”环境要为虚函数做多得多的工作。所以，无谓地将成员函数为virtual会影响程序执行效率。 重写虚函数定义在派生类中发生改变时我们说函数定义被重写。一些C++书籍区分了重定义（redefine）和重写（override）。两者都是在派生类更改函数定义。函数是虚函数，就称为重写。如果不是，就称为重定义。对于我们程序员而言，这种区分似乎有点无聊，因为程序员在两种情况下做的事情是一样的。不过，编译器对于这两种情况确定是区别对待的。 多态多态性是指借助晚期绑定技术，为一个函数名关联多种含义的能力。因此，多态性、晚期绑定和虚函数其实是同一个主题。 虚函数和扩展类型兼容性、切割问题12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Pet{public: virtual void print(); string name;};class Dog : public Pet{public: virtual void print(); string breed; // 品种};void Pet::print(){ cout &lt;&lt; \"Pet name: \" &lt;&lt; name &lt;&lt; endl;}void Dog::print(){ cout &lt;&lt; \"Dog name: \" &lt;&lt; name &lt;&lt; \", breed: \" &lt;&lt; breed &lt;&lt; endl;}int main(){ Pet vPet; Dog vDog; vDog.name = \"Tiny\"; vDog.breed = \"Great Dane\"; vPet = vDog; // cout &lt;&lt; vPet.breed; return 0;} 上述代码vPet = vDog;的赋值是允许的，但赋给变量vPet的值会丢失其breed字段。这称为切割问题（slicing problem）。例如，cout &lt;&lt; vPet.breed会报错。 切割问题：在将派生类对象赋给基类变量时，派生类对象有、基类没有的数据成员会在赋值过程中丢失，基类没有的成员函数也会丢失。在最终的基类对象中，将无法使用这些丢失的成员。 切割测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Demo{public: Demo(const string&amp; s): str(s) { cout &lt;&lt; \"Demo constructor called (\" + str + \").\\n\"; } ~Demo() { cout &lt;&lt; \"Demo deconstructor called (\" + str + \").\\n\"; } Demo(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo copy constructor called (\" + str + \").\\n\"; } Demo&amp; operator=(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo operator= called (\" + str + \").\\n\"; return *this; }private: string str;};class Base{public: Demo member1 = Demo(\"member1\");};class Derived : public Base{public: Demo member2 = Demo(\"member2\");};int main(){ Derived derived; Base base; base = derived;}/* OutputDemo constructor called (member1).Demo constructor called (member2).Demo constructor called (member1).Demo operator= called (member1).Demo deconstructor called (member1).Demo deconstructor called (member2).Demo deconstructor called (member1).*/ 幸好，C++提供了一种方式，允许在将一个Dog视为Pet的同时不丢失品种名称： 1234567Pet *pPet;Dog *pDog;pDog = new Dog;pDog-&gt;name = \"Tiny\";pDog-&gt;breed = \"Great Dane\";pPet = pDog;pPet-&gt;print(); // prints \"Dog name: Tiny, breed: Great Dane\" 基类Pet把print()声明为virtual。所以一旦编译器看到pPet-&gt;print();就会检查Pet和Dog的virtual表，判断pPet指向的是Dog类型的对象。因此，它会使用Dog::print()，而不是Pet::print()。 配合动态变量进行OOP是一种全然不同的编程方式。只要记住以下两条简单的规则，理解起来就容易得多。 如果指针pAncestor的域类型是指针pDescendant的域类型的基类，则以下指针赋值操作允许：pAncestor = pDescendant;。此外，pDescendant指向的动态变量的任何数据成员或成员函数都不会丢失。 虽然动态变量所有附加字段（成员）都没有丢，但要用virtual成员函数访问。 视图对虚成员函数定义不齐全的类进行编译编译前，如果还有任何尚未实现的virtual成员函数，编译就会失败，并产生形如undefined reference to Class_Name virtual table的错误信息。即使没有派生类，只有一个virtual成员，并且没有调用该虚函数，只要函数没有定义，就会产生这种形式的消息。此外，可能还会产生进一步的错误消息，声称程序对默认构造函数进行了未定义的引用，即使确实已定义了这些构造函数。 始终/尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）这里主要阐述让析构函数称为虚函数的好处，但实际上也有坏处。在《Effective C++》条款07中有提到具体内容，见本文后记。 析构函数最好都是虚函数。但在解释它为什么好之前，首先解释一下析构函数和指针如何交互，以及虚析构函数的具体含义。如以下代码，其中SomeClass是含有非虚析构函数的类： 123SomeClass *p = new SomeClass;// ...delete p; 为p调用delete，会自动调用SomeClass类的析构函数，现在看看将析构函数标记为virtual之后会发生什么。为了描述析构函数与虚函数机制的交互，最简单的方式是将所有析构函数都视为同名（即使它们并非真的同名）。如假定Derived类是Base类的派生类，并假定Base类的析构函数标记为virtual，现在分析以下代码： 123Base *pBase = new Derived;// ...delete pBase; 为pBase调用delete时，会调用一个析构函数。由于Base类中的析构函数标记为virtual，且指向的对象是Derived类型，故会调用Derived的析构函数（它进而调用Base类的析构函数）。若Base类的析构函数没有标记为virtual，则只调用Base类的析构函数。 还要注意一点，将析构函数标记为virtual后，派生类的所有析构函数都自动成为virtual的（不管是否用virtual标记）。同样，这种行为就好比所有析构函数具有相同的名称（即使事实上不同名）。 现在，已准备好解释为什么所有析构函数都应该是虚函数。假定Base类有一个指针类型的成员变量pB，Base类的构造函数会创建由pB指向的一个动态变量，而Base类的析构函数会删除之；另外，假定Base类的析构函数没有标记为virtual，并假定Derived类（从Base派生）有一个指针类型的成员变量pD，Derived类的构造函数会创建由pD指向的一个动态变量，而Derived类的析构函数会删除之。则以下代码 123Base *pBase = new Derived;// ...delete pBase; 由于基类析构函数未标记为virtual，所以只会调用Base类的析构函数。这会将pB指向的动态变量的内存返还给自由存储；但pD指向的动态变量占用的内存永远不会返还给自由存储直到程序终止。 另一方面，将基类Base析构函数标记为virtual，delete pBase;时会调用Derived类的析构函数（因为指向的对象是Derived类型）。Derived类的析构函数会删除pD指向的动态变量，再自动调用基类Base的析构函数删除pB指向的动态变量。 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;class Base{public: Base() { baseData = new int; std::cout &lt;&lt; \"baseData allocated.\\n\"; } ~Base() { delete baseData; std::cout &lt;&lt; \"baseData deleted.\\n\"; }private: int *baseData;};class Derived : public Base{public: Derived() { derivedData = new int; std::cout &lt;&lt; \"derivedData allocated.\\n\"; } ~Derived() { delete derivedData; std::cout &lt;&lt; \"derivedData deleted.\\n\"; }private: int *derivedData;};int main(){ Base *base = new Derived; delete base;}/* OutputbaseData allocated.derivedData allocated.baseData deleted.*/ 将第11行的~Base()改为virtual ~Base()，程序输出为 123456/* OutputbaseData allocated.derivedData allocated.derivedData deleted.baseData deleted.*/ 后记参考：Walter Savitch《Problem Solving with C++, Tenth Edition》《Effective C++》。 《Effective C++》条款07：“为多态基类声明virtual析构函数”中提到： 带多态性质的基类应该声明一个virtual析构函数；如果类带有任何virtual函数，则它就应该拥有一个virtual析构函数。 类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明virtual析构函数。（如标准库input_iterator_tag等）","link":"/2020/02/10/C++%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E5%A4%9A%E6%80%81/"},{"title":"C++11 新用法","text":"基于哈希的 map 和 set简述基于哈希的 map 和 set ，它们分别叫做 unordered_map, unordered_set 。数据分布越平均，性能相较 map 和 set 来说提升就更大。但由于它们基于哈希，所以并不像 map 和 set 一样能自动排序；它们都是无序的。 我做了一个测试：随机生成 $10^7$ 个 int 范围内的整数（平均分布），然后将其分别插入 map 和 unordered_map，再完整的做一次查询，查看时间和内存上的消耗。 测试结果 结构 总耗时 插入耗时 查询耗时 内存 map 18,041 MS 10,299 MS 7,742 MS 230.7 MB unordered_map 7,138 MS 5,426 MS 1,712 MS 212.0 MB 当数据分布平均时，从时间上看，两者的性能差距约为 $7138 / 18041 \\approx 40\\%$ 提示即使在平均意义下 unordered_map 有着比 map 更高的效率，但是由于两者的实现（前者哈希，后者平衡树）， unordered_map 单次插入的最差复杂度是 $O(N)$， map 单次插入的最差复杂度是 $O(log N)$ 。所以在出题人故意造数据卡 unordered_map 使其内部哈希表发生严重冲突时，unordered_map 就会变得很慢。 测试代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; data;int main() { freopen(\"map.txt\", \"r\", stdin); data.resize(5000000); map&lt;int, int&gt; mp; double st, ed; st = clock(); for (int i = 0; i &lt; 5000000; ++i) scanf(\"%d%d\", &amp;data[i].first, &amp;data[i].second); ed = clock(); printf(\"Read: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) mp[data[i].first] = data[i].second; ed = clock(); printf(\"Insert: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) data[i].second = mp[data[i].first]; ed = clock(); printf(\"Query: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); data = vector&lt;pair&lt;int, int&gt;&gt;();} 语法上的变化auto 关键字的新含义在 C++11 中，auto 关键字被赋予了新的含义。其功能是自动类型推导。 12345678auto x = 3; // y的类型自动推导为 intauto y = make_pair(1, 2); // y的类型自动推导为 pair&lt;int, int&gt;auto z; // 编译错误, z的类型需要一个初始值才能推导map&lt;int, int&gt; mp;// iter的类型推导为map&lt;int, int&gt;::iteratorfor (auto iter = mp.begin(); iter != mp.end(); ++iter) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; '\\n'; 与其相关的是一个新的关键字 decltype，取得某一个值的类型。 12int a = 1, b = 2;decltype(a + b) c; // c为int 增强的 for（基于范围的for循环）123456789map&lt;int, int&gt; mp;// C++11 之前遍历for (map&lt;int, int&gt;::iterator it = mp,begin(); it != mp,end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n';// C++11 之后for (auto val : mp) cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; 模板嵌套时一个小改善12priority_queue&lt;pair&lt;int, int&gt; &gt; heap; // C++11之前需加一个空格避免歧义priority_queue&lt;pair&lt;int, int&gt;&gt; heap; // C++11之后不用 初始化列表更简单的初始化方式。 1234567vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} };// 等价于下面代码vector&lt;pair&lt;int, int&gt; &gt; v;v.push_back(make_pair(1, 2));v.push_back(make_pair(2, 3));v.push_back(make_pair(3, 4)); lambda 表达式下面用一个例子讲述一下lambda表达式的大致用法。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} }; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } sort(v.begin(), v.end(), [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first; }); cout &lt;&lt; \"After sort:\\n\"; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } return 0;} 代码里的 sort，在C++11之前比较常见的等价写法是： 123456789bool cmp(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first;}int main() { // ... sort(v.begin(), v.end(), cmp); // ...}","link":"/2019/08/13/C++11%20%E6%96%B0%E7%94%A8%E6%B3%95/"},{"title":"Golang中的匿名函数、闭包、defer、panic、recover","text":"匿名函数12345678910package mainimport \"fmt\"func main() { f := func() { fmt.Println(\"test\") } f()} 闭包下面代码中，输出的三个x的地址一定是一样的，它们引用同一个变量。 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() { f := closure(10) fmt.Println(f(1)) fmt.Println(f(2))}func closure(x int) func(int) int { fmt.Println(&amp;x) return func(y int) int { fmt.Println(&amp;x) return x + y }}/* possible output:0xc0000600680xc000060068110xc00006006812*/ defer 执行方式类似其它语言中的析构函数，在函数体执行结束后按照调用顺序的相反顺序逐个执行 即使函数发生严重错误也会执行 支持匿名函数的调用 常用于资源清理、文件关闭、解锁以及记录时间等操作 通过与匿名函数配合可在return之后修改函数计算结果 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址 下面这个代码中，defer时i就传值进去了。所以输出210。 123456789package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer fmt.Print(i) }} 下面这个代码中，由于闭包中的i是对main函数中局部变量i的引用。defer在main函数结束后执行，而main函数结束时i的值已经为3。所以输出3次3。 1234567891011package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer func() { fmt.Println(i) }() }} 下面这个代码中，闭包里每一次传递的string事实上都不是同一个。所以输出的是ans2 ans1 ans0。 123456789101112131415package mainimport ( \"fmt\" \"strconv\")func main() { for i := 0; i &lt; 3; i++ { var t string = \"ans\" + strconv.Itoa(i) defer func() { fmt.Print(t + \" \") }() }} defer配合panic与recover123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"func main() { f1() f2() f3()}func f1() { fmt.Println(\"func f1\")}func f2() { // defer 一定要在 panic 之前, 因为 panic 触发时 // panic 所在函数就会立刻终止并倒序调用所有已经存在的defer // 若 defer 在 panic 之后, 程序根本不会知道后面有 defer defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (first)\") } }() defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (second)\") } }() panic(\"panic in f2\")}func f3() { fmt.Println(\"func f3\")}/* output:func f1err = panic in f2recover in f2 (second)func f3*/","link":"/2020/03/05/Golang%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81defer%E3%80%81panic%E3%80%81recover/"},{"title":"STL中_Rb_tree的探索","text":"我们知道STL中我们常用的set与multiset和map与multimap都是基于红黑树。本文介绍了它们的在STL中的底层数据结构_Rb_tree的直接用法与部分函数。难点主要是_Rb_tree的各个参数的确定。 特别注意在如下代码的Selector类用于从Node中选出用于排序的key值，这个仿函数必须返回const int&amp;而不能是int，否则less&lt;int&gt;::operator(const int&amp;, const int&amp;)会抛出segmentation fault。由于源码中逻辑比较复杂，但是可以观察到内部涉及这方面的地方经常使用到指针。所以可以推测是因为引用了已经释放的局部变量所以才抛出的segmentation fault。一开始写成int，看了很多源码才发现是这个原因，一定要注意。 接下来是样例代码，里面都有注释了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;iomanip&gt;// 原则上不要直接引用这个头文件，这里只是为了测试#include &lt;bits/stl_tree.h&gt;using namespace std;struct Node { int first, second; Node(int _first, int _second) : first(_first), second(_second){}; friend ostream&amp; operator&lt;&lt;(ostream&amp; outs, const Node&amp; node) { outs &lt;&lt; '{' &lt;&lt; node.first &lt;&lt; ',' &lt;&lt; node.second &lt;&lt; '}'; return outs; }};template &lt;class T&gt;struct Selector { // MUST return const int&amp;, not int. // if return int, segmentation fault will occur. // I have spent much time because of this. const int&amp; operator()(const T&amp; obj) const { return obj.first; }};int main() { // _Rb_tree: red-black tree in STL. using tree_type = _Rb_tree&lt;int, Node, Selector&lt;Node&gt;, less&lt;int&gt;&gt;; using iterator_type = tree_type::iterator; using result_pair_type = pair&lt;tree_type::iterator, bool&gt;; tree_type tree; // 插入元素Node(1, 2) result_pair_type res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert address = \" &lt;&lt; res.first._M_node &lt;&lt; endl; cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // true iterator_type it = tree.begin(); cout &lt;&lt; \"begin address = \" &lt;&lt; it._M_node &lt;&lt; endl; it = tree.find(1); cout &lt;&lt; \"address = \" &lt;&lt; it._M_node &lt;&lt; \", value = \" &lt;&lt; *it &lt;&lt; endl; // 再插入元素Node(1, 2)但是因为调用的是insert_unique // 它不会添加重复值，所以插入会被拒绝 res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // false // 再插入元素Node(1, 2)但这次调用insert_equal // multiset和multimap就是利用这个函数来插入重复值 // 也就是这个函数允许重复值，所以插入成功 tree._M_insert_equal(Node(1, 3)); cout &lt;&lt; \"size = \" &lt;&lt; tree.size() &lt;&lt; endl; // 大小就变为2 pair&lt;iterator_type, iterator_type&gt; result = tree.equal_range(1); for (iterator_type ite = result.first; ite != result.second; ++ite) { cout &lt;&lt; \"address = \" &lt;&lt; ite._M_node &lt;&lt; \", value = \" &lt;&lt; *ite &lt;&lt; endl; } return 0;} 程序的输出为（内存地址不定）： 12345678insert address = 0xf91be0insert result = truebegin address = 0xf91be0address = 0xf91be0, value = {1,2}insert result = falsesize = 2address = 0xf91be0, value = {1,2}address = 0xf91c10, value = {1,3}","link":"/2020/02/20/STL%E4%B8%AD_Rb_tree%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"title":"FJUTOJ-3682-LRU算法的实现2","text":"传送门 此题让我们实现一个LRU的模板类。本题较简便且高效的写法是维护一个std::list和一个std::unordered_map。 std::list 与 std::unordered_map 中存放的内容std::list中存放各key，类型为K。链表中各键码存放的顺序是按照访问顺序存放的。 std::unordered_map中以key为第一维，第二维为一个pair，其first和second分别为： first: 该key对应的value。 second:该key在std::list中的迭代器方便访问。 为方便，下面用“链表”来指代std::list，用“哈希表”来指代std::unordered_map。 各操作实现insert操作：用哈希表判断该键是否已经存在。若存在，先在链表中删除该key，然后再新加一个该key到链表尾部，并更新在哈希表中的value和链表的迭代器。若不存在，则直接加至链表尾部，并在哈希表中插入该key，伴随着对应的value和链表迭代器。 get操作：直接从哈希表中获得其value即可。代码实现未检测该key是否存在，严谨来说应该加上异常处理。 contains操作：直接在哈希表中查询是否存在该key即可。 vis操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，然后再将其加至链表尾部，并更新哈希表中对应链表迭代器。 pop操作：判断是否整个容器已经为空。若为空，则本操作无效。否则，将链表头部元素从链表中删除，并在哈希表中删除对应键值信息。 remove操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，并在哈希表中删除对应键值信息。 empty操作：哈希表或链表判空即可。 size操作：取哈希表或链表大小即可。 clear操作：清空哈希表和链表即可。 时间复杂度各操作基于对链表和哈希表的修改。期望复杂度均为$O(1)$。 参考代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;list&gt;#include &lt;unordered_map&gt;template &lt;typename K, typename V&gt;class LRU {private: typedef typename std::list&lt;K&gt;::iterator listIter; typedef typename std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt;::iterator unorderedMapIter; std::list&lt;K&gt; lst; std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt; mp;public: void insert(const K &amp;key, const V &amp;value) { unorderedMapIter it = mp.find(key); if (it == mp.end()) { lst.emplace_back(key); mp.insert(std::make_pair(key, std::make_pair(value, --lst.end()))); } else { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second = std::make_pair(value, --lst.end()); } } // If Key doesn't exist, this will create one &lt;Key, zero&gt; V get(const K &amp;key) { return mp[key].first; } bool contains(const K &amp;key) { return mp.count(key) == 1; } void vis(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second.second = --lst.end(); } } void pop() { if (!lst.empty()) { mp.erase(lst.front()); lst.pop_front(); } } void remove(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); mp.erase(it); } } bool emtpy() { // 本题要求此函数名为emtpy return lst.empty(); } unsigned long long size() { return lst.size(); } void clear() { lst.clear(); mp.clear(); }};","link":"/2019/03/16/FJUTOJ-3682-LRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B02/"},{"title":"C++引用的实现","text":"当我学习C++引用时，听到的第一句话是“引用是变量的别名，不像指针一样需要占用内存空间”。然而学到深处，发现此话并不完全正确。 本文主要介绍我如何通过实验来了解到C++引用的实现，其实引用的内部就是指针。当然这也于编译器有关，所以这里需要提及一下测试所用的编译器及环境。 测试环境是MinGW的g++ 8.1.0，64位编译器，64位的机子。所以指针的大小是8个字节，即64个bit。（注：因为目的是测试，所以测试时并没有处理对new操作符所产生对象的回收） 首先我写出了如下代码，试图通过指针偏移来获取有关引用的信息： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int64_t x; string&amp; str = *new string(); int64_t y; cin &gt;&gt; str; // 对引用做一次操作，避免编译器把变量优化掉 cout &lt;&lt; &amp;x &lt;&lt; endl; cout &lt;&lt; &amp;y &lt;&lt; endl; cout &lt;&lt; str &lt;&lt; endl; return 0;} 然而，这个程序的输出如下（str的输出忽略）： 120x61fe000x61fdf8 难道引用真的不占内存？编译器真的很聪明，可能优化掉了吧；经过一系列尝试，我写出了另外一段代码： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void foo(int64_t q, string&amp; s, int64_t r) { cout &lt;&lt; \"&amp;q: \" &lt;&lt; &amp;q &lt;&lt; endl; cout &lt;&lt; \"&amp;r: \" &lt;&lt; &amp;r &lt;&lt; endl; cout &lt;&lt; \"*(string**)(&amp;q + 1): \" &lt;&lt; *(string**)(&amp;q + 1) &lt;&lt; endl;}int main(){ string&amp; str = *new string(); cout &lt;&lt; \"main(): \" &lt;&lt; &amp;str &lt;&lt; endl; foo(0, str, 0); return 0;} 这段代码的输出是： 1234main(): 0x1e1bd0&amp;q: 0x61fde0&amp;r: 0x61fdf0*(string**)(&amp;q + 1): 0x1e1bd0 可见，q的地址是0x61fde0，r的地址是0x61fdf0。两个地址间相差16个字节！这里引用占用的内存出来了。显然引用对应的指针存储在q的8个字节之后。我们可以将q的地址加1，也就是加上8个字节，这里存储的就是引用的信息。假设它就是指针，那么考虑：(&amp;q + 1)本身是一个指向string*的指针，也就是string**。所以若要获取指针的值，需要对这个值解一次引用，输出出来。（当然如果你想简单一点，可以直接把它转成int64_t然后用16进制输出亦可） 至此真相大白，程序输出的最后一行0x1e1bd0与主函数中new出来的对象的地址（见输出第一行）一致。所以得出结论：引用是用指针实现的。用户对引用的访问操作都内含一次解引用，而这对用户来说是透明的。 不过需要提及的是，回想本文的第一个测试，发现引用的指针空间被优化掉了。所以引用有时也不一定会在栈上真正以指针体现出来。","link":"/2020/03/07/C++%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"TCP/IP学习笔记：HTTP","text":"报文格式请求报文12345GET /somedir/page.html HTTP/1.1Host: www.someschool.eduConnection: closeUser-agent: Mozilla/5.0Accept-language: fr 第一行叫做请求行，其后继的行叫做首部行。首部行中，冒号左边的称为首部字段名，右边称为值。 请求行 方法字段 GET：浏览器请求一个对象。 POST：当用户提交表单时，HTTP客户常使用POST方法，表单中的值存放在实体体中。 HEAD：类似于GET方法，当服务器收到一个HEAD请求时，将对用一个HTTP报文进行响应，但是不返回请求对象。 PUT：用户上传对象到指定的Web服务器上的指定路径（目录）。 DELETE：用户或应用程序删除Web服务器上的对象。 URL字段：例子中的/somedir/page.html。 版本字段：例子中的HTTP/1.1。 首部行 Host：指明对象所在的主机。 Connection: close告诉服务器不要使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。 User-agent：指明用户代理，即向服务器发送请求的浏览器类型。这里的Mozilla/5.0就是Firefox浏览器。 Accept-language：用户想得到的对象的语言，如这里的Fr即指法语版本。若服务器中没有这样的对象，那么服务器应当发送它的默认版本。 If-modified-since：（条件GET方法）若服务器上的对象在此日期之后被修改，服务器才会传回新对象，否则服务器返回304 Not Modified。这个日期通常来源于之前请求时得到的响应报文中的Last-modified首部行。 cookie：本机对应本站点的cookie。 实体体（可以不存在） ​ 如上所述，实体体通常含通过POST方法发送的表单信息。 一个HTTP请求报文的通用格式为： 1234567&lt;方法&gt; &lt;URL&gt; &lt;版本&gt;\\r\\n&lt;首部字段名:&gt; &lt;值&gt;\\r\\n&lt;首部字段名:&gt; &lt;值&gt;\\r\\n...&lt;首部字段名:&gt; &lt;值&gt;\\r\\n\\r\\n&lt;实体体&gt; 响应报文下面这个报文可以是对上述请求报文例子的回应。 12345678HTTP/1.1 200 OKConnection: closeDate: Tue, 18 Aug 2015 15:44:04 GMTServer: Apache/2.2.3 (CentOS)Last-Modified: Tue, 18 Aug 2015, 15:11:03 GMTContent-Length: 6821Content-Type: text/html(data data data data data ...) 这个例子中，第1行称为状态行，第2-7行称为首部行，接下来是实体体。实体体部分是报文的主要部分，它包含了所请求的对象本身（表示为data data data data data ...）。 状态行 协议版本字段（HTTP/1.1） 状态码（200） 常见的状态码： 状态码&amp;短语 含义 200 OK 请求成功，信息在返回的响应报文中。 301 Moved Permanently 请求的对象已经被永久转移，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。 304 Not Modified 告诉缓存器可以使用原有对象。 400 Bad Request 一个通用差错代码，指示该请求不能被服务器理解。 404 Not Found 被请求的文档不在服务器上。 505 HTTP Version Not Supported 服务器不支持请求报文使用的HTTP协议版本。 相应状态信息（OK） 首部行 Connection: close告诉客户发送完报文后将关闭该TCP连接。 Date：服务器产生并发送该响应报文的日期和时间。（不是对象创建或最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间） Server：生成该报文的服务器信息。（与请求报文中的User-agent对应） Last-Modified：对象创建或最后修改的日期和时间。（对对象缓存很重要） Content-Length：被发送对象的字节数。 Content-Type：对象类型。这里对象类型是HTML文本。（对象类型应该正式地由Content-Type首部行而不是用文件扩展名来指示） Set-cookie：设置cookie。 实体体（可以不存在） ​ 含有对象内容。 参考资料《计算机网络：自顶向下方法（原书第7版）》P64-75","link":"/2020/03/28/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP/"},{"title":"multimap与multiset","text":"multimap介绍基本与 map 相同，但除去了 operator[]， 因为其特点是相同 key 的值在 multimap 中可以多个存在。需要强调的，与 map 有明显不同的常用方法： 常用方法iterator insert(value) 插入键值对，返回插入后该元素的迭代器 size_type erase(key) 删除所有关键字与 key 相等的键值对，返回删除的元素个数 void erase(iterator pos) 删除对应位置元素 size_type count(key) 统计关键字为 key 的元素个数 iterator find(key) 查找关键字与 key 相等的键值对，返回对应位置的迭代器。如果不存在则返回 end() 。如果有多个关键字与 key 相等的键值对，返回的迭代器指向哪一个不定。 pair&lt;iterator, iterator&gt; equal_range(key) 查找关键字与 key 相等的键值对，返回迭代器对，描述与 key 相等的键值对的区间 [first, last) 。 代码示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef multimap&lt;int, char&gt;::iterator iterType;int main() { multimap&lt;int, char&gt; mp; mp.insert(make_pair(1, 'A')); mp.insert(make_pair(2, 'B')); mp.insert(make_pair(2, 'C')); mp.insert(make_pair(2, 'D')); mp.insert(make_pair(4, 'E')); mp.insert(make_pair(3, 'F')); pair&lt;iterType, iterType&gt; range = mp.equal_range(2); for (iterType it = range.first; it != range.second; ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n'; } return 0;} 12345output2 B2 C2 D multiset介绍与上述 multimap 的用法基本相同，只是每个元素只有一个值 key，而没有对应的 value。","link":"/2019/08/06/multimap%E4%B8%8Emultiset/"},{"title":"《深度探索C++对象模型》学习笔记","text":"3 Data语义学3.6 指向 data-member 的指针取一个非静态数据成员的地址将会得到它在类中的偏移量。 下面代码中数据成员指针的类型为：float Point3d::*。有些编译器返回的偏移量总是多1，因为考虑到不指向任何成员的指针应为0。如果不加1，有可能导致第一个数据成员成员的指针和不指向任何成员的指针相等，都为0。（此时说它是偏移量就有些不合适） 123456789101112131415161718192021222324252627282930313233343536373839// G++ 8.1.0, 64-bit#include &lt;iostream&gt;using namespace std;class Point3d { public: virtual ~Point3d() {} static Point3d origin; float x, y, z;};struct Base1 { int val1;};struct Base2 { int val2;};struct Derived : Base1, Base2 { int val3;};Point3d Point3d::origin;#define show(ptrToDataMember) printf(#ptrToDataMember \" = %d\\n\", ptrToDataMember)int main() { // 注意不能用 cout &lt;&lt; &amp;Point3d::x，会匹配到 operator&lt;&lt;(bool) // 为了简便，这里定义宏（与书上不同） show(&amp;Point3d::x); // 8 show(&amp;Point3d::y); // 12 show(&amp;Point3d::z); // 16 show(&amp;Base1::val1); // 0 show(&amp;Base2::val2); // 0 show(&amp;Derived::val1); // 0 show(&amp;Derived::val2); // 0（比较奇怪） show(&amp;Derived::val3); // 8 return 0;} 个人感觉，成员指针并不能拿来输出。所以输出什么值也只能作为参考，便于理解这个概念。事实上，我觉得cout给出了正确的行为。它将一个成员指针视为bool，以表示其是否真正有效。即 123456789101112struct Base1 { int val1;};int main() { int Base1::* p = 0; cout &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; endl; // false p = &amp;Base1::val1; printf(\"%d\\n\", p); // 0 cout &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; endl; // true return 0;}","link":"/2020/03/12/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"bitset","text":"用处一含有特定二进制位数 N 的容器，相当于 bool 数组，但压缩内存至每一个二进制位。 申明bitset&lt;N&gt; bset，其中 N 为字面常量，表示 bitset 中的二进制位个数。如 bitset&lt;10&gt; bset; 常用方法bitset(unsigned long val) 用 val 构造一个对应的 bitset (至 C++11 前) bitset(unsigned long long val) 用 val 构造一个对应的 bitset (自 C++11 始) bitset(string val) 用 val 构造一个对应的 bitset bool operator[] 获取特定二进制位的值 bool test(pos) 获取特定二进制位的值，但有越界检查：如果越界，抛出 std::out_of_range 异常。 bool all() 是否所有二进制位都是1 (自 C++11) bool any() 是否有二进制位是1 bool none() 是否所有二进制位都是0 size_t count() 返回二进制位是1的二进制位个数 size_t size() 返回 N bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; other) 与操作 bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; other) 或操作 bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; other) 异或操作 bitset&lt;N&gt; operator~() 非操作 bitset&lt;N&gt; operator&lt;&lt;(size_t pos) 左移 bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) 自左移 bitset&lt;N&gt; operator&gt;&gt;(size_t pos) 右移 bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) 自右移 bitset&lt;N&gt;&amp; set() 将全部位设为1 bitset&lt;N&gt;&amp; set(pos, value) 将pos位设为 value bitset&lt;N&gt;&amp; reset() 将全部位设为0 bitset&lt;N&gt;&amp; reset(pos) 将pos位设为0 bitset&lt;N&gt;&amp; flip() 翻转所有位（与 operator~ 类似，但是是直接在原数上进行） bitset&lt;N&gt; &amp;flip(pos) 翻转第pos位 string to_string(char zero = '0', char one = '1') 转为字符串 unsigned long to_ulong() 转为 unsigned long ，若溢出则抛出 std::overflow_error unsigned long long to_ullong() 转为 unsigned long long ，若溢出则抛出 std::overflow_error (自C++11) 代码示例12345678910#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() { bitset&lt;10&gt; bset(15); cout &lt;&lt; bset &lt;&lt; '\\n'; // output: 0000001111 return 0;}","link":"/2019/08/06/bitset/"},{"title":"Valgrind安装与memcheck简单使用","text":"安装 valgrindsudo apt install valgrind 安装后，查看一下版本以确认安装成功 valgrind --version 输出形如以下版本号信息就表示安装成功 1valgrind-3.11.0 使用 memcheck 检查内存泄漏memleak.cpp 12345678910111213141516171819202122232425262728293031class A {public: A() { a_arr = new int[5]; } ~A() { delete[] a_arr; }private: int* a_arr;};class B : public A {public: B() { b_arr = new int[3]; } ~B() { delete[] b_arr; }private: int* b_arr;};int main() { A* pa = new B(); delete pa; return 0;} 12g++ -g memleak.cpp -o memleakvalgrind --tool=memcheck ./memleak 其中 --tool=memcheck 可以省略，因为 valgrind 的默认工具就是 memcheck 。可以检查出类B对象中的12个字节（3个int）内存泄漏（见下方 definitely lost ）： 1234567891011121314151617181920==7661== Memcheck, a memory error detector==7661== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.==7661== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info==7661== Command: ./memleak==7661====7661====7661== HEAP SUMMARY:==7661== in use at exit: 72,716 bytes in 2 blocks==7661== total heap usage: 4 allocs, 2 frees, 72,752 bytes allocated==7661====7661== LEAK SUMMARY:==7661== definitely lost: 12 bytes in 1 blocks==7661== indirectly lost: 0 bytes in 0 blocks==7661== possibly lost: 0 bytes in 0 blocks==7661== still reachable: 72,704 bytes in 1 blocks==7661== suppressed: 0 bytes in 0 blocks==7661== Rerun with --leak-check=full to see details of leaked memory==7661====7661== For counts of detected and suppressed errors, rerun with: -v==7661== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 使用 memcheck 检查 overlapstrncpy.cpp 1234567891011121314151617#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main() { char s[60]; memset(s, '*', sizeof(s)); strcpy(s, \"abcdefghijklmnopqrstuvwxyz\"); strncpy(s + 26, s, 26); for (int i = 0; i &lt; 60; i++) cout &lt;&lt; (s[i] ? s[i] : '_'); cout &lt;&lt; '\\n'; strncpy(s + 26, s, 27); for (int i = 0; i &lt; 60; i++) cout &lt;&lt; (s[i] ? s[i] : '_'); cout &lt;&lt; '\\n'; return 0;} 12g++ -g strncpy.cpp -o strncpyvalgrind --tool=memcheck ./strncpy 此时memcheck会检查出重叠（overlap）错误。输出如下 123==7561== Source and destination overlap in strncpy(0xfff0003d5, 0xfff0003bb, 27)==7561== at 0x4C31626: __strncpy_sse2_unaligned (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==7561== by 0x400951: main (strncpy.cpp:13)","link":"/2020/03/23/Valgrind%E5%AE%89%E8%A3%85%E4%B8%8Ememcheck%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"TCP/IP学习笔记：DNS","text":"概述DNS：Domain Name System，域名系统。它是： 一个由分层的DNS服务器（DNS Server）实现的分布式数据库； 一个使得主机能够查询分布式数据库的应用层协议。 它运行在UDP之上，使用53号端口。 它提供的服务： 主机名到IP地址转换的目录服务。 主机别名。有着复杂主机名的主机能拥有一个或多个别名。复杂主机名也称为规范主机名。如果存在主机别名，主机别名比规范主机名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址。 邮件服务器别名。电子邮件应用程序可以调用DNS，对提供的主机名别名（如yahoo.com）进行解析，已获得该主机的规范主机名（如relay1.west-coast.hotmail.com）及其IP地址。 负载分配。DNS也用在冗余的服务器（如冗余的Web服务器）之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。由于这些冗余的Web服务器，一个IP地址集合因此与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。 域名空间 图源：《TCP/IP详解 卷1：协议》 DNS的分布式、层次数据库大致说来，在DNS服务器的层次结构中有3种类型的DNS服务器： 根DNS服务器：提供TLD服务器的IP地址。 顶级域名（Top-Level-Domain, TLD）DNS服务器：提供权威DNS服务器的IP地址。 权威DNS服务器：在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。一个组织机构的权威DNS服务器收藏了这些DNS记录。 还有一类重要的DNS服务器，严格而言它不属于DNS服务器的层次结构，但它对DNS层次结构至关重要。这一类DNS服务器是本地DNS服务器。每个ISP（如一个居民区的ISP或一个机构的ISP）都有一台本地DNS服务器（也叫默认名字服务器）。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址（通常通过DHCP）。主机的本地DNS服务器通常“临近”本主机：对某机构ISP而言，本地DNS服务器可能就与主机在同一局域网中；对于某居民区ISP来说，本地DNS服务器通常与主机相隔不超过几台路由器。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。 查询分为递归查询与迭代查询。 （具体例子见 《计算机网络：自顶向下方法（原书第7版）》P86-88） DNS缓存在一个请求链中，当某DNS服务器接收一个DNS回答（如包含某主机名到IP地址的映射）时，它能将映射缓存在本地存储器中。由于主机和主机名与IP地址间的映射不是永久的，所以DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。 本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器基本都被绕过了。 DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。资源记录是一个包含了以下字段的4元组： (Name, Value, Type, TTL) TTL 该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。 Name、Value、Type 若Type=A，则Name是主机名，Value是该主机名对应的IP地址。该类型的资源记录提供了标准的主机名到IP地址的映射。如(relay1.bar.foo.com, 145.37.93.126, A)。 若Type=NS，则Name是个域（如foo.com），而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。如(foo.com, dns.foo.com, NS)。 若Type=CNAME，则Value是别名为Name的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如(foo.com, relay1.bar.foo.com, CNAME)。 若Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。如(foo.com, mail.bar.foo.com, MX)。通过使用MX记录，一个公司的邮件服务器和其他服务器（如Web服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录。 参考资料《计算机网络：自顶向下方法（原书第7版）》P83-92","link":"/2020/03/29/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ADNS/"},{"title":"后缀数组","text":"相关定义及其证明sa 后缀数组 suffix array保存 $0 \\sim n-1$ 的全排列，含义是把所有后缀按字典序排序后，后缀在原串中的位置。$suffix(sa[i]) &lt; suffix(sa[i + 1])$ $sa[,]$ 记录位置，即“排第i的后缀是谁”。 rk 名次数组 rank array保存 $0 \\sim n-1$ 的全排列，$rk[i]$ 的含义是 $suffix(i)$ 在所有后缀中按字典序排序的名次。 $rk[,]$ 记录排名，即“第以第i个字符起始的后缀子串在所有后缀子串中排第几”。 sa 与 rk 的关系$sa[,]$ 与 $rk[,]$ 是一一对应的关系，且互为逆运算。于是 可用 $rk[,]$ 推导 $sa[,]$： for (int i = 0; i &lt; n; ++i) sa[rk[i]] = i; 可用 $sa[,]$ 推导 $rk[,]$： for (int i = 0; i &lt; n; ++i) rk[sa[i]] = i; LCP 最长公共前缀LCP 即 Longest Common Prefix，最长公共前缀。 记 $LCP(i, j)$ 为 $suffix(sa[i])$ 与 $suffix(sa[j])$ 的最长公共前缀长度，即排序后第 $i$ 个后缀与第 $j$ 个后缀的最长公共前缀长度 LCP Lemma (LCP引理)若 $0 \\lt i \\lt j \\lt k \\le n-1$，则 $LCP(i, k) = min{LCP(i, j),,LCP(j, k)}$。 证明： 设 $p=min{LCP(i, j), LCP(j, k)}$ ，则 $LCP(i, j) \\ge p ,;LCP(j, k) \\ge p$。 又设 $suffix(sa[i])=u,;suffix(sa[j])=v,;suffix(sa[k])=w$ ①。 我们记 $a=_{len}b$表示字符串 $a$ 长度为 $len$ 的前缀与字符串 $b$ 的长度为 $len$ 的前缀相等。 则由 $u={LCP(i,j)}v$ 可得 $u={p}v, ; v=_{p}w$ 。 于是可得 $u=_{p}w$。即 $LCP(i, k) \\ge p = min{LCP(i, j),,LCP(j, k)}$。 现在我们再证 $LCP(i,k) \\gt p$ 是不可能的。 又设存在一个 $q \\gt p$，$LCP(i, k) = q$。 则可得 $u[i] = w[i]$ 对任意 $i \\in [1, q]$ 均成立。由于 $q \\gt p$，所以上式中的一个是 $u[p+1] = w[p+1]$。 由 ① 得 $u[p+1] \\leq v[p+1] \\leq w[p+1]$。结合上一行得 $u[p+1]=v[p+1]=w[p+1]$。 而 $p=min{LCP(i, j), LCP(j, k)}$，即 $u[p+1] \\neq v[p+1]$ 或 $v[p+1] \\ne w[p+1]$。 出现矛盾，故不存在 $q$ ，使得假设 $LCP(i, k) = q \\gt p$ 成立。即得 $LCP(i, k) \\le p$。 故得 $LCP(i, k) \\ge p$ 且 $LCP(i, k) \\le p$。 最后 $LCP(i, k) = min{LCP(i, j), LCP(j, k)}$。 LCP Theorem(LCP定理)若 $i \\lt j$ 则 $LCP(i, j) = min{LCP(k - 1, k)},;i \\lt k \\le j$ 证明：由 LCP Lemma 与数学归纳法可得。 height 高度数组$height[,]$ 是一个辅助数组，和最长公共前缀 (LCP) 相关。 令 $height[i]=LCP(i-1,i),;1 \\lt i \\le n$ ，即 $suffix(sa[i-1])$ 与 $suffix(sa[i])$ 的最长公共前缀长度。 为了描述方便，记 $h[i]$ 为 $height[rank[i]]$ ，即后缀 $suffix(i)$ 与 $suffix(sa[rank[i]-1])$ 的LCP长度。 有一个很重要的性质可以让我们在 $O(N)$ 的时间内求得 $height[]$ 数组：$h[i] \\ge h[i-1] - 1$ 。 证明： 设 $suffix(k)$ 是排在 $suffix(i-1)$ 前一名的后缀，则它们的LCP长度为 $h[i-1]$。两者都去掉第一个字符，得到 $suffix(k+1)$ 与 $suffix(i)$ 。 ① 若 $h[i-1] \\le 1$ ，即 $h[i-1]-1 \\le 0$ ，则 $h[i] \\ge h[i-1] - 1$ 显然成立。 ② 若 $h[i-1] \\gt 1$ ，则在上面去掉第一个字符的过程中是去掉的两者LCP中的第一个字符，那么 $suffix(k+1)$ 与 $suffix(i)$ 的LCP长度就至少为 $h[i] \\ge [h-1]-1$ 。 故 $h[i] \\ge h[i-1]-1$ 得证。 倍增+基数排序 求 sa, rk, height 三数组个人模板，供参考。设字符串长度为 $N$，则下面代码求三数组的复杂度为 $O(N;logN)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 50;char s[N];int sa[N], rk[N], cnt[N], height[N], t1[N], t2[N];void calcSA(char *s, int n) { int m = 256; int i, *x = t1, *y = t2; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i] = s[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (i = n - k + 1; i &lt;= n; ++i) y[++p] = i; for (i = 1; i &lt;= n; ++i) if (sa[i] &gt; k) y[++p] = sa[i] - k; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[y[i]]]--] = y[i]; swap(x, y); x[sa[1]] = 1; p = 1; for (i = 2; i &lt;= n; ++i) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? p : ++p; if (p &gt;= n) break; m = p; } for (i = 1; i &lt;= n; ++i) rk[sa[i]] = i; for (int i = 1, k = 0; i &lt;= n; ++i) { if (rk[i] == 1) { height[rk[i]] = 0; } else { if (k) --k; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k; height[rk[i]] = k; } }}int main() { scanf(\"%s\", s + 1); int len = strlen(s + 1); calcSA(s, len); for (int i = 1; i &lt;= len; ++i) printf(\"%d \", sa[i]); return 0;} 后记https://www.cnblogs.com/ECJTUACM-873284962/p/6618870.html https://blog.csdn.net/qq_37774171/article/details/81776029 从上两文中做了一些参考，但部分证明感觉并不浅显易懂，在加以个人理解后最后形成此文。","link":"/2019/08/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"title":"高效随机数据生成-random与chrono","text":"请注意random库与chrono库均是C++11。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;// 生成 [a, b] 范围内的整数// 其中 INT_MIN &lt;= a &lt;= b &lt;= INT_MAXint rand(int a, int b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;int&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_INT_MAXunsigned rand(unsigned a, unsigned b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;unsigned&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 LONG_LONG_MIN &lt;= a &lt;= b &lt;= LONG_LONG_MAXLL rand(LL a, LL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;LL&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_LONG_LONG_MAXULL rand(ULL a, ULL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;ULL&gt;(a, b)(rng);}int main() { const LL MAX = 1e10; cout &lt;&lt; rand(-MAX, MAX); return 0;}","link":"/2019/08/07/%E9%AB%98%E6%95%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90-random%E4%B8%8Echrono/"},{"title":"操作系统——死锁与内存管理","text":"死锁必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 处理方法主要有以下四种方法： 鸵鸟策略 死锁检测与死锁恢复 死锁预防 死锁避免 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 1. 每种类型一个资源的死锁检测 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 2. 每种类型多个资源的死锁检测 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 3. 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 死锁预防在程序运行之前预防发生死锁。 1. 破坏互斥条件例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 2. 破坏占有和等待条件一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 3. 破坏不可抢占条件就是允许对资源实行抢夺。 4. 破坏环路等待给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免在程序运行时避免发生死锁。 1. 安全状态 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 2. 单个资源的银行家算法一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 3. 多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。 内存管理虚拟内存虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。 分页系统地址映射内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。 下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。 页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳页面置换算法（OPT, Optimal replacement algorithm）所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 17, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 最近最久未使用（LRU, Least Recently Used）虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 14, 7, 0, 7, 1, 0, 1, 2, 1, 2, 6 3. 最近未使用（NRU, Not Recently Used）每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中R 位会以一定周期T被清零。可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 4. 先进先出（FIFO, First In First Out）选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 5. 第二次机会算法（Second Chance）FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改： 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 第二次机会算法可视为一个环形队列（见下面所述“时钟”，但第二次机会算法实际上并不是环形的）。用一个指针指示哪一页是下面要淘汰的。当需要一个存储块时，指针就前进，直至找到访问位是0的页。随着指针的前进，把访问位就清为0。在最坏的情况下，所有的访问位都是1，指针要通过整个队列一周，每个页都给第二次机会。这时就退化成FIFO算法了。 6. 时钟（Clock）第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 段页式程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分页与分段的比较 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 参考资料CyC2018/CS-Notes 死锁预防 第二次机会算法","link":"/2020/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"二叉堆基础与优先队列","text":"堆是一种数据结构，而priority_queue (优先队列)是一个基于二叉堆的STL容器。 堆有很多种类，但以下提及的堆均为二叉堆。 以下是一个例子。将新元素20插入二叉堆： 所以对一个二叉堆，有3种基本操作： 插入：将 val 插入堆。 取堆顶：查看堆顶元素值。（即整个堆中最大或最小值） 出堆：将堆顶元素出堆。 大根堆参考实现代码： 1234567891011121314151617181920212223242526272829303132333435struct Heap { int heap[N], n; void clear() { n = 0; } void up(int p) { while (p &gt; 1) { if (heap[p] &gt; heap[p / 2]) { swap(heap[p], heap[p / 2]); p /= 2; } else { break; } } } void down(int p) { int s = p * 2; while (s &lt;= n) { if (s &lt; n &amp;&amp; heap[s] &lt; heap[s + 1]) ++s; if (heap[s] &gt; heap[p]) { swap(heap[s], heap[p]); p = s; s = p * 2; } else { break; } } } void insert(int val) { heap[++n] = val; up(n); } void pop() { heap[1] = heap[n--]; down(1); }}; 但在 C++ STL中，我们有 priority_queue 。所以我们通常就直接使用它，而不会手敲二叉堆（但是至少应该知道优先队列的工作原理）。 请注意 priority_queue 的堆顶默认是整个堆中的最大值（即默认大根堆，反过来的叫小根堆）。 priority_queue 有以下方法： push(val): 将 val 插入堆。$O(logN)$ top(): 查看堆顶元素值。（即整个堆中最大或最小值）$O(1)$ pop(): 将堆顶元素出堆。$O(logN)$ size(): 取堆大小。$O(1)$ empty(): 判断堆是否为空。$O(1)$ 有时我们需要（重新）定义小于号以使用 priority_queue 。有很多种方法可以实现对小于号的重载，如 bool operator&lt; friend bool operator&lt; bool operator() 以下是练习题： POJ-1338, HDOJ-4006, POJ-3253, HDOJ-1873, HDOJ-1509, POJ-1442, HDOJ-1896, POJ-1456 另外，与二叉堆关系密切的一个经典问题是: 哈夫曼树 (Huffman Tree). 如 T^TOJ-3810. 部分练习题参考代码 POJ-1338 [Ugly Numbers] 参考代码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; q;vector&lt;LL&gt; v;int main() { int n; q.push(1); while (q.size() &lt; 1500) { LL val = q.top(); q.pop(); if (!v.empty() &amp;&amp; v.back() == val) continue; v.push_back(val); q.push(val * 2); q.push(val * 3); q.push(val * 5); } while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { printf(\"%lld\\n\", v[n - 1]); } return 0;} HDOJ-4006 [The kth great number] 参考代码 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;int main() { int n, k, num; char op[3]; while (~scanf(\"%d %d\", &amp;n, &amp;k)) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; while (n--) { while (q.size() &gt; k) q.pop(); scanf(\"%s\", op); if (op[0] == 'I') { scanf(\"%d\", &amp;num); q.push(num); } else { printf(\"%d\\n\", q.top()); } } } return 0;}","link":"/2019/07/23/%E4%BA%8C%E5%8F%89%E5%A0%86%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"title":"操作系统——设备管理与链接","text":"设备管理磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 1. 先来先服务（FCFS, First Come First Served）按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先（SSTF, Shortest Seek Time First）优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 3. 电梯算法（SCAN）电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。 链接编译系统以下是一个 hello.c 程序： 123456#include &lt;stdio.h&gt;int main() { printf(\"hello, world\\n\"); return 0;} 在 Unix 系统上，由编译器把源文件转换为目标文件。 1gcc -o hello hello.c 这个过程大致如下： 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 静态链接静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务： 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 图源：深入理解计算机系统(原书第3版) Commonly used in makefiles: LD is a linker (comes from “link editor” or from “loader”). AS ia asn assembly language compiler. CC stands for “C compiler” (in GCC abbreviation it is also treated as “compiler collection”). CPP stands for “C preprocessor”. 目标文件 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 动态链接静态库有以下两个问题： 当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。 so = Shared ObjectDLL = Dynamic Link Library 共享库具有以下特点： 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 参考资料CyC2018/CS-Notes In makefiles what do CC and LD stand for? - Stack Overflow 深入理解计算机系统（原书第3版）","link":"/2020/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E4%B8%8E%E9%93%BE%E6%8E%A5/"},{"title":"操作系统——进程管理","text":"进程与线程概念进程是资源分配的基本单位；线程是独立调度的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 区别Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（Inter-Process Communication，进程间通信，提供了各种进程间通信的方法）。 进程调度算法不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 批处理系统 批处理系统，又名批处理操作系统。批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统。批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统。批处理操作系统分为单道批处理系统和多道批处理系统。 在单道批处理系统中，内存中仅有一道作业，它无法充分利用系统中的所有资源，致使系统性能较差。为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期又引入了多道程序设计技术，由此而形成了多道批处理系统。 多道批处理系统有两个特点： 多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。 成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。 1.1 先来先服务 First Come First Served（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 Shortest Job First（SJF） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 Shortest Remaining Time Next（SRTN） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 交互式系统 交互式计算机系统与操作人员以人机对话的方式一问一答，直至获得最后处理结果。采用这种方式，程序设计人员可以边设计，边调整，边修改，使错误和不足之处及时得到改正和补充。特别对于非专业的操作人员，系统能提供提示信息，逐步引导操作者完成所需的操作，得出处理结果。 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,.. （不一定，只要队列时间片大小递增即可）。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次（1+2+4+8+16+32+64=127）。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 实时系统实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section// exit section 同步与互斥 同步：多个进程按一定顺序执行； 互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量概念信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() { down(&amp;mutex); // 临界区 up(&amp;mutex);}void P2() { down(&amp;mutex); // 临界区 up(&amp;mutex);} 使用信号量实现生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() { while (true) { int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); }}void consumer() { while (true) { down(&amp;full); down(&amp;mutex); int item = remove_item(); consume_item(item); up(&amp;mutex); up(&amp;empty); }} 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程（monitor）把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 C 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait(x) 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal(x) 操作用于唤醒被 wait(x) 阻塞的进程。 使用管程实现生产者-消费者问题123456789101112131415161718192021222324252627282930313233343536373839404142// 管程monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 经典同步问题生产者和消费者问题前面已经讨论过了。 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1; // 对 count 加锁semaphore data_mutex = 1; // 对读写的数据加锁int count = 0;void reader() { while (true) { down(&amp;count_mutex); count++; if (count == 1) down(&amp;data_mutex); // 第一个读者需要对数据加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if (count == 0) up(&amp;data_mutex); up(&amp;count_mutex); }}void writer() { while (true) { down(&amp;data_mutex); write(); up(&amp;data_mutex); }} 哲学家进餐问题五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) { while (true) { think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); }} 为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态,一开始都是THINKINGsemaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) { // 哲学家 while (true) { think(); take_two(i); eat(); put_two(i); }}void take_two(int i) { down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);}void put_two(int i) { down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);}void test(int i) { // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) { state[i] = EATING; up(&amp;s[i]); }} 进程通信进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 12#include &lt;unistd.h&gt;int pipe(int fd[2]); 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 FIFO也称为命名管道，去除了管道只能在父子进程中使用的限制。 123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 信号量它是一个计数器，用于为多个进程提供对共享数据对象的访问。 共享存储允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 套接字与其它通信机制不同的是，它可用于不同机器间的进程通信。 参考资料CyC2018/CS-Notes 批处理系统 单道批处理系统 多道批处理系统 交互式系统","link":"/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"LeetCode 4月份每日一题题解","text":"Apr.1 有效括号的嵌套深度由于所给的字符串保证是有效括号字符串，所以将每个括号尽量平均分配即可。官方题解中考虑的奇偶性更巧妙，但不容易想到。 1234567891011121314151617181920212223// 0 ms, 7.3 MBclass Solution {public: vector&lt;int&gt; maxDepthAfterSplit(string seq) { const int n = seq.size(); vector&lt;int&gt; res; res.reserve(n); int depth[2] = {}; for (int i = 0; i &lt; n; i++) { if (seq[i] == '(') { int smallId = depth[0] &gt; depth[1]; res.push_back(smallId); ++depth[smallId]; } else { int bigId = depth[0] &lt; depth[1]; res.push_back(bigId); --depth[bigId]; } } return res; }}; Apr.2 生命游戏按照题意模拟即可。下面给出的是原地算法。 123456789101112131415161718192021222324252627282930313233343536373839// 0 ms, 6.9 MBclass Solution {public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) { if (board.empty()) return; const int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1}; const int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1}; const int m = board.size(); const int n = board[0].size(); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { int aliveCount = 0; for (int k = 0; k &lt; 8; k++) { int x = i + dx[k], y = j + dy[k]; if (0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; isAlive(board[x][y])) { ++aliveCount; } } if (board[i][j]) { // 第1位表示当前状态，第2位表示下一状态 if (aliveCount == 2 || aliveCount == 3) board[i][j] |= 2; } else { if (aliveCount == 3) board[i][j] |= 2; } } } for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) board[i][j] &gt;&gt;= 1; // 取下一状态 }private: bool isAlive(int value) { return value &amp; 1; }};","link":"/2020/04/01/LeetCode/4%E6%9C%88%E4%BB%BD%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","link":"/tags/Valgrind/"},{"name":"memcheck","slug":"memcheck","link":"/tags/memcheck/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/categories/TCP-IP/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}