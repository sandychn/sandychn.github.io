{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"bitset","text":"用处一含有特定二进制位数 N 的容器，相当于 bool 数组，但压缩内存至每一个二进制位。 申明bitset&lt;N&gt; bset，其中 N 为字面常量，表示 bitset 中的二进制位个数。如 bitset&lt;10&gt; bset; 常用方法bitset(unsigned long val) 用 val 构造一个对应的 bitset (至 C++11 前) bitset(unsigned long long val) 用 val 构造一个对应的 bitset (自 C++11 始) bitset(string val) 用 val 构造一个对应的 bitset bool operator[] 获取特定二进制位的值 bool test(pos) 获取特定二进制位的值，但有越界检查：如果越界，抛出 std::out_of_range 异常。 bool all() 是否所有二进制位都是1 (自 C++11) bool any() 是否有二进制位是1 bool none() 是否所有二进制位都是0 size_t count() 返回二进制位是1的二进制位个数 size_t size() 返回 N bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; other) 与操作 bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; other) 或操作 bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; other) 异或操作 bitset&lt;N&gt; operator~() 非操作 bitset&lt;N&gt; operator&lt;&lt;(size_t pos) 左移 bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) 自左移 bitset&lt;N&gt; operator&gt;&gt;(size_t pos) 右移 bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) 自右移 bitset&lt;N&gt;&amp; set() 将全部位设为1 bitset&lt;N&gt;&amp; set(pos, value) 将pos位设为 value bitset&lt;N&gt;&amp; reset() 将全部位设为0 bitset&lt;N&gt;&amp; reset(pos) 将pos位设为0 bitset&lt;N&gt;&amp; flip() 翻转所有位（与 operator~ 类似，但是是直接在原数上进行） bitset&lt;N&gt; &amp;flip(pos) 翻转第pos位 string to_string(char zero = '0', char one = '1') 转为字符串 unsigned long to_ulong() 转为 unsigned long ，若溢出则抛出 std::overflow_error unsigned long long to_ullong() 转为 unsigned long long ，若溢出则抛出 std::overflow_error (自C++11) 代码示例12345678910#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() { bitset&lt;10&gt; bset(15); cout &lt;&lt; bset &lt;&lt; '\\n'; // output: 0000001111 return 0;}","link":"/2019/08/bitset/"},{"title":"二叉堆基础与优先队列","text":"堆是一种数据结构，而priority_queue (优先队列)是一个基于二叉堆的STL容器。 堆有很多种类，但以下提及的堆均为二叉堆。 以下是一个例子。将新元素20插入二叉堆： 所以对一个二叉堆，有3种基本操作： 插入：将 val 插入堆。 取堆顶：查看堆顶元素值。（即整个堆中最大或最小值） 出堆：将堆顶元素出堆。 大根堆参考实现代码： 1234567891011121314151617181920212223242526272829303132333435struct Heap { int heap[N], n; void clear() { n = 0; } void up(int p) { while (p &gt; 1) { if (heap[p] &gt; heap[p / 2]) { swap(heap[p], heap[p / 2]); p /= 2; } else { break; } } } void down(int p) { int s = p * 2; while (s &lt;= n) { if (s &lt; n &amp;&amp; heap[s] &lt; heap[s + 1]) ++s; if (heap[s] &gt; heap[p]) { swap(heap[s], heap[p]); p = s; s = p * 2; } else { break; } } } void insert(int val) { heap[++n] = val; up(n); } void pop() { heap[1] = heap[n--]; down(1); }}; 但在 C++ STL中，我们有 priority_queue 。所以我们通常就直接使用它，而不会手敲二叉堆（但是至少应该知道优先队列的工作原理）。 请注意 priority_queue 的堆顶默认是整个堆中的最大值（即默认大根堆，反过来的叫小根堆）。 priority_queue 有以下方法： push(val): 将 val 插入堆。$O(logN)$ top(): 查看堆顶元素值。（即整个堆中最大或最小值）$O(1)$ pop(): 将堆顶元素出堆。$O(logN)$ size(): 取堆大小。$O(1)$ empty(): 判断堆是否为空。$O(1)$ 有时我们需要（重新）定义小于号以使用 priority_queue 。有很多种方法可以实现对小于号的重载，如 bool operator&lt; friend bool operator&lt; bool operator() 以下是练习题： POJ-1338, HDOJ-4006, POJ-3253, HDOJ-1873, HDOJ-1509, POJ-1442, HDOJ-1896, POJ-1456 另外，与二叉堆关系密切的一个经典问题是: 哈夫曼树 (Huffman Tree). 如 T^TOJ-3810. 部分练习题参考代码 POJ-1338 [Ugly Numbers] 参考代码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; q;vector&lt;LL&gt; v;int main() { int n; q.push(1); while (q.size() &lt; 1500) { LL val = q.top(); q.pop(); if (!v.empty() &amp;&amp; v.back() == val) continue; v.push_back(val); q.push(val * 2); q.push(val * 3); q.push(val * 5); } while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { printf(\"%lld\\n\", v[n - 1]); } return 0;} HDOJ-4006 [The kth great number] 参考代码 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;int main() { int n, k, num; char op[3]; while (~scanf(\"%d %d\", &amp;n, &amp;k)) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; while (n--) { while (q.size() &gt; k) q.pop(); scanf(\"%s\", op); if (op[0] == 'I') { scanf(\"%d\", &amp;num); q.push(num); } else { printf(\"%d\\n\", q.top()); } } } return 0;}","link":"/2019/07/binary-heap-and-priority-queue/"},{"title":"Boost学习笔记","text":"notes1234567891011121314151617181920212223242526272829whereis python3 # /usr/bin/python3.5msudo apt install python3-dev # 此命令会安装python3相关头文件到/usr/include/python3*下tar -xzvf boost_1_76_0.tar.gzrm boost_1_76_0.tar.gzcd boost_1_76_0/sudo bootstrap.sh# 这里需要配置 project_config# 不进行此配置时的报错为:# No python installation configured and autoconfiguration failed. See# http://www.boost.org/libs/python/doc/building.html for configuration# instructions or pass --without-python to suppress this message and# silently skip all Boost.Python targetsvim project_config.jam# 添加以下内容到 project-config-jam 结尾，注意配置文件中的空格不能省略# Python configuration# executable path : header path : library pathusing python : 3.5 : /usr/bin/python3.5m : /usr/include/python3.5m : /usr/lib/python3.5 ;sudo ./b2 # compilesudo ./b2 install --with-python # install# 可以在默认编译路径/usr/local/lib下找到相关的libboost*.so# boost在/usr/local/include/boost下mkdir demo_boostcd demo_boostvim test.cpp 1234567891011// test.cpp#include &lt;boost/python.hpp&gt;char const* greet() { return \"hello, world\";}BOOST_PYTHON_MODULE(test) { using namespace boost::python; def(\"greet\", greet);} 123456789# 将/usr/local/lib添加到动态链接库查找路径中，否则链接时会出错 cannot find -lboost_python35sudo vim /etc/ld.so.conf# 添加以下内容到结尾/usr/local/libsudo ldconfigg++ -I/usr/include/python3.5m -fPIC test.cpp -lboost_python35 -shared -o test.sovim test_py.py 12345# test_py.pyimport testprint(dir(test))print(test.greet()) 1python3 test_py.py 另一个例子 12345678910111213141516171819202122232425262728293031// demo.cpp#include &lt;boost/python.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;class Bonjour{ // Private attribute std::string m_msg;public: // Constructor Bonjour(std::string msg) :m_msg(msg) { } // Destructor ~Bonjour() { std::cout &lt;&lt; \"destructed \" &lt;&lt; this &lt;&lt; std::endl; } // Methods void greet() { std::cout &lt;&lt; m_msg &lt;&lt; std::endl; } // Getter/Setter functions for the attribute void set_msg(std::string msg) { this-&gt;m_msg = msg; } std::string get_msg() const { return m_msg; }};BOOST_PYTHON_MODULE(demo){ using namespace boost::python; class_&lt;Bonjour&gt;(\"Bonjour\", init&lt;std::string&gt;()) .def(\"greet\", &amp;Bonjour::greet) .add_property(\"msg\", &amp;Bonjour::get_msg, &amp;Bonjour::set_msg);} referencestar解压缩命令：[linux tar.gz zip 解压缩 压缩命令 安装与编译：linux下安装boost python详解 编译：Linux 编译boost (for python3) 动态库问题：cannot open shared object file: No such file or directory解决方法","link":"/2021/06/boost-notes/"},{"title":"C++11 新用法","text":"基于哈希的 map 和 set简述基于哈希的 map 和 set ，它们分别叫做 unordered_map, unordered_set 。数据分布越平均，性能相较 map 和 set 来说提升就更大。但由于它们基于哈希，所以并不像 map 和 set 一样能自动排序；它们都是无序的。 我做了一个测试：随机生成 $10^7$ 个 int 范围内的整数（平均分布），然后将其分别插入 map 和 unordered_map，再完整的做一次查询，查看时间和内存上的消耗。 测试结果 结构 总耗时 插入耗时 查询耗时 内存 map 18,041 MS 10,299 MS 7,742 MS 230.7 MB unordered_map 7,138 MS 5,426 MS 1,712 MS 212.0 MB 当数据分布平均时，从时间上看，两者的性能差距约为 $7138 / 18041 \\approx 40\\%$ 提示即使在平均意义下 unordered_map 有着比 map 更高的效率，但是由于两者的实现（前者哈希，后者平衡树）， unordered_map 单次插入的最差复杂度是 $O(N)$， map 单次插入的最差复杂度是 $O(log N)$ 。所以在出题人故意造数据卡 unordered_map 使其内部哈希表发生严重冲突时，unordered_map 就会变得很慢。 测试代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; data;int main() { freopen(\"map.txt\", \"r\", stdin); data.resize(5000000); map&lt;int, int&gt; mp; double st, ed; st = clock(); for (int i = 0; i &lt; 5000000; ++i) scanf(\"%d%d\", &amp;data[i].first, &amp;data[i].second); ed = clock(); printf(\"Read: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) mp[data[i].first] = data[i].second; ed = clock(); printf(\"Insert: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) data[i].second = mp[data[i].first]; ed = clock(); printf(\"Query: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); data = vector&lt;pair&lt;int, int&gt;&gt;();} 语法上的变化auto 关键字的新含义在 C++11 中，auto 关键字被赋予了新的含义。其功能是自动类型推导。 12345678auto x = 3; // y的类型自动推导为 intauto y = make_pair(1, 2); // y的类型自动推导为 pair&lt;int, int&gt;auto z; // 编译错误, z的类型需要一个初始值才能推导map&lt;int, int&gt; mp;// iter的类型推导为map&lt;int, int&gt;::iteratorfor (auto iter = mp.begin(); iter != mp.end(); ++iter) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; '\\n'; 与其相关的是一个新的关键字 decltype，取得某一个值的类型。 12int a = 1, b = 2;decltype(a + b) c; // c为int 增强的 for（基于范围的for循环）123456789map&lt;int, int&gt; mp;// C++11 之前遍历for (map&lt;int, int&gt;::iterator it = mp,begin(); it != mp,end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n';// C++11 之后for (auto val : mp) cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; 模板嵌套时一个小改善12priority_queue&lt;pair&lt;int, int&gt; &gt; heap; // C++11之前需加一个空格避免歧义priority_queue&lt;pair&lt;int, int&gt;&gt; heap; // C++11之后不用 初始化列表更简单的初始化方式。 1234567vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} };// 等价于下面代码vector&lt;pair&lt;int, int&gt; &gt; v;v.push_back(make_pair(1, 2));v.push_back(make_pair(2, 3));v.push_back(make_pair(3, 4)); lambda 表达式下面用一个例子讲述一下lambda表达式的大致用法。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} }; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } sort(v.begin(), v.end(), [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first; }); cout &lt;&lt; \"After sort:\\n\"; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } return 0;} 代码里的 sort，在C++11之前比较常见的等价写法是： 123456789bool cmp(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first;}int main() { // ... sort(v.begin(), v.end(), cmp); // ...}","link":"/2019/08/cpp-11-new/"},{"title":"C++的4种类型转换","text":"static_cast用隐式和用户定义转换的组合在类型间转换。 语法static_cast &lt;new_type&gt; (expression) 返回 new_type 类型的值。 解释唯有下列转换能用 static_cast 执行，但若转换会转型走常量性或易变性则亦不允许。 若存在从 expression 到 new_type 的隐式转换序列，或者若针对以 expression 到 new_type 类型的对象或引用所进行的直接初始化的重载决议，找到至少一个可行函数，则 static_cast &lt;new_type&gt; (expression) 返回如同以 new_type Temp(expression); 所初始化的一个虚构变量 Temp，它可能涉及隐式转换，对 new_type 的构造函数的调用，或对用户定义转换运算符的调用。对于非引用的 new_type，static_cast 纯右值表达式的结果对象是其直接初始化的对象。 (C++17 起) 若 new_type 是某类类型 D 的左值或指向它的指针纯右值，而 expression 的类型是到其非虚基类 B 的指针或引用，则 static_cast 进行向下转型（downcast）。若 B 是 D 的有歧义、不可访问或虚的基类（或虚基类的基类），则此向下转型非良构。这种 static_cast 并不进行用以确保该对象的运行时类型确实是 D 的运行时检查，而且仅当这项前提条件由其他方法所保证时才能安全使用，例如在实现静多态时。可以用 dynamic_cast 执行安全的向下转型。 12345struct B { };struct D : B { };D d;B&amp; br = d;static_cast&lt;D&amp;&gt;(br); // 左值指代原初的 d 对象 (本条自C++11起) 若 new_type 是右值引用类型，则 static_cast 将泛左值、类纯右值或数组纯右值 (C++17 前) 任何左值 (C++17 起) expression 的值转换为与该表达式指代相同对象，或指代其基类子对象（取决于 new_type）的亡值。若目标类型是表达式的不可访问或有歧义基类，则程序非良构。若表达式是位域左值，则它首先被转换成底层类型的纯右值。这种 static_cast 用于在 std::move 中实现移动语义。 若 new_type 是（可为 cv 限定的）void 类型，则 static_cast 在求值 expression 后舍弃其值。 若存在从 new_type 到 expression 类型的标准转换序列，且它不包含左值到右值、数组到指针、函数到指针、空指针、空成员指针、函数指针 (C++17 起)或布尔转换，则 static_cast 能进行该隐式转换的逆转换。 若从 expression 到 new_type 涉及左值到右值、数组到指针或函数到指针转换，则能显式用 static_cast 进行。 有作用域枚举类型(C++11)能转换成整数或浮点类型。 当目标类型为 cv bool 时，若原值为零则结果为 false，而对所有其他值结果为 true。对于其余整型类型，若该枚举的值能以目标类型表示，则结果为其值，否则结果未指明。(C++20前) 其结果与从枚举的底层类型隐式转换成目标类型的结果相同。 (C++20 起) 整数或枚举类型值可转换为任何完整枚举类型。 若底层类型不固定，则当 expression 的值落在范围（范围是大到足以保有目标枚举的所有枚举项的最小位域的所有可能值）外时，结果未指明 (C++17 前) 或 为未定义行为 (C++17 起)。 若底层类型固定，则其结果与转换原值到枚举的底层类型再到该枚举类型的结果相同。 浮点类型的值也可转换为任何完整枚举类型。 其结果与转换原值到枚举的底层类型再到该枚举类型的结果相同。 指向某类 D 的成员的指针可以向上转型（upcast）为指向其无歧义、可访问的基类 B 的成员。这种 static_cast 不进行用以确保成员实际存在于所指向对象的运行时类型的检查。 指向（可有 cv 限定）void 的指针类型的纯右值可转换到指向任何对象的指针类型。若原指针值所表示的内存中字节地址不满足目标类型的对齐要求，则结果指针值未指明。否则，若原指针值指向对象 a，且存在与 a 指针可互转换（定义于下文）的目标类型的（忽略 cv 限定）对象 *b，则结果为指向 *b 的指针。否则指针值不改变。任何指针转换到 void 指针，再转换回原（或更为 cv 限定的）类型的指针，都保持其原值。 同所有转型表达式，结果是： 左值，若 new_type 是左值引用或到函数类型的右值引用； 亡值，若 new_type 是到对象类型的右值引用； 否则为纯右值。 满足以下条件时，两个对象 a 与 b 指针可互转换（pointer-interconvertible）： 它们为同一对象，或 一个是 union 对象而另一个是该对象的非静态数据成员，或 一个是标准布局类对象，而另一个是该对象的首个非静态数据成员，或若该对象无非静态数据成员，则为该对象的任何基类子对象，或 存在对象 c 使得 a 与 c 指针可互转换，而 c 与 b 指针可互转换。 1234union U { int a; double b; } u;void* x = &amp;u; // x 的值为“指向 u 的指针”double* y = static_cast&lt;double*&gt;(x); // y 的值为“指向 u.b 的指针”char* z = static_cast&lt;char*&gt;(x); // z 的值为“指向 u 的指针” 注static_cast 亦可用于通过进行到指定类型的函数到指针转换，来消解函数重载的歧义。如 12std::for_each(files.begin(), files.end(), static_cast&lt;std::ostream&amp;(*)(std::ostream&amp;)&gt;(std::flush)); dynamic_cast沿继承层级向上、向下及侧向，安全地转换到其他类的指针和引用。 语法dynamic_cast &lt;new_type&gt; (expression) new_type：指向完整类类型的指针、到完整类类型的引用，或指向（可选的 cv 限定）void 的指针 expression*：若 *new_type 为引用，则为完整类类型的 左值 (C++11 前) / 泛左值 (C++11 起) 表达式，若 new_type 为指针，则为指向完整类类型的指针纯右值。 若转型成功，则 dynamic_cast 返回 new_type 类型的值。若转型失败且 new_type 是指针类型，则它返回该类型的空指针。若转型失败且 new_type 是引用类型，则它抛出与类型 std::bad_cast 的处理块匹配的异常。 解释唯有下列转换能用 dynamic_cast 进行，但若这种转换会转换走常量性或易变性则亦不允许。 若 expression 的类型恰是 new_type 或 new_type 的较少 cv 限定版本，则结果是 expression 具有 new_type 类型的值。（换言之，dynamic_cast 可用以添加常量性。隐式转换和 static_cast 亦能进行此转换。） 若 expression 的值是空指针值，则结果是 new_type 类型的空指针值。 若 new_type 是到 Base 的指针或引用，且 expression 的类型是到 Derived 的指针或引用，其中 Base 是 Derived 的唯一可访问基类，则结果是到 expression 所标识的对象中 Base 类子对象的指针或引用。（注意：隐式转换和 static_cast 亦能进行此转换。） 若 expression 是指向多态类型的指针，且 new_type 是到 void 的指针，则结果是指向 expression 所指向或引用的最终派生对象的指针。 多态对象：声明或继承了至少一个虚函数的类类型的对象是多态对象 若 expression 是到多态类型 Base 的指针或引用，且 new_type 是到 Derived 类型的指针或引用，则进行运行时检查： a) 检验 expression 所指向/标识的最终派生对象。若在该对象中 expression 指向/指代 Derived 的公开基类，且只有一个 Derived类型对象从 expression 所指向/标识的子对象派生，则转型结果指向/指代该 Derived 对象。（此之谓“向下转型（downcast）”。） b) 否则，若 expression 指向/指代最终派生对象的公开基类，而同时最终派生对象拥有 Derived 类型的无歧义公开基类，则转型结果指向/指代该 Derived（此之谓“侧向转型（sidecast）”。） c) 否则，运行时检查失败。若 dynamic_cast 用于指针，则返回 new_type 类型的空指针值。若它用于引用，则抛出 std::bad_cast 异常。 当在构造函数或析构函数中（直接或间接）使用 dynamic_cast，且 expression 指代正在构造/销毁的对象时，该对象被认为是最终派生对象。若 new_type 不是到构造函数/析构函数自身的类或其基类之一的指针或引用，则行为未定义。 与其他转型表达式相似： 若 new_type 是左值引用类型（expression 必为左值），则其结果为左值 若 new_type 是右值引用类型（expression 为完整类类型，可以是左值或右值 (C++17 前) / 必为泛左值（纯右值被实质化） (C++17 起)），则其结果为亡值 若 new_type 是指针类型，则其结果为纯右值 注 亦可用 static_cast 进行向下转型，它避免运行时检查的开销，但只有在程序（通过某些其他逻辑）能够保证 表达式 所指向的对象肯定是 Derived 时才是安全的。 某些形式的 dynamic_cast 依赖于运行时类型鉴别（ RTTI ），即编译的程序中关于每个多态类的信息。编译器通常有选项禁用此信息。 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;memory&gt;struct V { virtual void f(){}; // 必须为多态以使用运行时检查的 dynamic_cast};struct A : virtual V {};struct B : virtual V { B(V* v, A* a) { // 构造中转型（见后述 D 的构造函数中的调用） dynamic_cast&lt;B*&gt;(v); // 良好定义：v 有类型 V*，B 的 V 基类，产生 B* dynamic_cast&lt;B*&gt;(a); // 未定义行为：a 有类型 A*，A 非 B 的基类 }};struct D : A, B { D() : B((A*)this, this) {}};struct Base { virtual ~Base() {}};struct Derived : Base { virtual void name() {}};int main() { D d; // 最终派生对象 A&amp; a = d; // 向上转型，可以用 dynamic_cast，但不必须 D&amp; new_d = dynamic_cast&lt;D&amp;&gt;(a); // 向下转型 B&amp; new_b = dynamic_cast&lt;B&amp;&gt;(a); // 侧向转型 Base* b1 = new Base; if (Derived* d = dynamic_cast&lt;Derived*&gt;(b1)) { std::cout &lt;&lt; \"downcast from b1 to d successful\\n\"; d-&gt;name(); // 可以安全调用 } Base* b2 = new Derived; if (Derived* d = dynamic_cast&lt;Derived*&gt;(b2)) { std::cout &lt;&lt; \"downcast from b2 to d successful\\n\"; d-&gt;name(); // 可以安全调用 } delete b1; delete b2; try { std::unique_ptr&lt;A&gt; ptr(new A); D* test_d = static_cast&lt;D*&gt;(ptr.get()); D&amp; test = dynamic_cast&lt;D&amp;&gt;(*test_d); // 转型并不会出错 (见解释1) std::cout &lt;&lt; ptr.get() &lt;&lt; std::endl; std::cout &lt;&lt; &amp;test &lt;&lt; std::endl; } catch (const std::bad_cast&amp; e) { std::cout &lt;&lt; e.what() &lt;&lt; '\\n'; } try { std::unique_ptr&lt;A&gt; ptr(new A); D&amp; test = dynamic_cast&lt;D&amp;&gt;(*ptr.get()); // 向下转型失败, 会 throw std::cout &lt;&lt; ptr.get() &lt;&lt; std::endl; std::cout &lt;&lt; &amp;test &lt;&lt; std::endl; } catch (const std::bad_cast&amp; e) { std::cout &lt;&lt; e.what() &lt;&lt; '\\n'; }}// Possible output:// downcast from b2 to d successful// 0xee1be0// 0xee1be0// std::bad_cast const_cast在有不同 cv 限定的类型间转换。 语法const_cast &lt;new_type&gt; (expression) 返回 new_type 类型的值。 解释唯有下列转换能用 const_cast 进行。特别是，唯有 const_cast 可用于转型掉（移除）常量性或易变性。 两个指向同一类型的可能多级的指针可以互相转换，无关乎每个层级的 cv 限定符。 任何 T 类型的左值可转换为到同一类型 T 的左值或右值引用，cv 限定可更多或更少。同样地，类类型纯右值或任何类型的亡值可转换成具有更多或更少 cv 限定的右值引用。引用 const_cast 的结果指代原对象，若 expression 是泛左值，否则指代实质化的临时量 (C++17 起)。 同样的规则适用于可能多层的到数据成员的指针，及可能多层的到已知和未知边界数组（cv 限定元素的数组被认为是自身亦有 cv 限定） (C++17 起) 空指针值可转换成 new_type 的空指针值 同所有转型表达式，结果是： 左值，若 new_type 是左值引用或到函数类型的右值引用； 亡值，若 new_type 是到对象类型的右值引用； 否则为纯右值。 注函数指针和成员函数指针不可用于 const_cast。 const_cast 使得能够组成实际指代 const 对象 的到非 const 类型的引用或指针，或组成实际指代 volatile 对象的到非 volatile 类型的引用或指针。通过非 const 访问路径修改 const 对象和通过非 volatile 泛左值涉指 volatile 对象是未定义行为。 测试代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; struct type { int i; type(): i(3) {} void f(int v) const { // this-&gt;i = v; // 编译错误：this 是指向 const 的指针 const_cast&lt;type*&gt;(this)-&gt;i = v; // 只要该对象不是 const 就 OK }}; int main() { int i = 3; // 不声明 i 为 const const int&amp; rci = i; const_cast&lt;int&amp;&gt;(rci) = 4; // OK：修改 i std::cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; '\\n'; type t; // 假如这是 const type t，则 t.f(4) 会是未定义行为 t.f(4); std::cout &lt;&lt; \"type::i = \" &lt;&lt; t.i &lt;&lt; '\\n'; const int j = 3; // 声明 j 为 const int* pj = const_cast&lt;int*&gt;(&amp;j); // *pj = 4; // 未定义行为 void (type::* pmf)(int) const = &amp;type::f; // 指向成员函数的指针 // const_cast&lt;void(type::*)(int)&gt;(pmf); // 编译错误：const_cast 不可用于成员函数指针} reinterpret_cast通过重新解释底层位模式在类型间转换。 语法reinterpret_cast &lt;new_type&gt; (expression) 返回 new_type 类型的值。 解释与 static_cast 不同，但与 const_cast 类似，reinterpret_cast 表达式不会编译成任何 CPU 指令（除非在整数和指针间转换，或在指针表示依赖其类型的不明架构上）。它纯粹是一个编译时指令，指示编译器将 expression 视为如同具有 new_type 类型一样处理。 唯有下列转换能用 reinterpret_cast 进行，但若转换会转型走常量性或易变性则亦不允许。 整型、枚举、指针或成员指针类型的表达式可转换到其自身的类型。产生的值与 表达式 的相同。(C++11 起) 指针能转换成大小足以保有其类型所有值的任何整型类型（例如转换成 std::uintptr_t) 任何整型或枚举类型的值可转换到指针类型。指针转换到有足够大小的整数再转换回同一指针类型后，保证拥有其原值，否则结果指针无法安全地解引用（不保证相反方向的往返转换；相同指针可拥有多种整数表示）。不保证空指针常量 NULL 或整数零生成目标类型的空指针值；为此目的应该用 static_cast 或 隐式转换。 任何 std::nullptr_t 类型的值，包括 nullptr，可转换成任何整型类型，如同它是 (void*)0 一样，但没有值能转换成 std::nullptr_t，甚至 nullptr 也不行：为该目的应该用 static_cast。(C++11 起) 任何对象指针类型 T1* 可转换成指向对象指针类型 cv T2 。这严格等价于 static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(表达式))（这意味着，若 T2 的对齐要求不比 T1 的更严格，则指针值不改变，且将结果指针转换回原类型将生成其原值）。任何情况下，只有类型别名化（type aliasing）规则（见此）允许时，结果指针才可以安全地解引用。 T1 类型的左值表达式可转换成到另一个类型 T2 的引用。结果是与原左值指代同一对象，但有不同类型的左值或亡值。不创建临时量，不进行复制，不调用构造函数或转换函数。只有类型别名化（type aliasing）规则（见此）允许时，结果指针才可以安全地解引用。 任何函数指针可转换成指向不同函数类型的指针。通过指向不同函数类型的指针调用函数是未定义的，但将这种指针转换回指向原函数类型的指针将生成指向原函数的指针值。 一些实现上（特别是在任何 POSIX 兼容的系统上，即基于 dlsym 的要求），函数指针可以转换成 void* 或任何其他对象指针，反之亦然。若实现支持双向的转换，则转换回原类型将生成原值，否则结果指针不能安全地解引用或调用。 任何指针类型的空指针值可转换成任何其他指针类型，产生该类型的空指针值。注意不能用 reinterpret_cast 将空指针常量 nullptr 或任何其他 std::nullptr_t 类型的值转换为指针：为此目的应该使用隐式转换或 static_cast。 成员函数指针可转换成指向不同类型的不同成员函数的指针。转换回原类型将生成原值，否则结果指针不能安全使用。 指向某类 T1 的成员对象的指针可转换成指向另一个类 T2 的另一个成员对象的指针。若 T2 的对齐不比 T1 更严格，则转换回原类型 T1 将生成原值，否则不能安全地使用结果指针。 同所有转型表达式，结果是： 左值，若 new_type 是左值引用或到函数类型的右值引用； 亡值，若 new_type 是到对象类型的右值引用； 否则为纯右值。 参考static_cast dynamic_cast const_cast reinterpret_cast","link":"/2020/04/cpp-4-type-casts/"},{"title":"C++构造函数的优化","text":"下面这段代码 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class A { public: A() { cout &lt;&lt; \"default ctor\\n\"; } A(const A&amp; b) { cout &lt;&lt; \"copy ctor\\n\"; } ~A() { cout &lt;&lt; \"dtor\\n\"; }};A foo() { A b; return b;}int main() { A a = foo(); return 0;} 理论上，它的运行结果应为 123456default ctor // foo函数第一行的对象b的构造copy ctor // 对象b拷贝到返回值临时对象dtor // 对象b析构copy ctor // 返回值临时对象拷贝到main中对象adtor // 返回值临时对象析构dtor // main对象析构 然而，当我们实际编译并运行它时，运行结果为 12default ctordtor 发现所有的拷贝构造和临时对象的析构都被优化掉了。这就是NRV优化带来的性能上的好处。 对下面这个代码也是同理的。 123456789101112131415#include &lt;iostream&gt;using namespace std;class A { public: A() { cout &lt;&lt; \"default ctor\\n\"; } A(int x) { cout &lt;&lt; \"ctor with int\\n\"; } A(const A&amp; b) { cout &lt;&lt; \"copy ctor\\n\"; } ~A() { cout &lt;&lt; \"dtor\\n\"; }};int main() { A a = 3; return 0;} 优化前 1234ctor with intcopy ctordtordtor 优化后 12ctor with intdtor 值得一提的是，对于上面这一段代码，若使用括号（而不是等号）进行初始化，则无论是否开启优化都不会有临时对象的产生。即如下写法不会构造临时对象。 123456class A { ... }; // 同上int main() { A a(3); return 0;} 使用g++编译器我们可以加上 -fno-elide-constructors 参数，如此将关闭掉编译器对构造函数的优化，并输出未优化时的结果。 可以在 man g++ 中查到对该参数的描述。 1234-fno-elide-constructors The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.","link":"/2020/04/cpp-optimizations-of-constructors/"},{"title":"C++引用的实现","text":"当我学习C++引用时，听到的第一句话是“引用是变量的别名，不像指针一样需要占用内存空间”。然而学到深处，发现此话并不完全正确。 本文主要介绍我如何通过实验来了解到C++引用的实现，其实引用的内部就是指针。当然这也于编译器有关，所以这里需要提及一下测试所用的编译器及环境。 测试环境是MinGW的g++ 8.1.0，64位编译器，64位的机子。所以指针的大小是8个字节，即64个bit。（注：因为目的是测试，所以测试时并没有处理对new操作符所产生对象的回收） 首先我写出了如下代码，试图通过指针偏移来获取有关引用的信息： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int64_t x; string&amp; str = *new string(); int64_t y; cin &gt;&gt; str; // 对引用做一次操作，避免编译器把变量优化掉 cout &lt;&lt; &amp;x &lt;&lt; endl; cout &lt;&lt; &amp;y &lt;&lt; endl; cout &lt;&lt; str &lt;&lt; endl; return 0;} 然而，这个程序的输出如下（str的输出忽略）： 120x61fe000x61fdf8 难道引用真的不占内存？编译器真的很聪明，可能优化掉了吧；经过一系列尝试，我写出了另外一段代码： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void foo(int64_t q, string&amp; s, int64_t r) { cout &lt;&lt; \"&amp;q: \" &lt;&lt; &amp;q &lt;&lt; endl; cout &lt;&lt; \"&amp;r: \" &lt;&lt; &amp;r &lt;&lt; endl; cout &lt;&lt; \"*(string**)(&amp;q + 1): \" &lt;&lt; *(string**)(&amp;q + 1) &lt;&lt; endl;}int main(){ string&amp; str = *new string(); cout &lt;&lt; \"main(): \" &lt;&lt; &amp;str &lt;&lt; endl; foo(0, str, 0); return 0;} 这段代码的输出是： 1234main(): 0x1e1bd0&amp;q: 0x61fde0&amp;r: 0x61fdf0*(string**)(&amp;q + 1): 0x1e1bd0 可见，q的地址是0x61fde0，r的地址是0x61fdf0。两个地址间相差16个字节！这里引用占用的内存出来了。显然引用对应的指针存储在q的8个字节之后。我们可以将q的地址加1，也就是加上8个字节，这里存储的就是引用的信息。假设它就是指针，那么考虑：(&amp;q + 1)本身是一个指向string*的指针，也就是string**。所以若要获取指针的值，需要对这个值解一次引用，输出出来。（当然如果你想简单一点，可以直接把它转成int64_t然后用16进制输出亦可） 至此真相大白，程序输出的最后一行0x1e1bd0与主函数中new出来的对象的地址（见输出第一行）一致。所以得出结论：引用是用指针实现的。用户对引用的访问操作都内含一次解引用，而这对用户来说是透明的。 不过需要提及的是，回想本文的第一个测试，发现引用的指针空间被优化掉了。所以引用有时也不一定会在栈上真正以指针体现出来。","link":"/2020/03/cpp-implementation-of-references/"},{"title":"C++右值引用","text":"Rvalue references在C++0x中介绍了一种新的引用类型：右值引用，它帮助解决了不必要的拷贝问题和允许了完美转发的存在。当赋值的右手边（right-hand side）是一个右值时，左手边（left-hand side）的对象就可以偷走右手边对象的资源，而不是进行一次独立的分配，也就诞生了”移动语义“。 左值：可以出现在 operator= 左侧者。 右值：只能出现在 operator= 右侧者。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int a = 9; int b = 4; // a + b = 42; // error: lvalue required as left operand of assignment string s1(\"Hello \"); string s2(\"World\"); s1 + s2 = s2; // s1 + s2 可以当做左值！ cout &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; string() = \"World\"; // 可以对临时对象赋值！} C++在用户自定义类型中会产生一些细微的问题，这些问题有关于修改或赋值动作。这种问题就导致上面的定义不正确。 （但是仍然应把临时对象认为是右值。） 当右值出现在 operator= （拷贝赋值，copy assignment）的右侧，我们认为对资源进行偷取/搬移（move）而非拷贝（copy）是合理的。则 必须有语法让我们在调用端告诉编译器“这是个右值” 必须有语法让我们在被调用端写出一个专门处理右值的所谓移动赋值（move assignment）函数","link":"/2020/04/cpp-rvalue-references/"},{"title":"C++中的虚函数、重写与多态","text":"在C++中顺利使用虚函数需知道的细节 如函数在派生类中的定义有别于基类中的定义，而且你希望它成为虚函数，就要为基类的函数声明添加保留字virtual。在派生类的函数声明中，则可以不添加virtual。函数在基类中virtual，在派生类中自动virtual（但为了澄清，最好派生类中也将函数声明标记为virtual，尽管这非必须）。 保留字virtual在函数声明中添加，不要再函数定义中添加。 除非使用保留字virtual，否则不能获得虚函数，也不能获得虚函数的任何好处。 既然虚函数如此好用，为何不将所有成员函数都设为virtual？这似乎只有一个理由——效率。编译器和“运行时”环境要为虚函数做多得多的工作。所以，无谓地将成员函数为virtual会影响程序执行效率。 重写虚函数定义在派生类中发生改变时我们说函数定义被重写。一些C++书籍区分了重定义（redefine）和重写（override）。两者都是在派生类更改函数定义。函数是虚函数，就称为重写。如果不是，就称为重定义。对于我们程序员而言，这种区分似乎有点无聊，因为程序员在两种情况下做的事情是一样的。不过，编译器对于这两种情况确定是区别对待的。 多态多态性是指借助晚期绑定技术，为一个函数名关联多种含义的能力。因此，多态性、晚期绑定和虚函数其实是同一个主题。 虚函数和扩展类型兼容性、切割问题12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Pet{public: virtual void print(); string name;};class Dog : public Pet{public: virtual void print(); string breed; // 品种};void Pet::print(){ cout &lt;&lt; \"Pet name: \" &lt;&lt; name &lt;&lt; endl;}void Dog::print(){ cout &lt;&lt; \"Dog name: \" &lt;&lt; name &lt;&lt; \", breed: \" &lt;&lt; breed &lt;&lt; endl;}int main(){ Pet vPet; Dog vDog; vDog.name = \"Tiny\"; vDog.breed = \"Great Dane\"; vPet = vDog; // cout &lt;&lt; vPet.breed; return 0;} 上述代码vPet = vDog;的赋值是允许的，但赋给变量vPet的值会丢失其breed字段。这称为切割问题（slicing problem）。例如，cout &lt;&lt; vPet.breed会报错。 切割问题：在将派生类对象赋给基类变量时，派生类对象有、基类没有的数据成员会在赋值过程中丢失，基类没有的成员函数也会丢失。在最终的基类对象中，将无法使用这些丢失的成员。 切割测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Demo{public: Demo(const string&amp; s): str(s) { cout &lt;&lt; \"Demo constructor called (\" + str + \").\\n\"; } ~Demo() { cout &lt;&lt; \"Demo destructor called (\" + str + \").\\n\"; } Demo(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo copy constructor called (\" + str + \").\\n\"; } Demo&amp; operator=(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo operator= called (\" + str + \").\\n\"; return *this; }private: string str;};class Base{public: Demo member1 = Demo(\"member1\");};class Derived : public Base{public: Demo member2 = Demo(\"member2\");};int main(){ Derived derived; Base base; base = derived;}/* OutputDemo constructor called (member1).Demo constructor called (member2).Demo constructor called (member1).Demo operator= called (member1).Demo destructor called (member1).Demo destructor called (member2).Demo destructor called (member1).*/ 幸好，C++提供了一种方式，允许在将一个Dog视为Pet的同时不丢失品种名称： 1234567Pet *pPet;Dog *pDog;pDog = new Dog;pDog-&gt;name = \"Tiny\";pDog-&gt;breed = \"Great Dane\";pPet = pDog;pPet-&gt;print(); // prints \"Dog name: Tiny, breed: Great Dane\" 基类Pet把print()声明为virtual。所以一旦编译器看到pPet-&gt;print();就会检查Pet和Dog的virtual表，判断pPet指向的是Dog类型的对象。因此，它会使用Dog::print()，而不是Pet::print()。 配合动态变量进行OOP是一种全然不同的编程方式。只要记住以下两条简单的规则，理解起来就容易得多。 如果指针pAncestor的域类型是指针pDescendant的域类型的基类，则以下指针赋值操作允许：pAncestor = pDescendant;。此外，pDescendant指向的动态变量的任何数据成员或成员函数都不会丢失。 虽然动态变量所有附加字段（成员）都没有丢，但要用virtual成员函数访问。 视图对虚成员函数定义不齐全的类进行编译编译前，如果还有任何尚未实现的virtual成员函数，编译就会失败，并产生形如undefined reference to Class_Name virtual table的错误信息。即使没有派生类，只有一个virtual成员，并且没有调用该虚函数，只要函数没有定义，就会产生这种形式的消息。此外，可能还会产生进一步的错误消息，声称程序对默认构造函数进行了未定义的引用，即使确实已定义了这些构造函数。 始终/尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）这里主要阐述让析构函数称为虚函数的好处，但实际上也有坏处。在《Effective C++》条款07中有提到具体内容，见本文后记。 析构函数最好都是虚函数。但在解释它为什么好之前，首先解释一下析构函数和指针如何交互，以及虚析构函数的具体含义。如以下代码，其中SomeClass是含有非虚析构函数的类： 123SomeClass *p = new SomeClass;// ...delete p; 为p调用delete，会自动调用SomeClass类的析构函数，现在看看将析构函数标记为virtual之后会发生什么。为了描述析构函数与虚函数机制的交互，最简单的方式是将所有析构函数都视为同名（即使它们并非真的同名）。如假定Derived类是Base类的派生类，并假定Base类的析构函数标记为virtual，现在分析以下代码： 123Base *pBase = new Derived;// ...delete pBase; 为pBase调用delete时，会调用一个析构函数。由于Base类中的析构函数标记为virtual，且指向的对象是Derived类型，故会调用Derived的析构函数（它进而调用Base类的析构函数）。若Base类的析构函数没有标记为virtual，则只调用Base类的析构函数。 还要注意一点，将析构函数标记为virtual后，派生类的所有析构函数都自动成为virtual的（不管是否用virtual标记）。同样，这种行为就好比所有析构函数具有相同的名称（即使事实上不同名）。 现在，已准备好解释为什么所有析构函数都应该是虚函数。假定Base类有一个指针类型的成员变量pB，Base类的构造函数会创建由pB指向的一个动态变量，而Base类的析构函数会删除之；另外，假定Base类的析构函数没有标记为virtual，并假定Derived类（从Base派生）有一个指针类型的成员变量pD，Derived类的构造函数会创建由pD指向的一个动态变量，而Derived类的析构函数会删除之。则以下代码 123Base *pBase = new Derived;// ...delete pBase; 由于基类析构函数未标记为virtual，所以只会调用Base类的析构函数。这会将pB指向的动态变量的内存返还给自由存储；但pD指向的动态变量占用的内存永远不会返还给自由存储直到程序终止。 另一方面，将基类Base析构函数标记为virtual，delete pBase;时会调用Derived类的析构函数（因为指向的对象是Derived类型）。Derived类的析构函数会删除pD指向的动态变量，再自动调用基类Base的析构函数删除pB指向的动态变量。 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;class Base{public: Base() { baseData = new int; std::cout &lt;&lt; \"baseData allocated.\\n\"; } ~Base() { delete baseData; std::cout &lt;&lt; \"baseData deleted.\\n\"; }private: int *baseData;};class Derived : public Base{public: Derived() { derivedData = new int; std::cout &lt;&lt; \"derivedData allocated.\\n\"; } ~Derived() { delete derivedData; std::cout &lt;&lt; \"derivedData deleted.\\n\"; }private: int *derivedData;};int main(){ Base *base = new Derived; delete base;}/* OutputbaseData allocated.derivedData allocated.baseData deleted.*/ 将第11行的~Base()改为virtual ~Base()，程序输出为 123456/* OutputbaseData allocated.derivedData allocated.derivedData deleted.baseData deleted.*/ 后记参考： Walter Savitch《Problem Solving with C++, Tenth Edition》； 《Effective C++》。 《Effective C++》条款07：“为多态基类声明virtual析构函数”中提到： 带多态性质的基类应该声明一个virtual析构函数；如果类带有任何virtual函数，则它就应该拥有一个virtual析构函数。 类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明virtual析构函数。（如标准库input_iterator_tag等）","link":"/2020/02/cpp-virtual-functions-override-polymorphism/"},{"title":"Git笔记","text":"windows使含有中文的文件名正常显示对于某些含有中文的文件名（比如文档），在 git status 时会出现 \\347 这样的转义显示。将其修改为中文显示： 1git config --global core.quotepath false","link":"/2021/06/git-notes/"},{"title":"高效随机数据生成-random与chrono","text":"请注意random库与chrono库均是C++11。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;// 生成 [a, b] 范围内的整数// 其中 INT_MIN &lt;= a &lt;= b &lt;= INT_MAXint rand(int a, int b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;int&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_INT_MAXunsigned rand(unsigned a, unsigned b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;unsigned&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 LONG_LONG_MIN &lt;= a &lt;= b &lt;= LONG_LONG_MAXLL rand(LL a, LL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;LL&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_LONG_LONG_MAXULL rand(ULL a, ULL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;ULL&gt;(a, b)(rng);}int main() { const LL MAX = 1e10; cout &lt;&lt; rand(-MAX, MAX); return 0;}","link":"/2019/08/generate-random-data-in-high-efficiency-random-chrono/"},{"title":"FJUTOJ-3682-LRU算法的实现2","text":"传送门 此题让我们实现一个LRU的模板类。本题较简便且高效的写法是维护一个std::list和一个std::unordered_map。 std::list 与 std::unordered_map 中存放的内容std::list中存放各key，类型为K。链表中各键码存放的顺序是按照访问顺序存放的。 std::unordered_map中以key为第一维，第二维为一个pair，其first和second分别为： first: 该key对应的value。 second:该key在std::list中的迭代器方便访问。 为方便，下面用“链表”来指代std::list，用“哈希表”来指代std::unordered_map。 各操作实现insert操作：用哈希表判断该键是否已经存在。若存在，先在链表中删除该key，然后再新加一个该key到链表尾部，并更新在哈希表中的value和链表的迭代器。若不存在，则直接加至链表尾部，并在哈希表中插入该key，伴随着对应的value和链表迭代器。 get操作：直接从哈希表中获得其value即可。代码实现未检测该key是否存在，严谨来说应该加上异常处理。 contains操作：直接在哈希表中查询是否存在该key即可。 vis操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，然后再将其加至链表尾部，并更新哈希表中对应链表迭代器。 pop操作：判断是否整个容器已经为空。若为空，则本操作无效。否则，将链表头部元素从链表中删除，并在哈希表中删除对应键值信息。 remove操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，并在哈希表中删除对应键值信息。 empty操作：哈希表或链表判空即可。 size操作：取哈希表或链表大小即可。 clear操作：清空哈希表和链表即可。 时间复杂度各操作基于对链表和哈希表的修改。期望复杂度均为$O(1)$。 参考代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;list&gt;#include &lt;unordered_map&gt;template &lt;typename K, typename V&gt;class LRU {private: typedef typename std::list&lt;K&gt;::iterator listIter; typedef typename std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt;::iterator unorderedMapIter; std::list&lt;K&gt; lst; std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt; mp;public: void insert(const K &amp;key, const V &amp;value) { unorderedMapIter it = mp.find(key); if (it == mp.end()) { lst.emplace_back(key); mp.insert(std::make_pair(key, std::make_pair(value, --lst.end()))); } else { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second = std::make_pair(value, --lst.end()); } } // If Key doesn't exist, this will create one &lt;Key, zero&gt; V get(const K &amp;key) { return mp[key].first; } bool contains(const K &amp;key) { return mp.count(key) == 1; } void vis(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second.second = --lst.end(); } } void pop() { if (!lst.empty()) { mp.erase(lst.front()); lst.pop_front(); } } void remove(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); mp.erase(it); } } bool emtpy() { // 本题要求此函数名为emtpy return lst.empty(); } unsigned long long size() { return lst.size(); } void clear() { lst.clear(); mp.clear(); }};","link":"/2019/03/fjutoj-3682/"},{"title":"Hexo与Icarus博客搭建遇到问题与解决","text":"FontAwesome库很慢或404修改 blog\\themes\\icarus\\includes\\helpers\\cdn.js 文件 1234const icon_providers = { /* fontawesome: 'https://use.fontawesome.com/releases/v5.4.1/css/all.css' */ fontawesome: 'https://cdn.bootcss.com/font-awesome/5.4.1/css/all.css'}; 修改后执行 hexo cl &amp;&amp; hexo s 即可看到效果。 Reference: https://blog.csdn.net/t270153399/article/details/105345602","link":"/2020/10/hexo-icarus-blog-problems-solutions/"},{"title":"Golang中的匿名函数、闭包、defer、panic、recover","text":"匿名函数12345678910package mainimport \"fmt\"func main() { f := func() { fmt.Println(\"test\") } f()} 闭包下面代码中，输出的三个x的地址一定是一样的，它们引用同一个变量。 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() { f := closure(10) fmt.Println(f(1)) fmt.Println(f(2))}func closure(x int) func(int) int { fmt.Println(&amp;x) return func(y int) int { fmt.Println(&amp;x) return x + y }}/* possible output:0xc0000600680xc000060068110xc00006006812*/ defer 执行方式类似其它语言中的析构函数，在函数体执行结束后按照调用顺序的相反顺序逐个执行 即使函数发生严重错误也会执行 支持匿名函数的调用 常用于资源清理、文件关闭、解锁以及记录时间等操作 通过与匿名函数配合可在return之后修改函数计算结果 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址 下面这个代码中，defer时i就传值进去了。所以输出210。 123456789package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer fmt.Print(i) }} 下面这个代码中，由于闭包中的i是对main函数中局部变量i的引用。defer在main函数结束后执行，而main函数结束时i的值已经为3。所以输出3次3。 1234567891011package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer func() { fmt.Println(i) }() }} 下面这个代码中，闭包里每一次传递的string事实上都不是同一个。所以输出的是ans2 ans1 ans0。 123456789101112131415package mainimport ( \"fmt\" \"strconv\")func main() { for i := 0; i &lt; 3; i++ { var t string = \"ans\" + strconv.Itoa(i) defer func() { fmt.Print(t + \" \") }() }} defer配合panic与recover123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"func main() { f1() f2() f3()}func f1() { fmt.Println(\"func f1\")}func f2() { // defer 一定要在 panic 之前, 因为 panic 触发时 // panic 所在函数就会立刻终止并倒序调用所有已经存在的defer // 若 defer 在 panic 之后, 程序根本不会知道后面有 defer defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (first)\") } }() defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (second)\") } }() panic(\"panic in f2\")}func f3() { fmt.Println(\"func f3\")}/* output:func f1err = panic in f2recover in f2 (second)func f3*/","link":"/2020/03/golang-anonymous-functions-closure-defer-panic-recover/"},{"title":"《深度探索C++对象模型》学习笔记","text":"1 关于对象1.1 C++对象模式C++对象模型非静态数据成员放置于每一个类对象中，静态数据成员则被存放在类对象之外。静态与非静态成员函数也被放在类对象之外。虚函数则以两个步骤支持： 每一个类产生出一堆指向虚函数的指针，放在表格之中，此表称为虚表 (virtual table, vtbl)。 在每一个类对象中安插一个指针，指向相关的虚表。通常这个指针被称为 vptr 。它的设定与重置由每一个类的构造函数、析构函数、拷贝赋值运算符自动完成。每一个类所关联的 type_info 对象（用以支持runtime type identification, RTTI）也经由虚表指出，通常放在表格的第一个slot（位置）。 3 Data语义学3.0 综述 一个虚基类子对象只会在派生类中存在一份实例，不管它在继承体系中出现了多少次。 C++标准并不强制规定如“基类子对象的排列顺序“或”不同存取层级的数据成员的排列顺序“这种琐碎细节。它也不规定虚函数或虚基类的实现细节。C++标准说：那些细节由各家厂商自定。 C++对象模型把非静态数据成员直接存放在每一个类对象中，对于继承来的非静态数据成员（无论是虚继承还是非虚继承）也是如此。不过并没有强制定义其间的排列顺序。至于静态数据成员则被放置在程序的一个全局数据段（global data segment）中，不影响类对象的大小。 3.1 Data Member 的绑定 有关数据成员的绑定问题，现在的C++已经解决了。 若一个 inline 函数在 class 声明之后立刻被定义，则还是对其评估求值。即对成员函数本体的分析会直到整个class的声明都出现了开始。因此在一个inline成员函数体之内的一个数据成员绑定操作，会在整个class声明完成之后才发生。（member scope resolution rules） 1234567891011extern int x;class Point3d {public: // 对于函数本体的分析将延迟直到class声明的右大括号出现才开始 float X() const { return x; }private: float x;};// 分析在这里进行 然而这对于成员函数的参数列表并不为真。参数列表中的名称还是会在它们第一次遇到时被适当地决议（resolved）完成。 12345678910typedef int length; // global typedefclass Point3d {public: void mumble(length val); // length: int length mumble() { return _val; } // length: intprivate: typedef float length; // nested typedef length _val; // length: float} 对于这种情况，请总是把“nested type声明”放在class的起始处。 3.2 Data Member 的布局3.6 指向 Data Members 的指针取一个非静态数据成员的地址将会得到它在类中的偏移量。 下面代码中数据成员指针的类型为：float Point3d::*。有些编译器返回的偏移量总是多1，因为考虑到不指向任何成员的指针应为0。如果不加1，有可能导致第一个数据成员成员的指针和不指向任何成员的指针相等，都为0。（此时说它是偏移量就有些不合适） 123456789101112131415161718192021222324252627282930313233343536373839// G++ 8.1.0, 64-bit#include &lt;iostream&gt;using namespace std;class Point3d { public: virtual ~Point3d() {} static Point3d origin; float x, y, z;};struct Base1 { int val1;};struct Base2 { int val2;};struct Derived : Base1, Base2 { int val3;};Point3d Point3d::origin;#define show(ptrToDataMember) printf(#ptrToDataMember \" = %d\\n\", ptrToDataMember)int main() { // 注意不能用 cout &lt;&lt; &amp;Point3d::x，会匹配到 operator&lt;&lt;(bool) // 为了简便，这里定义宏（与书上不同） show(&amp;Point3d::x); // 8 show(&amp;Point3d::y); // 12 show(&amp;Point3d::z); // 16 show(&amp;Base1::val1); // 0 show(&amp;Base2::val2); // 0 show(&amp;Derived::val1); // 0 show(&amp;Derived::val2); // 0（比较奇怪） show(&amp;Derived::val3); // 8 return 0;} 个人感觉，成员指针并不能拿来输出。所以输出什么值也只能作为参考，便于理解这个概念。事实上，我觉得cout给出了正确的行为。它将一个成员指针视为bool，以表示其是否真正有效。即 123456789101112struct Base1 { int val1;};int main() { int Base1::* p = 0; cout &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; endl; // false p = &amp;Base1::val1; printf(\"%d\\n\", p); // 0 cout &lt;&lt; boolalpha &lt;&lt; p &lt;&lt; endl; // true return 0;}","link":"/2020/03/inside-the-cpp-object-model-notes/"},{"title":"multimap与multiset","text":"multimap介绍基本与 map 相同，但除去了 operator[]， 因为其特点是相同 key 的值在 multimap 中可以多个存在。需要强调的，与 map 有明显不同的常用方法： 常用方法iterator insert(value) 插入键值对，返回插入后该元素的迭代器 size_type erase(key) 删除所有关键字与 key 相等的键值对，返回删除的元素个数 void erase(iterator pos) 删除对应位置元素 size_type count(key) 统计关键字为 key 的元素个数 iterator find(key) 查找关键字与 key 相等的键值对，返回对应位置的迭代器。如果不存在则返回 end() 。如果有多个关键字与 key 相等的键值对，返回的迭代器指向哪一个不定。 pair&lt;iterator, iterator&gt; equal_range(key) 查找关键字与 key 相等的键值对，返回迭代器对，描述与 key 相等的键值对的区间 [first, last) 。 代码示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef multimap&lt;int, char&gt;::iterator iterType;int main() { multimap&lt;int, char&gt; mp; mp.insert(make_pair(1, 'A')); mp.insert(make_pair(2, 'B')); mp.insert(make_pair(2, 'C')); mp.insert(make_pair(2, 'D')); mp.insert(make_pair(4, 'E')); mp.insert(make_pair(3, 'F')); pair&lt;iterType, iterType&gt; range = mp.equal_range(2); for (iterType it = range.first; it != range.second; ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n'; } return 0;} 12345output2 B2 C2 D multiset介绍与上述 multimap 的用法基本相同，只是每个元素只有一个值 key，而没有对应的 value。","link":"/2019/08/multimap-and-multiset/"},{"title":"解决Navicat连接MySQL不成功的问题","text":"因为在虚拟机上使用MySQL不方便保存数据，尝试在Windows上使用Navicat连接Linux虚拟机上的MySQL。 在Navicat中输入用户名/密码后，提示 Can't connect to MySQL server on '&lt;MySQL Server IP&gt;' (10061 &quot;Unknown error&quot;) 解决方法： 修改 /etc/mysql/mysql.conf.d/mysqld.cnf ，将其中的 bind-address = 127.0.0.1 注释掉，保存。 运行 service mysql restart ，重启 MySQL。 接下来再尝试在Navicat中连接MySQL，又提示 1130 - Host '&lt;MySQL Server IP&gt;' is not allowed to connect to this MySQL server 因为默认情况下root用户只允许本机访问，即只能使用localhost访问。所以需要将root对应的host修改大一点，这里简单起见直接修改为所有IP访问。 解决方法： 在虚拟机上以root登录MySQL。然后执行 123mysql&gt; use mysql;mysql&gt; update user set host = '%' where user = 'root';mysql&gt; flush privileges; 现在再用Navicat连接MySQL就可以连接成功了。","link":"/2020/05/navicat-connect-mysql-fail-solution/"},{"title":"操作系统——死锁与内存管理","text":"死锁必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 处理方法主要有以下四种方法： 鸵鸟策略 死锁检测与死锁恢复 死锁预防 死锁避免 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 1. 每种类型一个资源的死锁检测 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 2. 每种类型多个资源的死锁检测 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 3. 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 死锁预防在程序运行之前预防发生死锁。 1. 破坏互斥条件例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 2. 破坏占有和等待条件一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 3. 破坏不可抢占条件就是允许对资源实行抢夺。 4. 破坏环路等待给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免在程序运行时避免发生死锁。 1. 安全状态 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 2. 单个资源的银行家算法一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 3. 多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。 内存管理虚拟内存虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。 分页系统地址映射内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。 下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。 页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳页面置换算法（OPT, Optimal replacement algorithm）所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 17, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 最近最久未使用（LRU, Least Recently Used）虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 14, 7, 0, 7, 1, 0, 1, 2, 1, 2, 6 3. 最近未使用（NRU, Not Recently Used）每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中R 位会以一定周期T被清零。可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 4. 先进先出（FIFO, First In First Out）选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 5. 第二次机会算法（Second Chance）FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改： 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 第二次机会算法可视为一个环形队列（见下面所述“时钟”，但第二次机会算法实际上并不是环形的）。用一个指针指示哪一页是下面要淘汰的。当需要一个存储块时，指针就前进，直至找到访问位是0的页。随着指针的前进，把访问位就清为0。在最坏的情况下，所有的访问位都是1，指针要通过整个队列一周，每个页都给第二次机会。这时就退化成FIFO算法了。 6. 时钟（Clock）第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 段页式程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分页与分段的比较 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 参考资料CyC2018/CS-Notes 死锁预防 第二次机会算法","link":"/2020/03/os-deadlock-and-memory-manage/"},{"title":"操作系统——设备管理与链接","text":"设备管理磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 1. 先来先服务（FCFS, First Come First Served）按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先（SSTF, Shortest Seek Time First）优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 3. 电梯算法（SCAN）电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。 链接编译系统以下是一个 hello.c 程序： 123456#include &lt;stdio.h&gt;int main() { printf(\"hello, world\\n\"); return 0;} 在 Unix 系统上，由编译器把源文件转换为目标文件。 1gcc -o hello hello.c 这个过程大致如下： 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 静态链接静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务： 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 图源：深入理解计算机系统(原书第3版) Commonly used in makefiles: LD is a linker (comes from “link editor” or from “loader”). AS ia asn assembly language compiler. CC stands for “C compiler” (in GCC abbreviation it is also treated as “compiler collection”). CPP stands for “C preprocessor”. 目标文件 可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 动态链接静态库有以下两个问题： 当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。 so = Shared ObjectDLL = Dynamic Link Library 共享库具有以下特点： 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 参考资料CyC2018/CS-Notes In makefiles what do CC and LD stand for? - Stack Overflow 深入理解计算机系统（原书第3版）","link":"/2020/03/os-device-manage-and-linking/"},{"title":"操作系统——进程管理","text":"进程与线程概念进程是资源分配的基本单位；线程是独立调度的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 区别Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（Inter-Process Communication，进程间通信，提供了各种进程间通信的方法）。 进程状态进程的3种基本状态（三态模型） 就绪态：进程已获得除CPU外的所有必要资源，只等待CPU时的状态。一个系统会将多个处于就绪状态的进程排成一个就绪队列。 执行态：进程已获CPU，正在执行。单处理机系统中，处于执行状态的进程只一个；多处理机系统中，有多个处于执行状态的进程。 阻塞态：又称等待状态或封锁状态，正在执行的进程由于某种原因而暂时无法继续执行，便放弃处理机而处于暂停状态，即进程执行受阻。(通常导致进程阻塞的典型事件有：请求I/O，申请缓冲空间等。一般，将处于阻塞状态的进程排成一个队列，有的系统还根据阻塞原因不同把这些阻塞集成排成多个队列。) 进程的5种状态（五态模型） 新建态：此时，进程已经拥有了字节的PCB，但该进程所必需的资源或其它信息（如主存资源）尚未分配，进程自身还未进入主存，即创建工作尚未完成，进程还不能够被调度运行。（创建进程的两个步骤： 为一个新进程创建PCB，并填写必要管理信息；把该进程转入就绪状态并插入就绪队列。） 就绪态 执行态 阻塞态 终止态：进程的终止首先要等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统。(当一个进程到达自然结束点或出现了无法克服的错误，或是被操作系统或其它有终止权的进程所终结，它将进入终止状态。进入终止状态的进程不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。) 进程调度算法不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 批处理系统 批处理系统，又名批处理操作系统。批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。这种采用批量处理作业技术的操作系统称为批处理操作系统。批处理操作系统不具有交互性，它是为了提高CPU的利用率而提出的一种操作系统。批处理操作系统分为单道批处理系统和多道批处理系统。 在单道批处理系统中，内存中仅有一道作业，它无法充分利用系统中的所有资源，致使系统性能较差。为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期又引入了多道程序设计技术，由此而形成了多道批处理系统。 多道批处理系统有两个特点： 多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。 成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。 1.1 先来先服务 First Come First Served（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 Shortest Job First（SJF） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 Shortest Remaining Time Next（SRTN） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 交互式系统 交互式计算机系统与操作人员以人机对话的方式一问一答，直至获得最后处理结果。采用这种方式，程序设计人员可以边设计，边调整，边修改，使错误和不足之处及时得到改正和补充。特别对于非专业的操作人员，系统能提供提示信息，逐步引导操作者完成所需的操作，得出处理结果。 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,.. （不一定，只要队列时间片大小递增即可）。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次（1+2+4+8+16+32+64=127）。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 实时系统实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section// exit section 同步与互斥 同步：多个进程按一定顺序执行； 互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量概念信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() { down(&amp;mutex); // 临界区 up(&amp;mutex);}void P2() { down(&amp;mutex); // 临界区 up(&amp;mutex);} 使用信号量实现生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() { while (true) { int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); }}void consumer() { while (true) { down(&amp;full); down(&amp;mutex); int item = remove_item(); consume_item(item); up(&amp;mutex); up(&amp;empty); }} 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程（monitor）把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 C 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait(x) 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal(x) 操作用于唤醒被 wait(x) 阻塞的进程。 使用管程实现生产者-消费者问题123456789101112131415161718192021222324252627282930313233343536373839404142// 管程monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 经典同步问题生产者和消费者问题前面已经讨论过了。 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1; // 对 count 加锁semaphore data_mutex = 1; // 对读写的数据加锁int count = 0;void reader() { while (true) { down(&amp;count_mutex); count++; if (count == 1) down(&amp;data_mutex); // 第一个读者需要对数据加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if (count == 0) up(&amp;data_mutex); up(&amp;count_mutex); }}void writer() { while (true) { down(&amp;data_mutex); write(); up(&amp;data_mutex); }} 哲学家进餐问题五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) { while (true) { think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); }} 为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态,一开始都是THINKINGsemaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) { // 哲学家 while (true) { think(); take_two(i); eat(); put_two(i); }}void take_two(int i) { down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);}void put_two(int i) { down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);}void test(int i) { // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) { state[i] = EATING; up(&amp;s[i]); }} 进程通信进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 12#include &lt;unistd.h&gt;int pipe(int fd[2]); 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 FIFO也称为命名管道，去除了管道只能在父子进程中使用的限制。 123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 信号量它是一个计数器，用于为多个进程提供对共享数据对象的访问。 共享存储允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 套接字与其它通信机制不同的是，它可用于不同机器间的进程通信。 参考资料CyC2018/CS-Notes 批处理系统 单道批处理系统 多道批处理系统 交互式系统 进程三种基本状态","link":"/2020/03/os-process-manage/"},{"title":"Python知识点1","text":"基本知识Python对象类型 对象类型 对应类型 实例 解释 数字 int, float, complex 1234, 3.14, 1.3e5, 3+4j 数字大小没有限制，内置支持复数及其运算。 字符串 str ‘abcd’, “abcd”, ‘’’ab’’’, “””ab”””, r’abc’, R’abc’ 不可变，使用单引号、双引号、三引号作为定界符，或以字母r或R引导的原始字符串。单引号、双引号、三单引号、三双引号可以互相嵌套，用来表示复杂字符串。三引号表示的字符串可以换行，支持排版较为复杂的字符串；三引号还可以在程序中表示较长的注释。 字符串 bytes b’Hello World’ 不可变，以字母b引导，使用单引号、双引号、三引号作为定界符 列表 list [1, 2, 3], [[1, 2, 3], None] 所有元素放在一对方括号[]中，元素之间使用逗号分隔，其中的元素可以是任意类型 字典 dict {1: “one”, 2: “two”} 所有元素放在一对大括号{}中，元素之间使用逗号分隔，元素形式为键:值。字典由于可变，所以本身不可哈希 元组 tuple (2, 3, 4), (-3,) 不可变，所有元素放在一对圆括号()中，元素之间使用逗号分隔，如果元组中只有一个元素的话，该元素后面需加一个逗号 集合 set, frozenset {‘a’, ‘b’, ‘c’}, frozenset({‘a’, ‘b’, ‘c’}) 所有元素放在一对大括号{}中，元素之间使用逗号分隔，元素不允许重复。set可变，而frozenset不可变。set由于可变，故本身不可哈希；frozenset可以 布尔 bool True, False 逻辑值，关系运算符、成员测试运算符、同一性测试运算符组成的表达式的值一般为True或False 空类型 NoneType None 空值 异常 BaseException Exception, ValueError… Python内置大量异常类，分别对应不同类型的异常 文件 f = open(‘data.dat’, ‘rb’) open是Python内置函数，使用指定的模式打开文件，返回文件对象 其它可迭代对象 生成器对象、range对象、zip对象、enumerate对象、map对象、filter对象等 range(1, 3), … 具有惰性求值的特点，除range对象之外，其他对象中的元素只能看一次 编程单元 函数、类、模块（类型为module） 类和函数都属于可调用对象，模块用来集中存放函数、类、常量或其他对象 例子12345678910111213a = 3 + 4jb = 5 + 6jc = a + bprint(c) # (8+10j)print(c.real, c.imag, c.conjugate()) # 8.0 10.0 (8-10j)# Python 3.6.x开始支持在数字中间位置使用单个下划线作为分隔来提高# 数字的可读性，类似于数学上使用逗号作为千位分隔符。print(1_000_000) # 1000000print(1_2_3_4) # 1234print(1_2 + 3_4j) # (12+34j)print(1_2.3_45) # 12.345 Python运算符取反12345a = 2print(~a) # -3# 2的二进制表示为 010，其中最高位为符号位# 取反得 101，将其取反+1可以得到它对应的正数 011，即 +3# 所以补码 101 为 -3，即上述 print 结果。 集合运算集合的交集、并集、对称差集等运算借助于位运算符来实现，而差集则使用减号运算符实现（并集运算符不是加号）。 12345678&gt;&gt;&gt; {1, 2, 3} | {3, 4, 5} # 并集，自动去除重复元素 a.union(b){1, 2, 3, 4, 5}&gt;&gt;&gt; {1, 2, 3} &amp; {3, 4, 5} # 交集 a.intersection(b){3}&gt;&gt;&gt; {1, 2, 3} ^ {3, 4, 5} # 对称差集 a.symmetric_difference(b){1, 2, 4, 5}&gt;&gt;&gt; {1, 2, 3} - {3, 4, 5} # 差集 a.difference(b){1, 2} 矩阵相乘运算符@12345678910111213141516171819202122232425262728class Test: def __matmul__(self, value): print('__matmul__', value) return self def __rmatmul__(self, value): print('__rmatmul__', value) return self def __imatmul__(self, value): print('__imatmul__', value) return selfa = Test()b = Test()c = a @ b # __matmul__ &lt;__main__.Test object at 0x000001E098F8A2E0&gt;d = 1 @ a # __rmatmul__ 1e = a @ 2 # __matmul__ 2c @= c # __imatmul__ &lt;__main__.Test object at 0x000001E098F2A550&gt;d @= 3 # __imatmul__ 3import numpy as npx = np.ones(3)y = np.eye(3) * 3y[0, 2] = 5y[2, 0] = 3print(x @ y) # [6. 3. 8.] 内置函数iter() 返回指定对象的可迭代对象 locals() 返回包含当前作用域内局部变量及其值的字典 next(iterator[, default]) 返回可迭代对象中的下一个元素，允许指定迭代结束之后继续迭代时的返回值 reduce(func, sequence[, initial]) 将双参数的函数 $func$ 以迭代的方式从左到右依次应用至序列 $sequence$ 中每个元素，最终返回单个值作为结果。在Python 2.x中该函数为内置函数，在Python 3.x中需要从functools中导入reduce函数再使用 repr(obj) 返回对象 $obj$ 的规范化字符串表示形式，对于大多数对象有 $eval(repr(obj)) == obj$。 str(obj) 把对象 $obj$ 直接转换为字符串 reversed(seq) 返回 $seq$ 的反向迭代器 sorted(iterable, key=None, reverse=False) 返回排序后的列表，其中 $iterable$ 表示要排序的序列或迭代对象，$key$ 用来指定排序规则或依据，$reverse$ 用来指定升序或降序。该函数不改变 $iterable$ 内任何元素的顺序 zip(seq1 [, seq2 […]]) 返回 $zip$ 对象，其中元素为 $(seq1[i], seq2[i], …)$ 形式的元组，最终结果中包含的元素个数取决于所有参数序列或可迭代对象中最短的那个 sum(iterable, start=0) 求和，其中 $sum$ 为初值。 isinstance(obj, class_or_tuple) 判断 $obj$ 是否是该类或该类的子类的对象。instance(x, (A, B, ...)) 等价于 ``isinstance(x, A) or isinstance(x, B) or …`。 filter(function or None, iterable) 返回一个 $filter$ 对象，生成满足 $function(item) == True$ 的元素，其中 $item$ 为 $iterable$ 中的元素。若第一参数为 $None$，则判定条件变为元素与 $True$ 等价。 enumerate(iterable, start=0) 返回一个 $enumerate$ 对象，生成一个个由 $count$ 和 $value$ 组成的元组。即该对象会返回 $(0, seq[0]), (1, seq[1]), (2, seq[2]), …$。 Python文件名 .py：Python源文件，由Python解释器负责解释执行。 .pyw：Python源文件，常用于图形界面程序文件。 .pyc：Python字节码文件，无法使用文本编辑器直接查看该类型文件内容，可用于隐藏Python源代码和提高运行速度。对于Python模块，第一次被导入时将被编译成字节码的形式，并在以后再次导入时优先使用“.pyc”文件，以提高模块的加载和运行速度。对于非模块文件，直接执行时并不生成“.pyc”文件，但可以使用py_compile模块的compile()函数进行编译以提高加载和运行速度。另外，Python还提供了compileall模块，其中包含compile_dir()、compile_file()和compile_path()等方法，用来支持批量Python源程序文件的编译。 .pyo：优化的Python字节码文件，同样无法使用文本编辑器直接查看其内容。可以使用“python –O -m py_compile file.py”或“python –OO -m py_compile file.py”进行优化编译。Python 3.5不再支持.pyo文件。 .pyd：一般是由其他语言编写并编译的二进制文件，常用于实现某些软件工具的Python编程接口插件或Python动态链接库。 列表 list深拷贝 copy.deepcopy12345678import copyx = [1, 2, [3, 4]]y = copy.deepcopy(x)x[2].append(5)y.append(6)print(x) # [1, 2, [3, 4, 5]]print(y) # [1, 2, [3, 4], 6] 对象可视化 pythontutor 字典 dictupdate使用字典对象的update()方法将另一个字典/可迭代对象的键、值对添加到当前字典对象。 12345update(...) D.update([E, ]**F) -&gt; None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k] 字典实现函数跳转表123456789funcDict = {'1':lambda:print('You input 1'), '2':lambda:print('You input 2'), '3':lambda:print('You input 3')}x = input('Input an integer to call different functions: ')func = funcDict.get(x)if func: func()else: print('Wrong integer.') 集合 setunion(another_set) 求并集（对应重载运算符 |） intersection(another_set) 求交集（对应重载运算符 &amp;） difference(another_set) 求差集（对应重载运算符 -） symmetric_difference(another_set) 求对称差集 （对应重载运算符 ^） x.issubset(y) $x$ 为 $y$ 的子集时为真 x.isdisjoint(y) $x$ 与 $y$ 没有交集时为真 字符串 str从Python 3.6.x开始支持一种新的字符串格式化方式，官方叫做Formatted String Literals，在字符串前加字母f，含义与字符串对象format()方法类似。 1234width = 10precision = 4value = 11/3print(f'result:{value:{width}.{precision}}') # result: 3.667 find(sub[, start[, end]])和rfind(sub[, start[, end]])方法分别用来查找一个字符串在另一个字符串指定范围（默认是整个字符串）中首次和最后一次出现的位置，如果不存在则返回$-1$。 index(sub[, start[, end]])和rindex(sub[, start[, end]])方法用来返回一个字符串在另一个字符串指定范围中首次和最后一次出现的位置，如果不存在则抛出异常。 关键字in：成员判断。如'ab' in 'abcde' -&gt; True。 count(sub[, start[, end]])方法用来返回一个字符串在当前字符串中出现的次数（不重叠 overlap）。 split(sep=None, maxsplit=-1)和rsplit(sep=None, maxsplit=-1)方法分别用来以指定字符为分隔符（默认为空白符），把当前字符串从左往右或从右往左分隔成多个字符串，并把分隔之后得到的空串丢弃，并返回包含分隔结果的列表。 partition(sep)和rpartition(sep)用来以指定字符串为分隔符将原字符串分隔为3部分，即分隔符前的字符串、分隔符字符串、分隔符后的字符串三者组成的元组；如果指定的分隔符不在原字符串中，则partition返回原字符串和两个空字符串的元组，rpartition返回两个空字符串和原字符串的元组。 join(iterable) 将任意数量的字符串连接，并以此字符串作为分隔符。如'.'.join(['ab', 'pq', 'rs']) -&gt; 'ab.pq.rs'。 lower()和upper() 返回小写字符串与大写字符串。 capitalize() 字符串首字母大写，返回新字符串。 title() 每个单词首字母大写，返回新字符串。 swapcase() 大小写互换，返回新字符串。 replace(old, new, count=-1) 将字符串中所有 $old$ 替换为 $new$。返回新字符串。若 $count$ 给定，则只替换前 $count$ 次出现。 maketrans() 与 translate()： 123table = str.maketrans('aeiou123', 'AEIOU!@#')s = 'Hello World'print(s.translate(table)) # HEllO WOrld strip()、rstrip()、lstrip() 123456s = \"\\n\\n abc \\n\\n\"print(s.strip()) # abcprint('aasdf'.strip('a')) # sdfprint('aasdffa'.strip('af')) # sdprint('aasdffa'.lstrip('af')) # sdffaprint('aasdffa'.rstrip('af')) # aasd center(width, fillchar=' ')、ljust(width, fillchar=' ')、rjust(width, fillchar=' ') 用$fillchar$填充，使字符串长度变为$width$，并居中/居左/居右。 zfill(width)返回指定宽度的字符串，在左侧以字符0进行填充。 isalnum()、isalpha()、isdigit()、isdecimal()、isnumeric()、isspace()、isupper()、islower() 功能如方法名所示。返回布尔值。","link":"/2020/06/python-topic1/"},{"title":"Python知识点3","text":"文件操作打开文件open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) file：打开的文件名称。 mode：打开文件后的处理方式。模式见下表。 buffering：读写文件的缓存模式。0表示不缓存，1表示缓存，如大于1则表示缓冲区大小。默认值是缓存模式。 encoding：对文本进行编码和解码的方式，只适用于文本模式，可以使用Python支持的任何格式，如GBK、utf8、CP936等。 模式 说明 r 读模式（默认模式，可省略），如果文件不存在则抛出异常 w 写模式，如果文件已存在，先清空原有内容 x 写模式，创建新文件，如果文件已存在则抛出异常 a 追加模式，不覆盖文件中原有内容 b 二进制模式（可与其他模式组合使用） t 文本模式（默认模式，可省略） + 读、写模式（可与其他模式组合使用） 上下文管理with语句12345with open(filename, mode, encoding) as fp: # 这里写通过文件对象fp读写文件内容的语句with open('test.txt', 'r') as src, open('test_new.txt', 'w') as dst: dst.write(src.read()) 文件对象常用属性 属性 说明 buffer 返回当前文件的缓冲区对象 closed 判断文件是否关闭，若文件已关闭则返回True fileno 文件号，一般不需要太关心这个数字 mode 返回文件的打开模式 name 返回文件的名称 文件对象常用方法 方法 功能说明 close() 把缓冲区的内容写入文件，同时关闭文件，并释放文件对象 detach() 分离并返回底层的缓冲，底层缓冲被分离后，文件对象不再可用，不允许做任何操作 flush() 把缓冲区的内容写入文件，但不关闭文件 read([size]) 从文本文件中读取size个字符（Python 3.x）的内容作为结果返回，或从二进制文件中读取指定数量的字节并返回，如果省略size则表示读取所有内容 readable() 测试当前文件是否可读 readline() 从文本文件中读取一行内容作为结果返回 readlines() 把文本文件中的每行文本作为一个字符串存入列表中，返回该列表，对于大文件会占用较多内存，不建议使用 seek(offset[, whence]) 把文件指针移动到新的字节位置，offset表示相对于whence的位置。whence为0表示从文件头开始计算，1表示从当前位置开始计算，2表示从文件尾开始计算，默认为0 seekable() 测试当前文件是否支持随机访问，如果文件不支持随机访问，则调用方法seek()、tell()和truncate()时会抛出异常 tell() 返回文件指针的当前位置 truncate([size]) 删除从当前指针位置到文件末尾的内容。如果指定了size，则不论指针在什么位置都只留下前size个字节，其余的一律删除 write(s) 把s的内容写入文件 writable() 测试当前文件是否可写 writelines(s) 把字符串列表写入文本文件，不添加换行符 序列化所谓序列化，简单地说就是把内存中的数据在不丢失其类型信息的情况下转成对象的二进制形式的过程，对象序列化后的形式经过正确的反序列化过程应该能够准确无误地恢复为原来的对象。 Python中常用的序列化模块有struct、pickle、marshal和shelve。 pickle模块123456789101112131415161718192021222324import picklei = 13000000a = 99.056s = '中国人民123abc'lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]tu = (-5, 10, 8)coll = {4, 5, 6}dic = {'a':'apple', 'b':'banana', 'g':'grape', 'o':'orange'}data = [i, a, s, lst, tu, coll, dic]with open('sample_pickle.dat', 'wb') as f: try: pickle.dump(len(data), f) #表示后面将要写入的数据个数 for item in data: pickle.dump(item, f) except: print('写文件异常!') #如果写文件异常则跳到此处执行with open('sample_pickle.dat', 'rb') as f: n = pickle.load(f) #读出文件的数据个数 for i in range(n): x = pickle.load(f) print(x) struct模块123456789101112131415161718192021222324252627282930import structn = 1300000000x = 96.45b = Trues = 'a1@中国'sn = struct.pack('if?', n, x, b) # 序列化length = len(sn) # 序列化后的长度，第14行会用到with open('sample_struct.dat', 'wb') as fp: fp.write(sn) # 写入字节串 fp.write(s.encode()) # 字符串直接编码为字节串写入with open('sample_struct.dat', 'rb') as fp: sn = fp.read(length) # 读length个字节 tu = struct.unpack('if?', sn) print(tu) n, x, bl = tu print('n=', n) print('x=', x) print('bl=', bl) s = fp.read(9).decode() print('s=', s)'''(1300000000, 96.44999694824219, True)n= 1300000000x= 96.44999694824219bl= Trues= a1@中国''' 异常与断言异常处理完整结构12345678910try: statementexcept ExceptionClass1 as name1: statementexcept ExceptionClass1 as name2: statementelse: statementfinally: statement 在 except 或 finally 子句中可以使用 raise 将异常再次抛出。 1234try: raise Exception()except: raise 断言语句1assert expression[, reason] 当判断表达式expression为真时，什么都不做；如果表达式为假，则抛出异常。 assert语句一般用于开发程序时对特定必须满足的条件进行验证，仅当__debug__为True时有效。当Python脚本以-O选项编译为字节码文件时，assert语句将被移除以提高运行速度。 operator库123456789101112from operator import itemgetterhelp(itemgetter)Help on class itemgetter in module operator:class itemgetter(builtins.object) | itemgetter(item, ...) --&gt; itemgetter object | | Return a callable object that fetches the given item(s) from its operand. | After f = itemgetter(2), the call f(r) returns r[2]. | After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) itertools库12345678910from itertools import combinationsfrom itertools import combinations_with_replacementfrom itertools import permutationslist(combinations([1, 2, 3], 3))# [(1, 2, 3)]list(combinations_with_replacement([1, 2, 3], 3))# [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 2), (1, 2, 3), (1, 3, 3), (2, 2, 2), (2, 2, 3), (2, 3, 3), (3, 3, 3)]list(permutations([1, 2, 3]))# [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] 1234567891011121314151617from itertools import groupbydef group(v): if v &gt; 10: return 'greater than 10' elif v &lt; 5: return 'less than 5' else: return 'between 5 and 10'x = range(20)y = groupby(x, group) #根据函数返回值对序列元素进行分组for k, v in y: print(k, ':', list(v))# less than 5 : [0, 1, 2, 3, 4]# between 5 and 10 : [5, 6, 7, 8, 9, 10]# greater than 10 : [11, 12, 13, 14, 15, 16, 17, 18, 19] 12345from itertools import cycleg = cycle([1, 2, 3])a = [next(g) for _ in range(10)]print(a) # [1, 2, 3, 1, 2, 3, 1, 2, 3, 1] 123456789101112131415from itertools import counthelp(count)class count(builtins.object) | count(start=0, step=1) | | Return a count object whose .__next__() method returns consecutive values. | | Equivalent to: | def count(firstval=0, step=1): | x = firstval | while 1: | yield x | x += step random库1234567891011121314151617181920212223242526from random import samplefrom random import shufflefrom random import randintfrom random import randrangeprint(sample([1, 3, 5, 7, 9], 3)) # [5, 3, 9]print(sample(range(1, 10000), 3)) # [8643, 752, 6308]a = [1, 3, 5, 7, 9]shuffle(a)print(a) # [3, 7, 9, 5, 1]help(randint)'''randint(a, b) method of random.Random instance Return random integer in range [a, b], including both end points.'''help(randrange)'''randrange(start, stop=None, step=1, _int=&lt;class 'int'&gt;) method of random.Random instance Choose a random item from range(start, stop[, step]). This fixes the problem with randint() which includes the endpoint; in Python this is usually not what you want.''' functools库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from functools import lru_cachefrom functools import cmp_to_keyfrom functools import partialhelp(lru_cache)'''Help on function lru_cache in module functools:lru_cache(maxsize=128, typed=False) Least-recently-used cache decorator. If *maxsize* is set to None, the LRU features are disabled and the cache can grow without bound. If *typed* is True, arguments of different types will be cached separately. For example, f(3.0) and f(3) will be treated as distinct calls with distinct results. Arguments to the cached function must be hashable. View the cache statistics named tuple (hits, misses, maxsize, currsize) with f.cache_info(). Clear the cache and statistics with f.cache_clear(). Access the underlying function with f.__wrapped__. See: http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)'''help(cmp_to_key)'''Help on built-in function cmp_to_key in module _functools:cmp_to_key(...) Convert a cmp= function into a key= function.'''def cmp(x, y): return y - xa = [3, 7, 0, -1, 4]print(a) # [3, 7, 0, -1, 4]a.sort(key=cmp_to_key(cmp))print(a) # [7, 4, 3, 0, -1]help(partial)'''Help on class partial in module functools:class partial(builtins.object) | partial(func, *args, **keywords) - new function with partial application | of the given arguments and keywords. | ... 详见“偏函数”一节''' dis库12345678910def aplusb(a, b): return a + bimport disdis.dis(aplusb)# 2 0 LOAD_FAST 0 (a)# 2 LOAD_FAST 1 (b)# 4 BINARY_ADD# 6 RETURN_VALUE","link":"/2020/06/python-topic3/"},{"title":"Python知识点2","text":"函数 function默认值参数默认值参数只在函数定义时被解释一次，可以使用 函数名.__defaults__ 查看所有默认参数的当前值。 1234def f(x=3): passprint(f.__defaults__) # (3,) 可变长度参数、序列解包可变长度参数：可变长度参数主要有两种形式：在参数名前加1个*或2个** *parameter用来接收多个位置实参并将其放在一个元组中 **parameter接收多个关键参数并存放到字典中 传递参数时，可以通过在实参序列前加一个星号将其解包，然后传递给多个单变量形参。 12345def demo(a, b, c): print(a + b + c)seq = [1, 2, 3]demo(*seq) 如果函数实参是字典，可以在前面加两个星号进行解包，等价于关键参数。 12345def demo(a, b, c): print(a + b + c)dic = {'a': 1, 'b': 2, 'c': 3}demo(**dic) 调用函数时对实参序列使用一个星号*进行解包后的实参将会被当做普通位置参数对待，并且会在关键参数和使用两个星号**进行序列解包的参数之前进行处理。 序列解包（的位置）不能在关键参数解包之后。 12345678910111213141516171819202122demo(a=1, *(2, 3))Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: demo() got multiple values for argument 'a'demo(b=1, *(2, 3))Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: demo() got multiple values for argument 'b'demo(c=1, *(2, 3)) # okdemo(**{'a': 1, 'b': 2}, *(3,)) File \"&lt;stdin&gt;\", line 1SyntaxError: iterable argument unpacking follows keyword argument unpackingdemo(*(3,), **{'a': 1, 'b': 2})Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: demo() got multiple values for argument 'a'demo(*(3,), **{'c':1, 'b':2}) # ok 变量作用域局部变量在某个作用域内任意位置只要有为变量赋值的操作，该变量在这个作用域内就是局部变量，除非使用 global 进行了声明。 123456789101112x = 3def f(): print(x) x = 5 print(x)f()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 2, in fUnboundLocalError: local variable 'x' referenced before assignment 多模块间共享变量如果需要在同一个程序的不同模块之间共享全局变量的话，可以编写一个专门的模块来实现这一目的。例如，假设在模块A.py中有如下变量定义： 1global_variable = 0 则可以在其他模块中包含以下用来设置/获取全局变量的语句： 123import AA.global_variable = 1print(A.global_variable) nonlocal变量除了局部变量和全局变量，Python还支持使用 nonlocal 关键字定义一种介于二者之间的变量。关键字 nonlocal 声明的变量会引用距离最近的非全局作用域的变量，要求声明的变量已经存在，关键字 nonlocal 不会创建新变量。 123456789101112131415161718192021222324252627def scope_test(): def do_local(): var = \"local variable\" def do_nonlocal(): nonlocal var # 要求var必须是已存在的变量 var = \"nonlocal variable\" def do_global(): global var # 如果全局作用域内没有var，就自动新建一个 var = \"global variable\" var = \"original\" do_local() print(\"after do_local:\", var) do_nonlocal() print(\"after do_nonlocal:\", var) do_global() print(\"after_do_global:\", var)scope_test()print(\"global:\", var)# after do_local: original# after do_nonlocal: nonlocal variable# after_do_global: nonlocal variable# global: global variable 变量访问时的搜索顺序变量访问时的LEGB顺序：Local ==&gt; Enclosing ==&gt; Global ==&gt; Builtin 12345678910111213141516171819202122232425262728x = 3def outer(): y = 5 # 这个自定义函数和内置函数名字相同，会在当前作用域和更内层作用域中影响内置函数map()的正常使用 def map(): return 'fake map()' def inner(): x = 7 y = 9 # 最内层的作用域内，局部变量（Local）x,y优先被访问 # 在局部域、闭包、全局作用域内都不存在函数max，最后在内置作用域（Builtin）内搜索到函数max # 当前作用域中不存在map，但在外层的闭包作用域内搜索到了，并没有调用内置函数map print('inner:', x, y, max(x,y), map()) inner() # 在当前作用域（闭包，Enclosing）内，y可以直接访问 # 当在当前作用域内不存在x，继续到全局作用域（Global）去搜索 # 当前作用域内不存在函数max，外层全局作用域也不存在，最后在内置作用域（Builtin）内搜索到函数max # 当前作用域中有个map，直接调用了，没有调用内置函数map print('outer:', x, y, max(x,y), map()) outer()# 当前作用域中有x，可以直接访问，但不存在y# 由于当前处于全局作用域，按Python变量搜索顺序，会继续在内置作用域搜索# 不会去搜索Enclosing和Local作用域，但在内置作用域内也不存在y，代码引发异常print('outside:', x, y, max(x,y)) 生成器函数 generator包含yield语句的函数可以用来创建生成器对象，这样的函数也称生成器函数。 每次执行到yield语句会返回一个值然后暂停或挂起后面代码的执行，下次通过生成器对象的__next__()方法、内置函数next()、for循环遍历生成器对象元素或其他方式显式“索要”数据时恢复执行。 生成器对象具有惰性求值的特点，适合大数据处理。 1234567891011121314def f(): for i in range(10): yield itry: a = f() print(a) while True: print(next(a), end = ' ')except StopIteration: pass# &lt;generator object f at 0x0000017AFC12BA50&gt;# 0 1 2 3 4 5 6 7 8 9 12345678910111213def f(): yield from 'abcdefghijklmnopqrstuvwxyz'try: a = f() print(a) while True: print(next(a), end = ' ')except StopIteration: pass# &lt;generator object f at 0x000002B26498BA50&gt;# a b c d e f g h i j k l m n o p q r s t u v w x y z 1234567def f(): yield 1 yield 2 yield 3a, b, c = f()print(a, b, c) 装饰器 decorator修饰器（decorator）是函数嵌套定义的另一个重要应用。修饰器本质上也是一个函数，只不过这个函数接收其他函数作为参数并对其进行一定的改造之后返回新函数。 Python面向对象程序设计中的静态方法、类方法、属性等也都是通过修饰器实现的，Python中还有很多这样的用法。 下面的代码演示了修饰器的定义与使用方法，定义其他函数调用之前或之后需要执行的通用代码。 1234567891011121314151617181920212223def before(func): def wrapper(*args, **kwargs): print('Before function') return func(*args, **kwargs) return wrapperdef after(func): def wrapper(*args, **kwargs): result = func(*args, **kwargs) print('After function') return result return wrapper@before@afterdef test(): print(3)test()# Before function# 3# After function 偏函数/函数柯里化偏函数（partial function）和函数柯里化（function currying）是函数式编程中常用的技术。有时候我们在复用已有函数时可能需要固定其中的部分参数，这除了可以通过默认值参数来实现之外，还可以使用偏函数。例如，有个函数用来实现3个数字相加： 12def add3(a, b, c): return a + b + c 如果现在需要一个类似的函数，与上面的函数add3()的区别仅在于参数b固定为一个数字（例如3），这时就可以使用偏函数的技术来复用上面的函数。 1234def add2(a, c): return add3(a, 3, c)print(add2(1, 1)) 或者使用标准库functools提供的partial()方法创建指定函数的偏函数。 1234from functools import partialadd2 = partial(add3, b=3)print(add2(a=1, c=1)) 类 class动态添加类数据成员与成员方法Python类型的动态性使得我们可以动态为自定义类及其对象增加新的属性和行为，俗称混入（mixin）机制，这在大型项目开发中会非常方便和实用。 12345678910111213141516171819202122class Car: price = 100000 # 定义类属性 def __init__(self, c): self.color = c # 定义实例属性car1 = Car(\"Red\") # 实例化对象car2 = Car(\"Blue\")print(car1.color, Car.price) # 查看实例属性和类属性的值Car.price = 110000 # 修改类属性Car.name = 'QQ' # 动态增加类属性car1.color = \"Yellow\" # 修改实例属性print(car2.color, Car.price, Car.name)print(car1.color, Car.price, Car.name)import typesdef setSpeed(self, s): self.speed = scar1.setSpeed = types.MethodType(setSpeed, car1) # 动态增加成员方法car1.setSpeed(50) # 调用成员方法print(car1.speed) 函数与方法的区别在Python中，函数和方法是有区别的。方法一般指与特定实例绑定的函数，通过对象调用方法时，对象本身将被作为第一个参数隐式传递过去，普通函数并不具备这个特点。 12345678910111213class Demo: passdef test(self, v): self.value = vt = Demo()t.test = testprint(t.test) # &lt;function test at 0x00000000034B7EA0&gt;t.test(t, 3) # 手动传递 selft.test = types.methodType(test)print(t.test) # &lt;bound method test of &lt;__main__.Demo object at 0x000000000074F9E8&gt;&gt;t.test(5) # 自动传递 self 类的私有成员在Python中，以下划线开头的变量名和方法名有特殊的含义，尤其是在类的定义中。 _xxx：受保护成员，不能用from module import *导入； __xxx__：系统定义的特殊成员； __xxx：私有成员，只有类对象自己能访问，子类对象不能直接访问到这个成员，但在对象外部可以通过对象名._类名__xxx这样的特殊方式来访问。 1234567891011121314class A: def __init__(self, value1 = 0, value2 = 0): self._value1 = value1 self.__value2 = value2 def setValue(self, value1, value2): self._value1 = value1 self.__value2 = value2 def show(self): print(self._value1) print(self.__value2)a = A()a._value1a._A__value2 # 类外访问私有成员 类的方法（实例方法、类方法、静态方法）如果通过类名来调用属于对象的公有方法，需要显式为该方法的self参数传递一个对象名，用来明确指定访问哪个对象的数据成员。 静态方法和类方法都可以通过类名和对象名调用，但不能直接访问属于对象的成员，只能访问属于类的成员。 静态方法可以没有参数。 一般将cls作为类方法的第一个参数名称，但也可以使用其他的名字作为参数，并且在调用类方法时不需要为该参数传递值。 1234567891011121314151617181920212223242526class Root: __total = 0 def __init__(self, v): # 构造方法 self.__value = v Root.__total += 1 def show(self): # 普通实例方法 print('self.__value:', self.__value) print('Root.__total:', Root.__total) @classmethod # 修饰器，声明类方法 def classShowTotal(cls): # 类方法 print(cls.__total) @staticmethod # 修饰器，声明静态方法 def staticShowTotal(): # 静态方法 print(Root.__total)r = Root(3)print(r.classShowTotal()) # 输出1, 通过对象来调用类方法print(r.staticShowTotal()) # 输出1, 通过对象来调用静态方法r.show() # self.__value: 3 # Root.__total: 1rr = Root(5)print(Root.classShowTotal()) # 输出2, 通过类名调用类方法print(Root.staticShowTotal()) # 输出2, 通过类名调用静态方法 属性 property只读属性1234567class Test: def __init__(self, value): self.__value = value @property def value(self): # 只读，无法修改和删除 return self.__value 可读、可写、不可删属性1234567891011121314class Test: def __init__(self, value): self.__value = value def __get(self): return self.__value def __set(self, v): self.__value = v value = property(__get, __set) def show(self): print(self.__value) 可读、可写、可删属性1234567891011121314151617class Test: def __init__(self, value): self.__value = value def __get(self): return self.__value def __set(self, v): self.__value = v def __del(self): del self.__value value = property(__get, __set, __del) def show(self): print(self.__value) 常用特殊方法类的构造函数是__init__()，一般用来为数据成员设置初值或进行其他必要的初始化工作，在创建对象时被自动调用和执行。如果用户没有设计构造函数，Python将提供一个默认的构造函数用来进行必要的初始化工作。 类的析构函数是__del__()，一般用来释放对象占用的资源，在Python删除对象和收回对象空间时被自动调用和执行。如果用户没有编写析构函数，Python将提供一个默认的析构函数进行必要的清理工作。 方法 功能说明 __new__() 类的静态方法，用于确定是否要创建对象 __init__() 构造方法，创建对象时自动调用 __del__() 析构方法，释放对象时自动调用 __add__() + __sub__() - __mul__() * __truediv__() / __floordiv__() // __mod__() % __pow__() ** __eq__()、__ne__()、__lt__()、__le__()、__gt__()、__ge__() ==、 !=、&lt;、 &lt;=、&gt;、 &gt;= __lshift__()、__rshift__() &lt;&lt;、&gt;&gt; __and__()、__or__()、__invert__()、__xor__() &amp;、|、~、^ __iadd__()、__isub__() +=、-=，很多其他运算符也有与之对应的复合赋值运算符 __pos__() 一元运算符+，正号 __neg__() 一元运算符-，负号 __contains__() 与成员测试运算符in对应 __radd__()、__rsub__() 反射加法、反射减法，一般与普通加法和减法具有相同的功能，但操作数的位置或顺序相反，很多其他运算符也有与之对应的反射运算符 __abs__() 与内置函数abs()对应 __bool__() 与内置函数bool()对应，要求该方法必须返回True或False __bytes__() 与内置函数bytes()对应 __complex__() 与内置函数complex()对应，要求该方法必须返回复数 __dir__() 与内置函数dir()对应 __divmod__() 与内置函数divmod()对应 __float__() 与内置函数float()对应，要求该该方法必须返回实数 __hash__() 与内置函数hash()对应 __int__() 与内置函数int()对应，要求该方法必须返回整数 __len__() 与内置函数len()对应 __next__() 与内置函数next()对应 __reduce__() 提供对reduce()函数的支持 __reversed__() 与内置函数reversed()对应 __round__() 对内置函数round()对应 __str__() 与内置函数str()对应，要求该方法必须返回str类型的数据 __repr__() 打印、转换，要求该方法必须返回str类型的数据 __getitem__() 按照索引获取值 __setitem__() 按照索引赋值 __delattr__() 删除对象的指定属性 __getattr__() 获取对象指定属性的值，对应成员访问运算符“.” __getattribute__() 获取对象指定属性的值，如果同时定义了该方法与__getattr__()，那么__getattr__()将不会被调用，除非在__getattribute__()中显式调用__getattr__()或者抛出AttributeError异常 __setattr__() 设置对象指定属性的值 __base__ 该类的基类 __class__ 返回对象所属的类 __dict__ 对象所包含的属性与值的字典 __subclasses__() 返回该类的所有子类 __call__() 包含该特殊方法的类的实例可以像函数一样调用 __get__()、__set__()、__delete__() 定义了这三个特殊方法中任何一个的类称作描述符（descriptor），描述符对象一般作为其他类的属性来使用，这三个方法分别在获取属性、修改属性值或删除属性时被调用 __enter()__、__exit__() 支持关键字with 例子__setattr__()12345678910111213141516&gt;&gt;&gt; class Constants: def __setattr__(self, name, value): assert name not in self.__dict__, 'You can not modify '+name assert name.isupper(), 'Constant should be uppercase.' assert value not in self.__dict__.values(), 'Value already exists.' self.__dict__[name] = value &gt;&gt;&gt; t = Constants()&gt;&gt;&gt; t.R = 3 # 成员不存在，允许添加&gt;&gt;&gt; t.R = 4 # 成员已存在，不允许修改AssertionError: You can not modify R&gt;&gt;&gt; t.G = 4&gt;&gt;&gt; t.g = 4 # 成员必须大写AssertionError: Constant should be uppercase.&gt;&gt;&gt; t.B = 4 # 成员的值不允许相同AssertionError: Value already exists. __enter__()、__exit__()123456789101112class myOpen: def __init__(self, fileName, mode='r'): self.fp = open(fileName, mode) def __enter__(self): return self.fp def __exit__(self, exceptionType, exceptionVal, trace): self.fp.close()with myOpen('test.txt') as fp: print(fp.read()) 继承在继承关系中，已有的、设计好的类称为父类或基类，新设计的类称为子类或派生类。派生类可以继承父类的公有成员，但是不能继承其私有成员。如果需要在派生类中调用基类的方法，可以使用内置函数super()、super(当前类名, self)或者通过“基类名.方法名()”的方式来实现这一目的。 Python支持多继承，如果父类中有相同的方法名，而在子类中使用时没有指定父类名，则Python解释器将从左向右按顺序进行搜索。 继承（覆盖）机制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class A: def __init__(self): # 构造方法可以被派生类继承 print('__init__() method in A') self.__private() self.public() def __private(self): # 私有方法在派生类中不能直接访问 print('__private() method in A') def public(self): # 公开方法在派生类中可以直接访问 print('public() method in A')class B(A): # 类B没有构造方法，会继承基类的构造方法 def __private(self): print('__private() method in B') def public(self): # 覆盖了继承自A类的public方法 print('public() method in B')class C(B): def __init__(self): super().__init__() # 不用显式传递self print('__init__() method in C') self.__private() # 这里调用的是C类的__private方法 self.public() def __private(self): print('__private() method in C') def public(self): print('public() method in C') b = B()print(dir(b))c = C()# __init__() method in A# __private() method in A# public() method in B# ['_A__private', '_B__private', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'public']# __init__() method in A# __private() method in A# public() method in C# __init__() method in C# __private() method in C# public() method in C 多继承时的mro在Python 3.x的多继承树中，如果在中间层某类有向上一层解析的迹象，则会先把本层右侧的其他类方法解析完，然后从本层最后一个解析的类方法中直接进入上一层并继续解析，也就是在从子类到超类的反向树中按广度优先解析。 如果在解析过程中，不再有向基类方向上一层解析的迹象，则同一层中右侧其他类方法不再解析。（MRO知识：学习博客-多继承MRO顺序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BaseClass(object): def show(self): print('BaseClass')class SubClassA(BaseClass): def show(self): print('Enter SubClassA') super().show() print('Exit SubClassA')class SubClassB(BaseClass): def show(self): print('Enter SubClassB') super().show() print('Exit SubClassB')class SubClassC(BaseClass): def show(self): print('Enter SubClassC') super().show() print('Exit SubClassC')class SubClassD(SubClassA, SubClassB, SubClassC): def show(self): print('Enter SubClassD') super().show() print('Exit SubClassD')d = SubClassD()d.show()print(SubClassD.mro())'''Enter SubClassDEnter SubClassAEnter SubClassBEnter SubClassCBaseClassExit SubClassCExit SubClassBExit SubClassAExit SubClassD[&lt;class '__main__.SubClassD'&gt;, &lt;class '__main__.SubClassA'&gt;, &lt;class '__main__.SubClassB'&gt;, &lt;class '__main__.SubClassC'&gt;, &lt;class '__main__.BaseClass'&gt;, &lt;class 'object'&gt;]''' 123456789101112131415161718192021222324252627282930313233343536373839class BaseClass(object): def show(self): print('BaseClass')class SubClassA(BaseClass): def show(self): print('Enter SubClassA') super().show() print('Exit SubClassA')class SubClassB(BaseClass): def show(self): print('Enter SubClassB') # super().show() # 不再向上一层解析 print('Exit SubClassB') class SubClassC(SubClassA): def show(self): print('Enter SubClassC') super().show() print('Exit SubClassC')class SubClassD(SubClassB, SubClassC): def show(self): print('Enter SubClassD') super().show() print('Exit SubClassD')d = SubClassD()d.show()print(SubClassD.mro())'''Enter SubClassDEnter SubClassBExit SubClassBExit SubClassD[&lt;class '__main__.SubClassD'&gt;, &lt;class '__main__.SubClassB'&gt;, &lt;class '__main__.SubClassC'&gt;, &lt;class '__main__.SubClassA'&gt;, &lt;class '__main__.BaseClass'&gt;, &lt;class 'object'&gt;]''' 多态所谓多态（polymorphism），是指基类的同一个方法在不同派生类对象中具有不同的表现和行为。派生类继承了基类行为和属性之后，还会增加某些特定的行为和属性，同时还可能会对继承来的某些行为进行一定的改变，这都是多态的表现形式。 Python大多数运算符可以作用于多种不同类型的操作数，并且对于不同类型的操作数往往有不同的表现，这本身就是多态，是通过特殊方法与运算符重载实现的。","link":"/2020/06/python-topic2/"},{"title":"STL中_Rb_tree的探索","text":"我们知道STL中我们常用的set与multiset和map与multimap都是基于红黑树。本文介绍了它们的在STL中的底层数据结构_Rb_tree的直接用法与部分函数。难点主要是_Rb_tree的各个参数的确定。 特别注意在如下代码的Selector类用于从Node中选出用于排序的key值，这个仿函数必须返回const int&amp;而不能是int，否则less&lt;int&gt;::operator(const int&amp;, const int&amp;)会抛出segmentation fault。一开始写成int，看了很多源码才发现是这个原因，一定要注意。（Update on 2020-5-6：通过对源码阅读，终于彻底明白为何出现写int会出现问题，见文末） 接下来是样例代码，里面都有注释了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;iomanip&gt;// 原则上不要直接引用这个头文件，这里只是为了测试#include &lt;bits/stl_tree.h&gt;using namespace std;struct Node { int first, second; Node(int _first, int _second) : first(_first), second(_second){}; friend ostream&amp; operator&lt;&lt;(ostream&amp; outs, const Node&amp; node) { outs &lt;&lt; '{' &lt;&lt; node.first &lt;&lt; ',' &lt;&lt; node.second &lt;&lt; '}'; return outs; }};template &lt;class T&gt;struct Selector { // MUST return const int&amp;, not int. // if return int, segmentation fault will occur. // I have spent much time because of this. const int&amp; operator()(const T&amp; obj) const { return obj.first; }};int main() { // _Rb_tree: red-black tree in STL. using tree_type = _Rb_tree&lt;int, Node, Selector&lt;Node&gt;, less&lt;int&gt;&gt;; using iterator_type = tree_type::iterator; using result_pair_type = pair&lt;tree_type::iterator, bool&gt;; tree_type tree; // 插入元素Node(1, 2) result_pair_type res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert address = \" &lt;&lt; res.first._M_node &lt;&lt; endl; cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // true iterator_type it = tree.begin(); cout &lt;&lt; \"begin address = \" &lt;&lt; it._M_node &lt;&lt; endl; it = tree.find(1); cout &lt;&lt; \"address = \" &lt;&lt; it._M_node &lt;&lt; \", value = \" &lt;&lt; *it &lt;&lt; endl; // 再插入元素Node(1, 2)但是因为调用的是insert_unique // 它不会添加重复值，所以插入会被拒绝 res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // false // 再插入元素Node(1, 2)但这次调用insert_equal // multiset和multimap就是利用这个函数来插入重复值 // 也就是这个函数允许重复值，所以插入成功 tree._M_insert_equal(Node(1, 3)); cout &lt;&lt; \"size = \" &lt;&lt; tree.size() &lt;&lt; endl; // 大小就变为2 pair&lt;iterator_type, iterator_type&gt; result = tree.equal_range(1); for (iterator_type ite = result.first; ite != result.second; ++ite) { cout &lt;&lt; \"address = \" &lt;&lt; ite._M_node &lt;&lt; \", value = \" &lt;&lt; *ite &lt;&lt; endl; } return 0;} 程序的输出为（内存地址不定）： 12345678insert address = 0xf91be0insert result = truebegin address = 0xf91be0address = 0xf91be0, value = {1,2}insert result = falsesize = 2address = 0xf91be0, value = {1,2}address = 0xf91c10, value = {1,3} Update on 2020-5-6 当将Selector::operator()的返回值写为int时，执行时会在main()中的it = tree.find(1)时抛出Segmentation Fault。以下给出调用过程。 12345678910111213141516171819202122232425262728293031// main.cpp, main()int main() { ... it = tree.find(1); ...}// stl_tree.h, std::_Rb_tree::find(const _Key&amp;)template&lt;typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc&gt;typename _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::iterator _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;:: find(const _Key&amp; __k) { iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k); return (__j == end() || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j; }// stl_tree.h, std::_Rb_tree::_M_lower_bound(_Link_type, _Link_type, const _Key&amp;)template&lt;typename _Key, typename _Val, typename _KeyOfValue, typename _Compare, typename _Alloc&gt;typename _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::iterator _Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;:: _M_lower_bound(_Link_type __x, _Link_type __y, const _Key&amp; __k) { while (__x != 0) if (!_M_impl._M_key_compare(_S_key(__x), __k)) __y = __x, __x = _S_left(__x); else __x = _S_right(__x); return iterator(__y); } 在此处的 _M_impl._M_key_compare 也就是比较仿函数对象，在这里即less&lt;int&gt;对象。异常就是在这个函数里抛出的，可见问题出现在 _S_key(__x) 中。 1234// stl_tree.h, std::_Rb_tree::_S_key(_Const_Base_ptr)static const _Key&amp; _S_key(_Const_Base_ptr __x) { return _KeyOfValue()(_S_value(__x));} 这里的 _KeyOfValue() 就是我们给的 Selector 了。所以在这里如果将 operator() 的返回值写为 int ，则这里将其以 const _Key&amp; 返回，就是返回局部对象的引用，后面又在 less&lt;int&gt;::operator() 里面使用了这个引用（这个引用实际上指向一个已过期的栈上数据： _KeyOfValue() 的返回值），这个行为导致了Segmentation Fault。","link":"/2020/05/stl-rb_tree/"},{"title":"后缀数组","text":"相关定义及其证明sa 后缀数组 suffix array保存 $0 \\sim n-1$ 的全排列，含义是把所有后缀按字典序排序后，后缀在原串中的位置。$suffix(sa[i]) &lt; suffix(sa[i + 1])$ $sa[,]$ 记录位置，即“排第i的后缀是谁”。 rk 名次数组 rank array保存 $0 \\sim n-1$ 的全排列，$rk[i]$ 的含义是 $suffix(i)$ 在所有后缀中按字典序排序的名次。 $rk[,]$ 记录排名，即“第以第i个字符起始的后缀子串在所有后缀子串中排第几”。 sa 与 rk 的关系$sa[,]$ 与 $rk[,]$ 是一一对应的关系，且互为逆运算。于是 可用 $rk[,]$ 推导 $sa[,]$： for (int i = 0; i &lt; n; ++i) sa[rk[i]] = i; 可用 $sa[,]$ 推导 $rk[,]$： for (int i = 0; i &lt; n; ++i) rk[sa[i]] = i; LCP 最长公共前缀LCP 即 Longest Common Prefix，最长公共前缀。 记 $LCP(i, j)$ 为 $suffix(sa[i])$ 与 $suffix(sa[j])$ 的最长公共前缀长度，即排序后第 $i$ 个后缀与第 $j$ 个后缀的最长公共前缀长度 LCP Lemma (LCP引理)若 $0 \\lt i \\lt j \\lt k \\le n-1$，则 $LCP(i, k) = min{LCP(i, j),,LCP(j, k)}$。 证明： 设 $p=min{LCP(i, j), LCP(j, k)}$ ，则 $LCP(i, j) \\ge p ,;LCP(j, k) \\ge p$。 又设 $suffix(sa[i])=u,;suffix(sa[j])=v,;suffix(sa[k])=w$ ①。 我们记 $a=_{len}b$表示字符串 $a$ 长度为 $len$ 的前缀与字符串 $b$ 的长度为 $len$ 的前缀相等。 则由 $u={LCP(i,j)}v$ 可得 $u={p}v, ; v=_{p}w$ 。 于是可得 $u=_{p}w$。即 $LCP(i, k) \\ge p = min{LCP(i, j),,LCP(j, k)}$。 现在我们再证 $LCP(i,k) \\gt p$ 是不可能的。 又设存在一个 $q \\gt p$，$LCP(i, k) = q$。 则可得 $u[i] = w[i]$ 对任意 $i \\in [1, q]$ 均成立。由于 $q \\gt p$，所以上式中的一个是 $u[p+1] = w[p+1]$。 由 ① 得 $u[p+1] \\leq v[p+1] \\leq w[p+1]$。结合上一行得 $u[p+1]=v[p+1]=w[p+1]$。 而 $p=min{LCP(i, j), LCP(j, k)}$，即 $u[p+1] \\neq v[p+1]$ 或 $v[p+1] \\ne w[p+1]$。 出现矛盾，故不存在 $q$ ，使得假设 $LCP(i, k) = q \\gt p$ 成立。即得 $LCP(i, k) \\le p$。 故得 $LCP(i, k) \\ge p$ 且 $LCP(i, k) \\le p$。 最后 $LCP(i, k) = min{LCP(i, j), LCP(j, k)}$。 LCP Theorem(LCP定理)若 $i \\lt j$ 则 $LCP(i, j) = min{LCP(k - 1, k)},;i \\lt k \\le j$ 证明：由 LCP Lemma 与数学归纳法可得。 height 高度数组$height[,]$ 是一个辅助数组，和最长公共前缀 (LCP) 相关。 令 $height[i]=LCP(i-1,i),;1 \\lt i \\le n$ ，即 $suffix(sa[i-1])$ 与 $suffix(sa[i])$ 的最长公共前缀长度。 为了描述方便，记 $h[i]$ 为 $height[rank[i]]$ ，即后缀 $suffix(i)$ 与 $suffix(sa[rank[i]-1])$ 的LCP长度。 有一个很重要的性质可以让我们在 $O(N)$ 的时间内求得 $height[]$ 数组：$h[i] \\ge h[i-1] - 1$ 。 证明： 设 $suffix(k)$ 是排在 $suffix(i-1)$ 前一名的后缀，则它们的LCP长度为 $h[i-1]$。两者都去掉第一个字符，得到 $suffix(k+1)$ 与 $suffix(i)$ 。 ① 若 $h[i-1] \\le 1$ ，即 $h[i-1]-1 \\le 0$ ，则 $h[i] \\ge h[i-1] - 1$ 显然成立。 ② 若 $h[i-1] \\gt 1$ ，则在上面去掉第一个字符的过程中是去掉的两者LCP中的第一个字符，那么 $suffix(k+1)$ 与 $suffix(i)$ 的LCP长度就至少为 $h[i] \\ge [h-1]-1$ 。 故 $h[i] \\ge h[i-1]-1$ 得证。 倍增+基数排序 求 sa, rk, height 三数组个人模板，供参考。设字符串长度为 $N$，则下面代码求三数组的复杂度为 $O(N;logN)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 50;char s[N];int sa[N], rk[N], cnt[N], height[N], t1[N], t2[N];void calcSA(char *s, int n) { int m = 256; int i, *x = t1, *y = t2; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i] = s[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (i = n - k + 1; i &lt;= n; ++i) y[++p] = i; for (i = 1; i &lt;= n; ++i) if (sa[i] &gt; k) y[++p] = sa[i] - k; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[y[i]]]--] = y[i]; swap(x, y); x[sa[1]] = 1; p = 1; for (i = 2; i &lt;= n; ++i) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? p : ++p; if (p &gt;= n) break; m = p; } for (i = 1; i &lt;= n; ++i) rk[sa[i]] = i; for (int i = 1, k = 0; i &lt;= n; ++i) { if (rk[i] == 1) { height[rk[i]] = 0; } else { if (k) --k; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k; height[rk[i]] = k; } }}int main() { scanf(\"%s\", s + 1); int len = strlen(s + 1); calcSA(s, len); for (int i = 1; i &lt;= len; ++i) printf(\"%d \", sa[i]); return 0;} 后记https://www.cnblogs.com/ECJTUACM-873284962/p/6618870.html https://blog.csdn.net/qq_37774171/article/details/81776029 从上两文中做了一些参考，但部分证明感觉并不浅显易懂，在加以个人理解后最后形成此文。","link":"/2019/08/suffix-array/"},{"title":"TCP/IP学习笔记：DNS","text":"概述DNS：Domain Name System，域名系统。它是： 一个由分层的DNS服务器（DNS Server）实现的分布式数据库； 一个使得主机能够查询分布式数据库的应用层协议。 它运行在UDP之上，使用53号端口。 它提供的服务： 主机名到IP地址转换的目录服务。 主机别名。有着复杂主机名的主机能拥有一个或多个别名。复杂主机名也称为规范主机名。如果存在主机别名，主机别名比规范主机名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址。 邮件服务器别名。电子邮件应用程序可以调用DNS，对提供的主机名别名（如yahoo.com）进行解析，已获得该主机的规范主机名（如relay1.west-coast.hotmail.com）及其IP地址。 负载分配。DNS也用在冗余的服务器（如冗余的Web服务器）之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。由于这些冗余的Web服务器，一个IP地址集合因此与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。 域名空间 图源：《TCP/IP详解 卷1：协议》 DNS的分布式、层次数据库大致说来，在DNS服务器的层次结构中有3种类型的DNS服务器： 根DNS服务器：提供TLD服务器的IP地址。 顶级域名（Top-Level-Domain, TLD）DNS服务器：提供权威DNS服务器的IP地址。 权威DNS服务器：在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。一个组织机构的权威DNS服务器收藏了这些DNS记录。 还有一类重要的DNS服务器，严格而言它不属于DNS服务器的层次结构，但它对DNS层次结构至关重要。这一类DNS服务器是本地DNS服务器。每个ISP（如一个居民区的ISP或一个机构的ISP）都有一台本地DNS服务器（也叫默认名字服务器）。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址（通常通过DHCP）。主机的本地DNS服务器通常“临近”本主机：对某机构ISP而言，本地DNS服务器可能就与主机在同一局域网中；对于某居民区ISP来说，本地DNS服务器通常与主机相隔不超过几台路由器。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。 查询分为递归查询与迭代查询。 （具体例子见 《计算机网络：自顶向下方法（原书第7版）》P86-88） DNS缓存在一个请求链中，当某DNS服务器接收一个DNS回答（如包含某主机名到IP地址的映射）时，它能将映射缓存在本地存储器中。由于主机和主机名与IP地址间的映射不是永久的，所以DNS服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。 本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器基本都被绕过了。 DNS记录共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射。资源记录是一个包含了以下字段的4元组： (Name, Value, Type, TTL) TTL 该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。 Name、Value、Type 若Type=A，则Name是主机名，Value是该主机名对应的IP地址。该类型的资源记录提供了标准的主机名到IP地址的映射。如(relay1.bar.foo.com, 145.37.93.126, A)。 若Type=NS，则Name是个域（如foo.com），而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。如(foo.com, dns.foo.com, NS)。 若Type=CNAME，则Value是别名为Name的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如(foo.com, relay1.bar.foo.com, CNAME)。 若Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。如(foo.com, mail.bar.foo.com, MX)。通过使用MX记录，一个公司的邮件服务器和其他服务器（如Web服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS客户应当请求一条MX记录；而为了获得其他服务器的规范主机名，DNS客户应当请求CNAME记录。 参考资料《计算机网络：自顶向下方法（原书第7版）》P83-92","link":"/2020/03/tcp-ip-dns/"},{"title":"Valgrind安装与memcheck简单使用","text":"安装 valgrindsudo apt install valgrind 安装后，查看一下版本以确认安装成功 valgrind --version 输出形如以下版本号信息就表示安装成功 1valgrind-3.11.0 使用 memcheck 检查内存泄漏memleak.cpp 12345678910111213141516171819202122232425262728293031class A {public: A() { a_arr = new int[5]; } ~A() { delete[] a_arr; }private: int* a_arr;};class B : public A {public: B() { b_arr = new int[3]; } ~B() { delete[] b_arr; }private: int* b_arr;};int main() { A* pa = new B(); delete pa; return 0;} 12g++ -g memleak.cpp -o memleakvalgrind --tool=memcheck ./memleak 其中 --tool=memcheck 可以省略，因为 valgrind 的默认工具就是 memcheck 。可以检查出类B对象中的12个字节（3个int）内存泄漏（见下方 definitely lost ）： 1234567891011121314151617181920==7661== Memcheck, a memory error detector==7661== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.==7661== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info==7661== Command: ./memleak==7661====7661====7661== HEAP SUMMARY:==7661== in use at exit: 72,716 bytes in 2 blocks==7661== total heap usage: 4 allocs, 2 frees, 72,752 bytes allocated==7661====7661== LEAK SUMMARY:==7661== definitely lost: 12 bytes in 1 blocks==7661== indirectly lost: 0 bytes in 0 blocks==7661== possibly lost: 0 bytes in 0 blocks==7661== still reachable: 72,704 bytes in 1 blocks==7661== suppressed: 0 bytes in 0 blocks==7661== Rerun with --leak-check=full to see details of leaked memory==7661====7661== For counts of detected and suppressed errors, rerun with: -v==7661== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 使用 memcheck 检查 overlapstrncpy.cpp 1234567891011121314151617#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main() { char s[60]; memset(s, '*', sizeof(s)); strcpy(s, \"abcdefghijklmnopqrstuvwxyz\"); strncpy(s + 26, s, 26); for (int i = 0; i &lt; 60; i++) cout &lt;&lt; (s[i] ? s[i] : '_'); cout &lt;&lt; '\\n'; strncpy(s + 26, s, 27); for (int i = 0; i &lt; 60; i++) cout &lt;&lt; (s[i] ? s[i] : '_'); cout &lt;&lt; '\\n'; return 0;} 12g++ -g strncpy.cpp -o strncpyvalgrind --tool=memcheck ./strncpy 此时memcheck会检查出重叠（overlap）错误。输出如下 123==7561== Source and destination overlap in strncpy(0xfff0003d5, 0xfff0003bb, 27)==7561== at 0x4C31626: __strncpy_sse2_unaligned (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)==7561== by 0x400951: main (strncpy.cpp:13)","link":"/2020/03/valgrind-installation-and-memcheck-usage/"},{"title":"TCP/IP学习笔记：HTTP","text":"报文格式请求报文12345GET /somedir/page.html HTTP/1.1Host: www.someschool.eduConnection: closeUser-agent: Mozilla/5.0Accept-language: fr 第一行叫做请求行，其后继的行叫做首部行。首部行中，冒号左边的称为首部字段名，右边称为值。 请求行 方法字段 GET：浏览器请求一个对象。 POST：当用户提交表单时，HTTP客户常使用POST方法，表单中的值存放在实体体中。 HEAD：类似于GET方法，当服务器收到一个HEAD请求时，将对用一个HTTP报文进行响应，但是不返回请求对象。 PUT：用户上传对象到指定的Web服务器上的指定路径（目录）。 DELETE：用户或应用程序删除Web服务器上的对象。 URL字段：例子中的/somedir/page.html。 版本字段：例子中的HTTP/1.1。 首部行 Host：指明对象所在的主机。 Connection: close告诉服务器不要使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。 User-agent：指明用户代理，即向服务器发送请求的浏览器类型。这里的Mozilla/5.0就是Firefox浏览器。 Accept-language：用户想得到的对象的语言，如这里的Fr即指法语版本。若服务器中没有这样的对象，那么服务器应当发送它的默认版本。 If-modified-since：（条件GET方法）若服务器上的对象在此日期之后被修改，服务器才会传回新对象，否则服务器返回304 Not Modified。这个日期通常来源于之前请求时得到的响应报文中的Last-modified首部行。 cookie：本机对应本站点的cookie。 实体体（可以不存在） ​ 如上所述，实体体通常含通过POST方法发送的表单信息。 一个HTTP请求报文的通用格式为： 1234567&lt;方法&gt; &lt;URL&gt; &lt;版本&gt;\\r\\n&lt;首部字段名:&gt; &lt;值&gt;\\r\\n&lt;首部字段名:&gt; &lt;值&gt;\\r\\n...&lt;首部字段名:&gt; &lt;值&gt;\\r\\n\\r\\n&lt;实体体&gt; 响应报文下面这个报文可以是对上述请求报文例子的回应。 12345678HTTP/1.1 200 OKConnection: closeDate: Tue, 18 Aug 2015 15:44:04 GMTServer: Apache/2.2.3 (CentOS)Last-Modified: Tue, 18 Aug 2015, 15:11:03 GMTContent-Length: 6821Content-Type: text/html(data data data data data ...) 这个例子中，第1行称为状态行，第2-7行称为首部行，接下来是实体体。实体体部分是报文的主要部分，它包含了所请求的对象本身（表示为data data data data data ...）。 状态行 协议版本字段（HTTP/1.1） 状态码（200） 常见的状态码： 状态码&amp;短语 含义 200 OK 请求成功，信息在返回的响应报文中。 301 Moved Permanently 请求的对象已经被永久转移，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。 304 Not Modified 告诉缓存器可以使用原有对象。 400 Bad Request 一个通用差错代码，指示该请求不能被服务器理解。 404 Not Found 被请求的文档不在服务器上。 505 HTTP Version Not Supported 服务器不支持请求报文使用的HTTP协议版本。 相应状态信息（OK） 首部行 Connection: close告诉客户发送完报文后将关闭该TCP连接。 Date：服务器产生并发送该响应报文的日期和时间。（不是对象创建或最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间） Server：生成该报文的服务器信息。（与请求报文中的User-agent对应） Last-Modified：对象创建或最后修改的日期和时间。（对对象缓存很重要） Content-Length：被发送对象的字节数。 Content-Type：对象类型。这里对象类型是HTML文本。（对象类型应该正式地由Content-Type首部行而不是用文件扩展名来指示） Set-cookie：设置cookie。 实体体（可以不存在） ​ 含有对象内容。 参考资料《计算机网络：自顶向下方法（原书第7版）》P64-75","link":"/2020/03/tcp-ip-http/"},{"title":"VMware使用相关","text":"压缩自增长的虚拟磁盘体积运行前应保证虚拟磁盘所在的宿主机硬盘分区下有足够空间。 在虚拟机下，运行 12sudo apt install open-vm-toolssudo vmware-toolbox-cmd disk shrink / 将自增长的虚拟磁盘切换为预分配在 VMware 安装目录下，运行 1vmware-vdiskmanager -r \"原vmdk名\" -s 30GB -t 2 \"新vmdk名\" 可将自增长的虚拟磁盘切换为预分配30GB。 虚拟磁盘重命名在 VMware 安装目录下，运行 1vmware-vdiskmanager -n \"原vmdk名\" \"新vmdk名\" Windows 上创建打开一个特定虚拟机的快捷方式设置快捷方式目标 1&quot;...\\VMware Workstation\\vmrun.exe&quot; -T ws start &quot;...\\UbuntuServer.vmx&quot;","link":"/2020/10/vmware-notes/"},{"title":"TCP/IP学习笔记：传输层","text":"传输层传输层也称为运输层（Transport Layer）。在此层的分组，TCP称为“报文段”，UDP称为“数据报“。 进程到进程的数据交付（多路复用与多路分解）和差错检查是两种最低限度的传输层服务，也是UDP所能提供的仅有的两种服务。 端口号端口号为一个16比特的值，即范围为 0-65535。其中 0-1023 称为“周知端口号”。 UDP套接字由一个二元组全面标识：目的IP地址、目的端口号。 TCP套接字由一个四元组全面标识：源IP地址、源端口号、目的IP地址、目的端口号。 TCP与UDP的比较相比TCP，UDP满足： 关于发送什么数据以及何时发送的应用层控制更精细 无需连接建立 无连接状态（无须保存与维护连接状态，节约资源） 分组的首部开销小。（TCP：20 Bytes，UDP：8 Bytes） UDP报文段格式 源端口号 (2 bytes) 目的端口号 (2 bytes) 长度 (2 bytes) 检验和 (2 bytes) 应用数据 当一台主机接收一个UDP分组，它的目的端口与运行中的任一UDP套接字都不匹配，则该主机发送一个特殊的ICMP数据报。 可靠数据传输解决流水线的差错恢复有2种基本方法： 回退N步（Go-Back N，GBN），即“滑动窗口协议”（Sliding-Window Protocol） 选择重传（Selective Repeat，SR）。选择重传协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失/受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个确认正确接收的分组。对于选择重传协议，其窗口长度必须小于等于序号空间的一半。 TCP概念 发起连接的称为客户，另一方称为服务器。 TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度MSS（Maximum Segment Size）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（最大传输单元MTU，Maximum Transmission Unit）。该MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上TCP/IP首部长度（通常为40字节 [TCP首部20字节，IP首部20字节]）须能放入单个链路层帧中。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。注意MSS是指在报文段里应用层数据的最大长度而非指包括首部的TCP报文段的最大长度。 TCP报文段首部 源端口号 (16 bits) 目的端口号 (16 bits) 序号 (32 bits) 确认号 (32 bits) 首部长度 (4 bits) 以 32 bits (4 bytes) 的字为单位的TCP首部长度 典型长度为20字节，即值为5 (20 bytes = 5 * 4 bytes) 最大范围：$2^4 \\times 32 \\ bits=16 \\times 4 \\ bytes=64 \\ bytes$ 保留未用 (4 bits) CWR (1 bit) ECE (1 bit) URG (1 bit)：指示报文段里存在着被发送端的上层实体置为紧急的数据 ACK (1 bit) PSH (1 bit)：指示接收方应立即将数据交给上层 RST (1 bit) SYN (1 bit) FIN (1 bit) 接收窗口 (16 bits)：用于流量控制，指示接收方愿意接受的字节数量 因特网检验和 (16 bits) 紧急数据指针 (16 bits)：指出紧急数据的最后一个字节；当紧急数据存在并给出指向紧急数据尾指针时，TCP必须通知接收端的上层实体 选项 (可选且变长) 序号SYN与确认号ACK 主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号 TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累计确认（cumulative acknowledgment） 一条TCP连接的双方均可随机地选择初始序号，这样做可以减少将那些仍在网络中存在的，来自两台主机之间先前已终止的连接的报文段误认为是后来这两台主机之间新建的连接所产生的有效报文段的可能性（且该新连接碰巧与旧连接使用了相同的端口号） 该客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中，这种确认被称为是捎带（piggybacked）在服务器到客户的报文段中的。 估计往返时间（定时器时长的设定）报文段的样本RTT（表示为 $SampleRTT$）就是从某报文段被发出（即交给IP）到对该报文段的确认被收到之间的时间量。 大部分TCP的实现仅能某个时刻做一次 $SampleRTT$ 测量，而不是为每个发送的报文段估计 $SampleRTT$，从而产生一个接近每个RTT的新 $SampleRTT$ 值。 另外，TCP绝不为已被重传的报文段计算 $SampleRTT$。 显然随各种环境变化，报文段的 $SampleRTT$ 会波动，由于这种波动的存在，任何指定的 $SampleRTT$ 值可能都不是特定的。于是为估计一个相对典型的RTT，要采取某种对 $SampleRTT$ 取平均的方法，TCP维持一个 $SampleRTT$ 均值（称为 $EstimatedRTT$）。一旦获得一个新的 $SampleRTT$ 时，TCP就会根据以下公式求得（更新）$EstimatedRTT$： $$EstimatedRTT=(1-\\alpha) \\cdot EstimatedRTT + \\alpha \\cdot SampleRTT$$ 在 RFC 6298 中给出的 $\\alpha$ 推荐值为 $\\alpha = 0.125$，从统计学观点讲，这种平均被称为“指数加权移动平均”（Exponential Weighted Moving Average，EWMA）。这种加权平均对最近的样本赋予的权值要大于对旧样本赋予的权值。 除估算RTT外，测量RTT的变化也是有价值的。RFC 6298 中也定义了RTT偏差 $DevRTT$，用于估算 $SampleRTT$ 一般会偏离 $EstimatedRTT$ 的程度： $$DevRTT = (1-\\beta) \\cdot DevRTT + \\beta \\cdot\\lvert SampleRTT-EstimatedRTT \\rvert$$ $DevRTT$ 是一个 $SampleRTT$ 与 $EstimatedRTT$ 之间差值的 EWMA，其中 $\\beta$ 的推荐值为 $\\beta = 0.25$。 设置和管理重传超时间隔将超时间隔设为 $EstimatedRTT$ 加上一个余量，当 $SampleRTT$ 值波动较大时，这个余量应该大些；反之应小些。$DevRTT$ 在此发挥作用： $$TimeoutInterval = EstimatedRTT + 4 \\cdot DevRTT$$ 事实上大多数TCP实现，只是在每次重传时将 $TimeoutInterval$ 变为2倍。 推荐的初始 $TimeoutInterval$ 的值为1秒，在出现超时该值将加倍，以免即将被确认的后继报文段过早超时，然而只要收到报文段并更新 $EstimatedRTT$，就使用上式更新 $TimeoutInterval$ [每当定时器在另两个事件(收到上层应用的数据/收到ACK)中的任意一个启动时，$TimeoutInterval$ 由最近的 $EstimatedRTT$ 与 $DevRTT$ 值推算得到]。 有些版本的TCP还有一个隐式NAK机制，在TCP的快速重传机制下，收到对一个特定报文段的3个冗余ACK就可作为对后面报文段的一个隐式NAK，从而在超时之前触发对该报文段的重传。 快速重传 Fast Retransmit 冗余ACK（Duplicate ACK）：再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认； 因为TCP不使用否定确认，所以接收方不能向发送方发回一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认； 因为发送方经常一个接一个地发送大量的报文段，若一个报文段的丢失，就很可能引起许多一个接一个的冗余ACK。若TCP发送方接收到对相同数据的3个冗余ACK，它把这当作一种指示，说明跟在这个已被确认过3次的报文段之后的报文段已丢失。一旦收到3个冗余ACK，TCP就执行快速重传。 产生TCP ACK的建议 (RFC 5681) 事件 TCP接收方动作 具有所期望序号的按序报文段到达，所有在期望序号及以前的数据都已被确认 延迟的ACK。对另一个按序报文段的到达最多等待 500ms，若一个按序报文段在此时间间隔内未到达，则发送一个ACK。 具有所期望序号的按序报文段到达，另一个按序报文段等待ACK传输 立即发送单个累积ACK，以确认两个按序报文段 比期望序号大的失序报文段到达，检测出间隔 立即发送冗余ACK，指示下一个期待字节的序号（即间隔的低端序号） 能部分或完全填充接收数据间隔的报文段到达 倘若该报文段起始于间隔的低端，则立即发送ACK 流量控制 Flow-Control Service 消除发送方使接收方缓存溢出的可能性 速度匹配服务，即发送方的发送速率与接收方的接受速率匹配 接收窗口大小 $rwnd=RcvBuffer - (LastByteRcvd - LastByteRead)$ 则发送方在该连接的整个生命周期须保证 $LastByteSent - LastByteAcked \\le rwnd$ 当接收方的窗口满时使 $rwnd=0$，按上述方案可能导致发送方一直等待接收方。为此TCP规定要求：当接收方的接收窗口为 $0$ 时发送方继续发送只有一个字节数据的报文段，这些报文段会被接收方确认，最终缓存将开始清空，且确认报文里将包含一个非 $0$ 的 $rwnd$ 值。 TCP三次握手 RST当一台主机收到一个TCP报文段，但其端口号或源IP地址与该主机上进行中的套接字都不匹配时，该主机将向源发送一个特殊重置报文段，即RST标志位置1。当主机发送一个重置报文段时，它告诉该源”我没有那个报文段的套接字，请不要再发送该报文段了“。 拥塞控制概括运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，“拥塞窗口” $cwnd$ （congestion window）： $$LastByteSent-LastByteAcked \\le min(rwnd, cwnd)$$ “丢包事件”定义为：出现超时或收到来自接收方的3个冗余ACK（即4个确认，一个初始ACK和其后的3个冗余ACK）。 一个丢失的报文段表示拥塞出现，因此当丢失报文段时应当降低TCP发送方的速率。 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此当对先前未确认报文段的确认到达时，能够增加发送方的速率。（确认的到达被认为是“一切顺利”的隐含指示） 具体算法 《计算机网络：自顶向下方法》P179 图3-51 公平性公平性与UDP从TCP的视角来看，UDP不与其它连接合作，也不适时地调整其传输速率，因为TCP拥塞控制在面临拥塞增加（丢包）时，将降低其传输速率，而UDP源则不必这样做，如此UDP源有可能压制TCP流量。 公平性与并行TCP连接例如Web服务器通常使用多个并行TCP连接来传送一个Web页中的多个对象。当一个应用使用多条并行连接时，它占用了一条拥塞链路中较大比例的带宽。 明确拥塞通告：网络辅助拥塞控制一个TCP发送方不会收到来自网络层的明确拥塞指示，而是通过观察分组丢失来推断拥塞，然而对于IP和TCP的扩展方案RFC 3168已经提出并已经实现和部署，该方案允许网络明确向TCP发送方和接收方发出拥塞信号，这种形式的网络辅助拥塞控制称为明确拥塞通告（Explicit Congestion Notification，ECN）。 在网络层，IP数据包首部的服务类型字段中的两个比特被用于ECN。路由器所使用的一种ECN比特设置指示该路由器正在历经拥塞。该拥塞指示则由被标记的IP数据报所携带，送给目的主机，再由目的主机通知发送主机。 RFC 3168推荐仅当拥塞持续不断存在时才设置ECN比特。（发送主机所使用的另一种ECN比特设置通知路由器发送方和接收方是ECN使能的，因此能够对于ECN指示的网络拥塞采取行动） 当接收主机中的TCP通过一个接收到的数据报收到了一个ECN拥塞指示时，接收主机中的TCP通过在接收方到发送方的TCP ACK报文段中设置ECE（明确拥塞通告回显，ECN Echo）比特，通知发送主机中的TCP收到拥塞指示。接下来，TCP发送方通过减半拥塞窗口对一个具有ECE拥塞指示的ACK作出回应，就像它对丢失报文段使用快速重传作出回应一样，并且在下一个传输的TCP发送方到接收方的报文段首部中对CWR（拥塞窗口缩减）比特进行设置。 ReferenceJames F. Kurose and Keith W. Ross, Computer Networking: A Top-Down Approach, 7E, Pearson Education, 2017. 中译版：陈鸣译，2019年，机械工艺出版社。","link":"/2020/10/tcp-ip-transport-layer/"},{"title":"2020-04 LeetCode每日一题做题记录","text":"Apr.30 快乐数12345678910111213141516class Solution: def isHappy(self, n: int) -&gt; bool: def change(x: int) -&gt; int: ret = 0 while x: x, digit = divmod(x, 10) ret += digit * digit return ret st = set() while n not in st: if n == 1: return True st.add(n) n = change(n) return False Apr.29 山脉数组中查找目标值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 4 ms, 7.2 MB/** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * class MountainArray { * public: * int get(int index); * int length(); * }; */class Solution {public: template&lt;typename Func&gt; int binary_search(MountainArray&amp; mountainArr, int target, int l, int r, Func func) { target = func(target); while (l &lt;= r) { int mid = (l + r) / 2; int cur = func(mountainArr.get(mid)); if (cur == target) return mid; if (cur &lt; target) l = mid + 1; else r = mid - 1; } return -1; } int findInMountainArray(int target, MountainArray &amp;mountainArr) { int l = 0, r = mountainArr.length() - 1; while (l &lt; r) { int mid = (l + r) / 2; if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) { l = mid + 1; } else { r = mid; } } int peak = l; int index = binary_search(mountainArr, target, 0, peak, [](int x) { return x; }); if (index != -1) return index; index = binary_search(mountainArr, target, peak + 1, mountainArr.length() - 1, [](int x) { return -x; }); return index; }}; Apr.28 数组中数字出现的次数分组异或。 12345678910111213141516// 40 ms, 16.1 MBclass Solution {public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) { int xor_all = 0; for (int val : nums) xor_all ^= val; // xor_all 中 1 的位表示两个只出现过一次的数中这一位不同 int bit = xor_all &amp; -xor_all; // 以 lowbit(xor_all) 区分两个组别 int a = 0, b = 0; // 对这两个组别分别做异或 for (int val : nums) { if (val &amp; bit) a ^= val; else b ^= val; } return {a, b}; }}; Apr.27 搜索旋转排序数组1234567891011121314151617181920212223242526272829303132333435363738// 0 ms, 6.4 MBclass Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { if (nums.empty()) { return -1; } int p = 0, q = 1; while (q) { if (p + q &gt;= nums.size() || nums[p + q] &lt; nums[p]) { q &gt;&gt;= 1; } else { p += q; q &lt;&lt;= 1; } } // nums[p] is the biggest value in nums. int l, r; if (target &gt;= nums[0]) { // the target's index is in [0, p]. l = -1; r = p + 1; } else { // the target's index is in [p+1, nums.size()-1]. l = p; r = nums.size(); } while (l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; if (nums[mid] &lt;= target) { l = mid; } else { r = mid; } } return l &gt;= 0 &amp;&amp; nums[l] == target ? l : -1; }}; Apr.26 合并K个排序链表123456789101112131415161718192021222324252627282930313233343536373839// 60 ms, 10.4 MB/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: struct Cmp { bool operator()(const ListNode* a, const ListNode* b) const { return a-&gt;val &gt; b-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap; for (ListNode* listHead : lists) { if (listHead) heap.push(listHead); } ListNode dummy; ListNode* last = &amp;dummy; while (!heap.empty()) { ListNode* now = heap.top(); heap.pop(); if (now-&gt;next) heap.push(now-&gt;next); last-&gt;next = now; last = now; } return dummy.next; }}; Apr.25 全排列解法一 123456789101112131415161718192021222324// 4 ms, 7.4 MBclass Solution {public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; now, const vector&lt;int&gt;&amp; nums, int visit) { if (visit == (1 &lt;&lt; nums.size()) - 1) { ans.emplace_back(now); return; } for (int i = 0; i &lt; nums.size(); i++) { if (!((visit &gt;&gt; i) &amp; 1)) { now.push_back(nums[i]); dfs(ans, now, nums, visit ^ (1 &lt;&lt; i)); now.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; dfs(ans, tmp, nums, 0); return ans; }}; 解法二 123456789101112131415161718192021// 4 ms, 7.2 MBclass Solution {public: void solve(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int pos) { if (pos == nums.size()) { res.emplace_back(nums); return; } for (int i = pos; i &lt; nums.size(); i++) { swap(nums[pos], nums[i]); solve(res, nums, pos + 1); swap(nums[pos], nums[i]); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ans; solve(ans, nums, 0); return ans; }}; Apr.24 数组中的逆序对经典问题，可用归并排序或树状数组解决。我的解法是离散化树状数组。时间复杂度 $O(N logN)$ ，空间复杂度 $O(N)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 468 ms, 45.3 MBclass Solution {public: vector&lt;int&gt; tree; vector&lt;int&gt; tmp; void init(int n) { tree.resize(n + 1); } int lowbit(int x) { return x &amp; -x; } void add(int x, int y, int n) { while (x &lt;= n) { tree[x] += y; x += lowbit(x); } } int sum(int x) { int sum = 0; while (x) { sum += tree[x]; x -= lowbit(x); } return sum; } int getId(int val) { return lower_bound(tmp.begin(), tmp.end(), val) - tmp.begin() + 1; } int reversePairs(vector&lt;int&gt;&amp; nums) { int ans = 0; tmp.insert(tmp.begin(), nums.begin(), nums.end()); sort(tmp.begin(), tmp.end()); tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end()); init(tmp.size()); for (int i = 0; i &lt; nums.size(); i++) { int id = getId(nums[i]); ans += i - sum(id); add(id, 1, tmp.size()); } return ans; }}; Apr.23 硬币完全背包。 1234567891011121314// 76 ms, 14.2 MBclass Solution {public: int waysToChange(int n) { vector&lt;int&gt; dp(n + 1); dp[0] = 1; for (int val : {1, 5, 10, 25}) { for (int i = val; i &lt;= n; i++) { dp[i] = (dp[i] + dp[i - val]) % 1000000007; } } return dp[n]; }}; Apr.22 二叉树的右视图DFS，对于每个结点的子树，先遍历右子树，再遍历左子树。时间复杂度 $O(N)$。 12345678910111213141516171819202122# 40 ms, 13.9 MB# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rightSideView(self, root: TreeNode) -&gt; List[int]: ans = [] def traverse(root: TreeNode, depth: int): if not root: return if len(ans) &lt;= depth: ans.append(root.val) traverse(root.right, depth + 1) traverse(root.left, depth + 1) traverse(root, 0) return ans Apr.21 统计「优美子数组」双指针，当维护的区间中的奇数个数cnt达到k时，保存此位置为k_cnt_right_begin，然后再将右端点r往右移直到指针到数组边界或右边的数字是个奇数（会导致cnt加1）。此时移动左端点l，每次移动对答案的贡献是r - k_cnt_right_begin + 1，即左端点为l，右端点落在[k_cnt_right_begin, r]的区间。移动l并更新cnt直到cnt &lt; k。此时再移动右指针。重复以上步骤直到遍历完数组即可。 时间复杂度 $O(N)$ ，空间复杂度 $O(1)$ 。 12345678910111213141516171819202122232425262728// 380 ms, 62.9 MBclass Solution {public: int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int l = 0, r = -1, cnt = 0; int ans = 0; while (r + 1 &lt; n) { // 在 cnt &lt; k 时继续拓展右端点 while (r + 1 &lt; n &amp;&amp; cnt &lt; k) cnt += nums[++r] &amp; 1; if (r &gt;= n) break; int k_cnt_right_begin = r; // 在维持 cnt == k 的前提下，再尽量移动右端点 while (r + 1 &lt; n &amp;&amp; !(nums[r + 1] &amp; 1)) ++r; // 则满足 cnt == k 的区间的左端点为 l // 右端点为 [k_cnt_right_begin, r] 之一 while (l &lt;= r &amp;&amp; cnt == k) { ans += r - k_cnt_right_begin + 1; cnt -= nums[l++] &amp; 1; } } return ans; }}; Apr.20 岛屿数量通过 BFS 或 DFS 搜索遍历每一个连通块即可。但 BFS 在队列上所消耗的空间为 $O(max(N, M))$ ，DFS在栈上所消耗的空间为 $O(N*M)$ 。 123456789101112131415161718192021222324# 80 ms, 14.4 MBclass Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 n, m = len(grid), len(grid[0]) # 为了保护 grid 数组，不直接使用 grid 数组进行标记 vis = [[False] * m for _ in range(n)] q = collections.deque() ans = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and vis[i][j] == False: q.append((i, j)) vis[i][j] = True ans += 1 while q: x, y = q.popleft() for a, b in (x-1, y), (x+1, y), (x, y-1), (x, y+1): if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m and grid[a][b] == '1' and not vis[a][b]: q.append((a, b)) vis[a][b] = True return ans Apr.19 统计重复个数Apr.18 盛最多水的容器123456789101112# 68 ms, 15.2 MBclass Solution: def maxArea(self, height: List[int]) -&gt; int: l, r = 0, len(height) - 1 ans = 0 while l &lt; r: ans = max(ans, (r - l) * min(height[l], height[r])) if height[l] &lt; height[r]: l += 1 else: r -= 1 return ans Apr.17 跳跃游戏1234567891011121314// 8 ms, 7.8 MBclass Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { const int n = nums.size(); int rightmost = 0; for (int i = 0; i &lt; n &amp;&amp; i &lt;= rightmost; i++) { rightmost = max(rightmost, i + nums[i]); } return rightmost &gt;= n - 1; }}; Apr.16 合并区间1234567891011121314151617# 52 ms, 14.6 MBclass Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: intervals.sort() ans = [] left, right = -1, -1 for interval in intervals: if interval[0] &gt; right: if left != -1: ans.append([left, right]) left, right = interval else: right = max(right, interval[1]) # why max: cases like [[1, 4], [2, 3]] if left != -1: ans.append([left, right]) return ans Apr.15 01矩阵以各 $0$ 节点为起点进行广度搜索即可，时间复杂度 $O(NM)$，空间复杂度 $O(NM)$ 。 1234567891011121314151617181920212223242526272829303132333435363738394041// 136 ms, 25.3 MBclass Solution {public: using PII = pair&lt;int, int&gt;; const int INF = 0x3F3F3F3F; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) { return {}; } const int n = matrix.size(); const int m = matrix[0].size(); const int go[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}}; queue&lt;PII&gt; q; vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, INF)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (matrix[i][j] == 0) { q.emplace(i, j); dist[i][j] = 0; } while (!q.empty()) { PII now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int x = now.first + go[i][0]; int y = now.second + go[i][1]; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; dist[x][y] == INF) { dist[x][y] = dist[now.first][now.second] + 1; q.emplace(x, y); } } } return dist; }}; 或用DP解，从左上角开始递推一次，再从右下角开始递推一次。时间复杂度 $O(NM)$，空间复杂度 $O(1)$ 。 12345678910111213141516171819202122232425262728293031323334// 140 ms, 23 MBclass Solution {public: const int INF = 0x3F3F3F3F; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) { return {}; } const int n = matrix.size(); const int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, INF)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (matrix[i][j] == 0) dist[i][j] = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) { if (i - 1 &gt;= 0) dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); if (j - 1 &gt;= 0) dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } for (int i = n - 1; i &gt;= 0; i--) for (int j = m - 1; j &gt;= 0; j--) { if (i + 1 &lt; n) dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); if (j + 1 &lt; m) dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } return dist; }}; Apr.14 两数相加1234567891011121314151617181920212223242526272829303132// 52 ms, 73.9 MB/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { stack&lt;int&gt; s1, s2; for (; l1; l1 = l1-&gt;next) s1.push(l1-&gt;val); for (; l2; l2 = l2-&gt;next) s2.push(l2-&gt;val); int carry = 0; ListNode* ans = nullptr; while (!s1.empty() || !s2.empty() || carry != 0) { int a = s1.empty() ? 0 : s1.top(); int b = s2.empty() ? 0 : s2.top(); if (!s1.empty()) s1.pop(); if (!s2.empty()) s2.pop(); int cur = a + b + carry; carry = cur / 10; cur %= 10; ListNode* curnode = new ListNode(cur); curnode-&gt;next = ans; ans = curnode; } return ans; }}; Apr.13 设计推特1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 76 ms, 20.5 MBclass Twitter {public: /** Initialize your data structure here. */ Twitter(): time(0) {} /** Compose a new tweet. */ void postTweet(int userId, int tweetId) { mp[userId].addTweet(time, tweetId); } /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; heap; for (int followee : mp[userId].followees) { for (const pair&lt;int, int&gt;&amp; timeId : mp[followee].tweets) { heap.push(timeId); if (heap.size() &gt; 10) heap.pop(); } } for (const pair&lt;int, int&gt;&amp; timeId : mp[userId].tweets) { heap.push(timeId); if (heap.size() &gt; 10) heap.pop(); } vector&lt;int&gt; res; res.reserve(heap.size()); while (!heap.empty()) { res.push_back(heap.top().second); heap.pop(); } reverse(res.begin(), res.end()); return res; } /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) { if (followerId == followeeId) return; mp[followerId].followees.insert(followeeId); } /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) { mp[followerId].followees.erase(followeeId); }private: struct Node { unordered_set&lt;int&gt; followees; list&lt;pair&lt;int, int&gt;&gt; tweets; // 1st-time, 2nd-id void addTweet(int&amp; time, int id) { if (tweets.size() == 10) tweets.pop_back(); tweets.emplace_front(++time, id); } }; int time; unordered_map&lt;int, Node&gt; mp;};/** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj-&gt;postTweet(userId,tweetId); * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId); * obj-&gt;follow(followerId,followeeId); * obj-&gt;unfollow(followerId,followeeId); */ Apr.12 交点参考官方题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def intersection(self, start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -&gt; List[float]: # 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上 # 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上 def inside(x1, y1, x2, y2, xk, yk): # 若与 x 轴平行，只需要判断 x 的部分 # 若与 y 轴平行，只需要判断 y 的部分 # 若为普通线段，则都要判断 return (x1 == x2 or min(x1, x2) &lt;= xk &lt;= max(x1, x2)) and (y1 == y2 or min(y1, y2) &lt;= yk &lt;= max(y1, y2)) def update(ans, xk, yk): # 将一个交点与当前 ans 中的结果进行比较 # 若更优则替换 return [xk, yk] if not ans or [xk, yk] &lt; ans else ans x1, y1 = start1 x2, y2 = end1 x3, y3 = start2 x4, y4 = end2 ans = list() # 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行 if (y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3): # 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上 if (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1): # 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上 if inside(x1, y1, x2, y2, x3, y3): ans = update(ans, x3, y3) # 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上 if inside(x1, y1, x2, y2, x4, y4): ans = update(ans, x4, y4) # 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上 if inside(x3, y3, x4, y4, x1, y1): ans = update(ans, x1, y1) # 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上 if inside(x3, y3, x4, y4, x2, y2): ans = update(ans, x2, y2) # 在平行时，其余的所有情况都不会有交点 else: # 联立方程得到 t1 和 t2 的值 t1 = (x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1)) t2 = (x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3)) # 判断 t1 和 t2 是否均在 [0, 1] 之间 if 0.0 &lt;= t1 &lt;= 1.0 and 0.0 &lt;= t2 &lt;= 1.0: ans = [x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)] return ans Apr.11 鸡蛋掉落参考官方题解 1234567891011121314151617181920class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: def f(x): ans = 0 r = 1 for i in range(1, K+1): r *= x-i+1 r //= i ans += r if ans &gt;= N: break return ans lo, hi = 1, N while lo &lt; hi: mi = (lo + hi) // 2 if f(mi) &lt; N: lo = mi + 1 else: hi = mi return lo Apr.10 翻转字符串里的单词模拟即可。这里给出原地算法和非原地算法。先给出空间 $O(N)$ 非原地算法： 1234567891011121314151617181920212223242526// 16 ms, 8.2 MBclass Solution {public: string reverseWords(string s) { string word; string res; auto update = [&amp;word, &amp;res] { if (!res.empty()) res += ' '; res.append(word.rbegin(), word.rend()); word.clear(); }; for (int i = (int)s.size() - 1; i &gt;= 0; i--) { if (s[i] == ' ') { if (!word.empty()) update(); } else { word += s[i]; } } if (!word.empty()) update(); return res; }}; 我的额外空间 $O(1)$ 原地算法： 123456789101112131415161718192021222324252627// 8 ms, 7.6 MBclass Solution {public: string reverseWords(string s) { reverse(s.begin(), s.end()); int wordBegin = -1; int pos = 0; auto update = [&amp;] (int i) { if (wordBegin == -1) return; if (pos) s[pos++] = ' '; // 不是第一个单词 for (int j = wordBegin; j &lt; i; ) s[pos++] = s[j++]; reverse(s.begin() + pos - (i - wordBegin), s.begin() + pos); wordBegin = -1; }; for (size_t i = 0; i &lt; s.size(); i++) { if (s[i] == ' ') update(i); else if (wordBegin == -1) wordBegin = i; } update(s.size()); s.erase(s.begin() + pos, s.end()); return s; }}; Apr.9 括号生成如下是我的解法。其中parenthesToAdd表示还需要加多少个左括号，parenthesToEnd表示还需要加多少个右括号： 12345678910111213141516171819202122232425262728// 4 ms, 13.9 MBclass Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; res; string tmp; dfs(res, n, 0, tmp); return res; }private: void dfs(vector&lt;string&gt;&amp; res, int parenthesToAdd, int parenthesToEnd, string &amp;now) { if (parenthesToAdd == 0 &amp;&amp; parenthesToEnd == 0) { res.emplace_back(now); return; } if (parenthesToAdd &gt; 0) { now.push_back('('); dfs(res, parenthesToAdd - 1, parenthesToEnd + 1, now); now.pop_back(); } if (parenthesToEnd &gt; 0) { now.push_back(')'); dfs(res, parenthesToAdd, parenthesToEnd - 1, now); now.pop_back(); } }}; 官方题解极简写法： 123456789101112131415161718// 20 ms, 15.5 MBclass Solution {public: vector&lt;string&gt; generateParenthesis(int n) { if (n == 0) { return vector&lt;string&gt;{\"\"}; } vector&lt;string&gt; res; for (int c = 0; c &lt; n; c++) { for (const string&amp; left : generateParenthesis(c)) { for (const string &amp;right : generateParenthesis(n - c - 1)) { res.emplace_back(\"(\" + left + \")\" + right); } } } return res; }}; Apr.8 机器人的运动范围首先这是一个bfs问题，我们可以直接用bfs解决。特别地，本题有一个优化：假设左上角为坐标原点$(0,0)$，则每次bfs扩展时仅需扩展该点的右边和下边。如果有一个可达的新点在当前点的正上方，则那个点一定已经被之前bfs时某一次访问过。 1234567891011121314151617181920212223242526272829303132333435363738394041// 0 ms, 7.1 MBclass Solution {public: int movingCount(int m, int n, int k) { auto digitSum = [](int x) { int res = 0; while (x) { res += x % 10; x /= 10; } return res; }; // use vector&lt;char&gt; instead of vector&lt;bool&gt; vector&lt;vector&lt;char&gt;&gt; vis(m, vector&lt;char&gt;(n)); queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(0, 0); vis[0][0] = 1; const int dx[] = {0, 1}; const int dy[] = {1, 0}; int ans = 0; while (!q.empty()) { auto now = q.front(); ++ans; q.pop(); for (int i = 0; i &lt; 2; i++) { pair&lt;int, int&gt; next(now.first + dx[i], now.second + dy[i]); if (next.first &lt; m &amp;&amp; next.second &lt; n &amp;&amp; digitSum(next.first) + digitSum(next.second) &lt;= k &amp;&amp; !vis[next.first][next.second]) { q.emplace(next.first, next.second); vis[next.first][next.second] = 1; } } } return ans; }}; Apr.7 旋转矩阵原地算法，旋转过程如代码下方注释所示。 123456789101112131415161718192021222324252627// 8 ms, 7.4 MBclass Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { const int n = matrix.size(); for (int i = 0; i &lt; n / 2; i++) { // 每次循环处理一圈 从外到内 for (int j = i; j &lt; n - 1 - i; j++) { swap(matrix[i][j], matrix[j][n - 1 - i]); swap(matrix[i][j], matrix[n - 1 - i][n - 1 - j]); swap(matrix[i][j], matrix[n - 1 - j][i]); } } }};/* 5 1 9 11 [11] 1 9 [5] [16] 1 9 5 [15] 1 9 5 2 4 8 10 2 4 8 10 2 4 8 10 2 4 8 1013 3 6 7 13 3 6 7 13 3 6 7 13 3 6 715 14 12 16 15 14 12 16 15 14 12[11] [16]14 12 1115 1 9 5 15[10] 9 5 15[12] 9 5 15[13] 9 5 2 4 8 10 2 4 8 [1] 2 4 8 1 2 4 8 113 3 6 7 13 3 6 7 13 3 6 7 [12] 3 6 716 14 12 11 16 14 12 11 16 14 [10]11 16 10 12 11 ...*/ Apr.6 编辑距离时间复杂度 $O(N*M)$ 的DP。见官方题解。 Apr.5 LFU缓存解法一：双哈希表配合链表，时间复杂度 $O(1)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 256 ms, 39.8 MBclass LFUCache {private: struct Node { int key, value, freq; }; typedef typename list&lt;Node&gt;::iterator iter_type; map&lt;int, iter_type&gt; key_iter_map; map&lt;int, list&lt;Node&gt;&gt; frequency_nodeList_map; int capacity; int minFreq;public: LFUCache(int _capacity) : capacity(_capacity), minFreq(-1) {} int get(int key) { auto it = key_iter_map.find(key); if (it == key_iter_map.end()) return -1; return visit(it, it-&gt;second-&gt;value); } void put(int key, int value) { auto iter = key_iter_map.find(key); if (iter == key_iter_map.end()) { if (int(key_iter_map.size()) == capacity) { dropLFU(); } if (int(key_iter_map.size()) &lt; capacity) { minFreq = 1; frequency_nodeList_map[1].push_front({key, value, 1}); key_iter_map.emplace(key, frequency_nodeList_map[1].begin()); } } else { visit(iter, value); } } // 用参数value代替缓存中原有的value,更新访问频率和最后一次访问时间,返回修改前的value int visit(map&lt;int, iter_type&gt;::iterator iter, int value) { int freq = iter-&gt;second-&gt;freq; iter_type nodeIter = iter-&gt;second; int oldValue = nodeIter-&gt;value; frequency_nodeList_map[freq].erase(nodeIter); if (freq == minFreq &amp;&amp; frequency_nodeList_map[freq].empty()) { ++minFreq; frequency_nodeList_map.erase(freq); } frequency_nodeList_map[freq + 1].push_front({iter-&gt;first, value, freq + 1}); iter-&gt;second = frequency_nodeList_map[freq + 1].begin(); return oldValue; } void dropLFU() { if (key_iter_map.empty()) return; auto iter = --frequency_nodeList_map[minFreq].end(); key_iter_map.erase(iter-&gt;key); frequency_nodeList_map[minFreq].pop_back(); if (frequency_nodeList_map[minFreq].empty()) { frequency_nodeList_map.erase(minFreq); ++minFreq; } }};/** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 解法二：单哈希表配合双向链表，时间复杂度 $O(1)$。但事实是……它并没有我想象中的比解法一来得快，而维护链表的逻辑实在是有些复杂，不是很划得来，但思路是宝贵的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 216 ms, 39.8 MBclass LFUCache {private: struct Node { int key, value, freq; }; using pair_list_iter_t = list&lt;pair&lt;int, list&lt;Node&gt;&gt;&gt;::iterator; using node_list_iter_t = list&lt;Node&gt;::iterator; unordered_map&lt;int, pair&lt;pair_list_iter_t, node_list_iter_t&gt;&gt; keyItersMap; list&lt;pair&lt;int, list&lt;Node&gt;&gt;&gt; freqNodeList; int capacity; int size;public: LFUCache(int _capacity) : capacity(_capacity), size(0) { freqNodeList.emplace_back(INT_MAX, list&lt;Node&gt;()); } int get(int key) { auto iter = keyItersMap.find(key); if (iter == keyItersMap.end()) return -1; pair_list_iter_t pairListIter = iter-&gt;second.first; node_list_iter_t nodeListIter = iter-&gt;second.second; pair_list_iter_t nextPairListIter = pairListIter; ++nextPairListIter; int freq = nodeListIter-&gt;freq; int value = nodeListIter-&gt;value; if (nextPairListIter-&gt;first != freq + 1) { nextPairListIter = freqNodeList.insert(nextPairListIter, make_pair(freq + 1, list&lt;Node&gt;())); } nextPairListIter-&gt;second.push_front({key, value, freq + 1}); keyItersMap[key] = make_pair(nextPairListIter, nextPairListIter-&gt;second.begin()); pairListIter-&gt;second.erase(nodeListIter); if (pairListIter-&gt;second.empty()) freqNodeList.erase(pairListIter); return value; } void put(int key, int value) { auto iter = keyItersMap.find(key); if (iter == keyItersMap.end()) { if (size == capacity) { pair&lt;int, list&lt;Node&gt;&gt;* front = &amp;freqNodeList.front(); if (front-&gt;first != INT_MAX) { keyItersMap.erase(front-&gt;second.back().key); front-&gt;second.pop_back(); if (front-&gt;second.empty()) freqNodeList.pop_front(); --size; } } if (size &lt; capacity) { pair&lt;int, list&lt;Node&gt;&gt;* front = &amp;freqNodeList.front(); if (front-&gt;first != 1) { freqNodeList.push_front(make_pair(1, list&lt;Node&gt;())); front = &amp;freqNodeList.front(); } front-&gt;second.push_front({key, value, 1}); keyItersMap[key] = make_pair(freqNodeList.begin(), front-&gt;second.begin()); ++size; } } else { pair_list_iter_t pairListIter = iter-&gt;second.first; node_list_iter_t nodeListIter = iter-&gt;second.second; pair_list_iter_t nextPairListIter = pairListIter; ++nextPairListIter; int freq = nodeListIter-&gt;freq; if (nextPairListIter-&gt;first != freq + 1) { nextPairListIter = freqNodeList.insert(nextPairListIter, make_pair(freq + 1, list&lt;Node&gt;())); } nextPairListIter-&gt;second.push_front({key, value, freq + 1}); keyItersMap[key] = make_pair(nextPairListIter, nextPairListIter-&gt;second.begin()); pairListIter-&gt;second.erase(nodeListIter); if (pairListIter-&gt;second.empty()) freqNodeList.erase(pairListIter); } }};/** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ Apr.4 接雨水定义以下两个数组 $leftMax[i]=max(leftMax[i-1], height[i])$，特别地 $leftMax[0] = height[0]$； $rightMax[i] = max(rightMax[i + 1], height[i])$，特别地 $rightMax[n - 1] = height[n - 1]$。 则第 $i (1 \\le i \\le n-2)$ 个位置内接到的雨水 $trap[i]$ 为 $max(0, min(leftMax[i-1], rightMax[i+1])-height[i])$ 也即 $min(leftMax[i], rightMax[i]) - height[i]$ 维护从左到右的最大值和从右到左的最大值可以在时间复杂度$O(N)$内解决问题。 1234567891011121314151617181920212223242526// 8 ms, 6.9 MBclass Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.empty()) return 0; const int n = height.size(); vector&lt;int&gt; leftMax(n); vector&lt;int&gt; rightMax(n); leftMax[0] = height[0]; for (int i = 1; i &lt; n; i++) leftMax[i] = max(leftMax[i - 1], height[i]); rightMax[n - 1] = height[n - 1]; for (int i = n - 2; i &gt;= 0; i--) rightMax[i] = max(rightMax[i + 1], height[i]); int ans = 0; for (int i = 1; i &lt; n - 1; i++) { ans += max(0, min(leftMax[i - 1], rightMax[i + 1]) - height[i]); // 或 ans += min(leftMax[i], rightMax[i]) - height[i]; } return ans; }}; 基于公式 $min(leftMax[i], rightMax[i]) - height[i]$。我们假设存在两个变量并赋予初值$left=0$与$right=n-1$，并维护两个变量$lmax$与$rmax$，它们的值为$lmax=leftMax[left]$与$rmax=rightMax[right]$。现在考虑把$left$和$right$尽量往中间推进。 假设我们现在想把$left$往右推进，由公式 $trap[i]=min(leftMax[i], rightMax[i]) - height[i]$，那么也就意味着式子$leftMax[left] \\le rightMax[left]$需要被满足。对$right$同理。这样我们能得到一个时间$O(1)$的算法。 123456789101112131415161718192021222324252627// 8 ms, 6.7 MBclass Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.empty()) return 0; const int n = height.size(); int left = 0, right = n - 1; int leftMax = 0, rightMax = 0; int ans = 0; while (left &lt;= right) { if (leftMax &lt;= rightMax) { // 或 height[left] &lt; height[right] leftMax = max(leftMax, height[left]); ans += leftMax - height[left]; ++left; } else { rightMax = max(rightMax, height[right]); ans += rightMax - height[right]; --right; } } return ans; }}; Apr.3 字符串转换整数 (atoi)本题主要考察的是代码功底，其中要注意判断溢出的处理。如果条件允许可以直接用long long，但下面给出的是用int的解决办法，稍微麻烦些，但是只用了32位的int就解决了问题。 1234567891011121314151617181920212223242526272829303132333435363738// 4 ms, 6.2 MBclass Solution {public: int myAtoi(string str) { if (str.empty()) { return 0; } int res = 0; bool neg = false; // 数是否为负 size_t i = 0; // 丢弃无用的开头空格 while (str[i] == ' ') i++; // 判断正负号 if (str[i] == '+' || str[i] == '-') { neg = (str[i] == '-'); i++; } for (; i &lt; str.size() &amp;&amp; isdigit(str[i]); i++) { int now = str[i] - '0'; if (neg) { if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; now &gt; INT_MAX % 10 + 1)) { return INT_MIN; } res = res * 10 - now; } else { if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; now &gt; INT_MAX % 10)) { return INT_MAX; } res = res * 10 + now; } } return res; }}; Apr.2 生命游戏按照题意模拟即可。下面给出的是原地算法。刚看到这题的时候可能会想再开一个二维数组用于存储新状态，其实所给的参数里面已经有很大的冗余空间给我们使用了（32位的int，只用了1位，还有31位可以拿来存储其他状态）。 123456789101112131415161718192021222324252627282930313233343536373839// 0 ms, 6.9 MBclass Solution {public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) { if (board.empty()) return; const int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1}; const int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1}; const int m = board.size(); const int n = board[0].size(); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { int aliveCount = 0; for (int k = 0; k &lt; 8; k++) { int x = i + dx[k], y = j + dy[k]; if (0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; isAlive(board[x][y])) { ++aliveCount; } } if (board[i][j]) { // 第1位表示当前状态，第2位表示下一状态 if (aliveCount == 2 || aliveCount == 3) board[i][j] |= 2; } else { if (aliveCount == 3) board[i][j] |= 2; } } } for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) board[i][j] &gt;&gt;= 1; // 取下一状态 }private: bool isAlive(int value) { return value &amp; 1; }}; Apr.1 有效括号的嵌套深度由于所给的字符串保证是有效括号字符串，所以将每个括号尽量平均分配即可。官方题解中考虑的奇偶性更巧妙，但不容易想到。 1234567891011121314151617181920212223// 0 ms, 7.3 MBclass Solution {public: vector&lt;int&gt; maxDepthAfterSplit(string seq) { const int n = seq.size(); vector&lt;int&gt; res; res.reserve(n); int depth[2] = {}; for (int i = 0; i &lt; n; i++) { if (seq[i] == '(') { int smallId = depth[0] &gt; depth[1]; res.push_back(smallId); ++depth[smallId]; } else { int bigId = depth[0] &lt; depth[1]; res.push_back(bigId); --depth[bigId]; } } return res; }};","link":"/2020/04/LeetCode/2020-04-leetcode-daily-problem-record/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Navicat","slug":"Navicat","link":"/tags/Navicat/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Valgrind","slug":"Valgrind","link":"/tags/Valgrind/"},{"name":"memcheck","slug":"memcheck","link":"/tags/memcheck/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Boost","slug":"Boost","link":"/categories/Boost/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"TCP/IP","slug":"TCP-IP","link":"/categories/TCP-IP/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}