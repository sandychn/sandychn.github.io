{"pages":[{"title":"标签","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"C++11 新用法","text":"基于哈希的 map 和 set简述基于哈希的 map 和 set ，它们分别叫做 unordered_map, unordered_set 。数据分布越平均，性能相较 map 和 set 来说提升就更大。但由于它们基于哈希，所以并不像 map 和 set 一样能自动排序；它们都是无序的。 我做了一个测试：随机生成 $10^7$ 个 int 范围内的整数（平均分布），然后将其分别插入 map 和 unordered_map，再完整的做一次查询，查看时间和内存上的消耗。 测试结果 结构 总耗时 插入耗时 查询耗时 内存 map 18,041 MS 10,299 MS 7,742 MS 230.7 MB unordered_map 7,138 MS 5,426 MS 1,712 MS 212.0 MB 当数据分布平均时，从时间上看，两者的性能差距约为 $7138 / 18041 \\approx 40\\%$ 提示即使在平均意义下 unordered_map 有着比 map 更高的效率，但是由于两者的实现（前者哈希，后者平衡树）， unordered_map 单次插入的最差复杂度是 $O(N)$， map 单次插入的最差复杂度是 $O(log N)$ 。所以在出题人故意造数据卡 unordered_map 使其内部哈希表发生严重冲突时，unordered_map 就会变得很慢。 测试代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; data;int main() { freopen(\"map.txt\", \"r\", stdin); data.resize(5000000); map&lt;int, int&gt; mp; double st, ed; st = clock(); for (int i = 0; i &lt; 5000000; ++i) scanf(\"%d%d\", &amp;data[i].first, &amp;data[i].second); ed = clock(); printf(\"Read: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) mp[data[i].first] = data[i].second; ed = clock(); printf(\"Insert: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); st = clock(); for (int i = 0; i &lt; 5000000; ++i) data[i].second = mp[data[i].first]; ed = clock(); printf(\"Query: %dms\\n\", int(1000.0 * (ed - st) / CLOCKS_PER_SEC)); data = vector&lt;pair&lt;int, int&gt;&gt;();} 语法上的变化auto 关键字的新含义在 C++11 中，auto 关键字被赋予了新的含义。其功能是自动类型推导。 12345678auto x = 3; // y的类型自动推导为 intauto y = make_pair(1, 2); // y的类型自动推导为 pair&lt;int, int&gt;auto z; // 编译错误, z的类型需要一个初始值才能推导map&lt;int, int&gt; mp;// iter的类型推导为map&lt;int, int&gt;::iteratorfor (auto iter = mp.begin(); iter != mp.end(); ++iter) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; '\\n'; 与其相关的是一个新的关键字 decltype，取得某一个值的类型。 12int a = 1, b = 2;decltype(a + b) c; // c为int 增强的 for（基于范围的for循环）123456789map&lt;int, int&gt; mp;// C++11 之前遍历for (map&lt;int, int&gt;::iterator it = mp,begin(); it != mp,end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n';// C++11 之后for (auto val : mp) cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; 模板嵌套时一个小改善12priority_queue&lt;pair&lt;int, int&gt; &gt; heap; // C++11之前需加一个空格避免歧义priority_queue&lt;pair&lt;int, int&gt;&gt; heap; // C++11之后不用 初始化列表更简单的初始化方式。 1234567vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} };// 等价于下面代码vector&lt;pair&lt;int, int&gt; &gt; v;v.push_back(make_pair(1, 2));v.push_back(make_pair(2, 3));v.push_back(make_pair(3, 4)); lambda 表达式下面用一个例子讲述一下lambda表达式的大致用法。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;pair&lt;int, int&gt;&gt; v{ {1, 2}, {2, 3}, {3, 4} }; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } sort(v.begin(), v.end(), [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first; }); cout &lt;&lt; \"After sort:\\n\"; for (auto&amp; val : v) { cout &lt;&lt; val.first &lt;&lt; ' ' &lt;&lt; val.second &lt;&lt; '\\n'; } return 0;} 代码里的 sort，在C++11之前比较常见的等价写法是： 123456789bool cmp(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) { return a.first &gt; b.first;}int main() { // ... sort(v.begin(), v.end(), cmp); // ...}","link":"/2019/08/13/C++11%20%E6%96%B0%E7%94%A8%E6%B3%95/"},{"title":"C++中的虚函数、重写与多态","text":"在C++中顺利使用虚函数需知道的细节 如函数在派生类中的定义有别于基类中的定义，而且你希望它成为虚函数，就要为基类的函数声明添加保留字virtual。在派生类的函数声明中，则可以不添加virtual。函数在基类中virtual，在派生类中自动virtual（但为了澄清，最好派生类中也将函数声明标记为virtual，尽管这非必须）。 保留字virtual在函数声明中添加，不要再函数定义中添加。 除非使用保留字virtual，否则不能获得虚函数，也不能获得虚函数的任何好处。 既然虚函数如此好用，为何不将所有成员函数都设为virtual？这似乎只有一个理由——效率。编译器和“运行时”环境要为虚函数做多得多的工作。所以，无谓地将成员函数为virtual会影响程序执行效率。 重写虚函数定义在派生类中发生改变时我们说函数定义被重写。一些C++书籍区分了重定义（redefine）和重写（override）。两者都是在派生类更改函数定义。函数是虚函数，就称为重写。如果不是，就称为重定义。对于我们程序员而言，这种区分似乎有点无聊，因为程序员在两种情况下做的事情是一样的。不过，编译器对于这两种情况确定是区别对待的。 多态多态性是指借助晚期绑定技术，为一个函数名关联多种含义的能力。因此，多态性、晚期绑定和虚函数其实是同一个主题。 虚函数和扩展类型兼容性、切割问题12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Pet{public: virtual void print(); string name;};class Dog : public Pet{public: virtual void print(); string breed; // 品种};void Pet::print(){ cout &lt;&lt; \"Pet name: \" &lt;&lt; name &lt;&lt; endl;}void Dog::print(){ cout &lt;&lt; \"Dog name: \" &lt;&lt; name &lt;&lt; \", breed: \" &lt;&lt; breed &lt;&lt; endl;}int main(){ Pet vPet; Dog vDog; vDog.name = \"Tiny\"; vDog.breed = \"Great Dane\"; vPet = vDog; // cout &lt;&lt; vPet.breed; return 0;} 上述代码vPet = vDog;的赋值是允许的，但赋给变量vPet的值会丢失其breed字段。这称为切割问题（slicing problem）。例如，cout &lt;&lt; vPet.breed会报错。 切割问题：在将派生类对象赋给基类变量时，派生类对象有、基类没有的数据成员会在赋值过程中丢失，基类没有的成员函数也会丢失。在最终的基类对象中，将无法使用这些丢失的成员。 切割测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;using std::cout;using std::endl;using std::string;class Demo{public: Demo(const string&amp; s): str(s) { cout &lt;&lt; \"Demo constructor called (\" + str + \").\\n\"; } ~Demo() { cout &lt;&lt; \"Demo deconstructor called (\" + str + \").\\n\"; } Demo(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo copy constructor called (\" + str + \").\\n\"; } Demo&amp; operator=(const Demo&amp; other) { str = other.str; cout &lt;&lt; \"Demo operator= called (\" + str + \").\\n\"; return *this; }private: string str;};class Base{public: Demo member1 = Demo(\"member1\");};class Derived : public Base{public: Demo member2 = Demo(\"member2\");};int main(){ Derived derived; Base base; base = derived;}/* OutputDemo constructor called (member1).Demo constructor called (member2).Demo constructor called (member1).Demo operator= called (member1).Demo deconstructor called (member1).Demo deconstructor called (member2).Demo deconstructor called (member1).*/ 幸好，C++提供了一种方式，允许在将一个Dog视为Pet的同时不丢失品种名称： 1234567Pet *pPet;Dog *pDog;pDog = new Dog;pDog-&gt;name = \"Tiny\";pDog-&gt;breed = \"Great Dane\";pPet = pDog;pPet-&gt;print(); // prints \"Dog name: Tiny, breed: Great Dane\" 基类Pet把print()声明为virtual。所以一旦编译器看到pPet-&gt;print();就会检查Pet和Dog的virtual表，判断pPet指向的是Dog类型的对象。因此，它会使用Dog::print()，而不是Pet::print()。 配合动态变量进行OOP是一种全然不同的编程方式。只要记住以下两条简单的规则，理解起来就容易得多。 如果指针pAncestor的域类型是指针pDescendant的域类型的基类，则以下指针赋值操作允许：pAncestor = pDescendant;。此外，pDescendant指向的动态变量的任何数据成员或成员函数都不会丢失。 虽然动态变量所有附加字段（成员）都没有丢，但要用virtual成员函数访问。 视图对虚成员函数定义不齐全的类进行编译编译前，如果还有任何尚未实现的virtual成员函数，编译就会失败，并产生形如undefined reference to Class_Name virtual table的错误信息。即使没有派生类，只有一个virtual成员，并且没有调用该虚函数，只要函数没有定义，就会产生这种形式的消息。此外，可能还会产生进一步的错误消息，声称程序对默认构造函数进行了未定义的引用，即使确实已定义了这些构造函数。 始终/尽量使析构函数成为虚函数（主要讲述把析构函数声明为虚函数的优点）这里主要阐述让析构函数称为虚函数的好处，但实际上也有坏处。在《Effective C++》条款07中有提到具体内容，见本文后记。 析构函数最好都是虚函数。但在解释它为什么好之前，首先解释一下析构函数和指针如何交互，以及虚析构函数的具体含义。如以下代码，其中SomeClass是含有非虚析构函数的类： 123SomeClass *p = new SomeClass;// ...delete p; 为p调用delete，会自动调用SomeClass类的析构函数，现在看看将析构函数标记为virtual之后会发生什么。为了描述析构函数与虚函数机制的交互，最简单的方式是将所有析构函数都视为同名（即使它们并非真的同名）。如假定Derived类是Base类的派生类，并假定Base类的析构函数标记为virtual，现在分析以下代码： 123Base *pBase = new Derived;// ...delete pBase; 为pBase调用delete时，会调用一个析构函数。由于Base类中的析构函数标记为virtual，且指向的对象是Derived类型，故会调用Derived的析构函数（它进而调用Base类的析构函数）。若Base类的析构函数没有标记为virtual，则只调用Base类的析构函数。 还要注意一点，将析构函数标记为virtual后，派生类的所有析构函数都自动成为virtual的（不管是否用virtual标记）。同样，这种行为就好比所有析构函数具有相同的名称（即使事实上不同名）。 现在，已准备好解释为什么所有析构函数都应该是虚函数。假定Base类有一个指针类型的成员变量pB，Base类的构造函数会创建由pB指向的一个动态变量，而Base类的析构函数会删除之；另外，假定Base类的析构函数没有标记为virtual，并假定Derived类（从Base派生）有一个指针类型的成员变量pD，Derived类的构造函数会创建由pD指向的一个动态变量，而Derived类的析构函数会删除之。则以下代码 123Base *pBase = new Derived;// ...delete pBase; 由于基类析构函数未标记为virtual，所以只会调用Base类的析构函数。这会将pB指向的动态变量的内存返还给自由存储；但pD指向的动态变量占用的内存永远不会返还给自由存储直到程序终止。 另一方面，将基类Base析构函数标记为virtual，delete pBase;时会调用Derived类的析构函数（因为指向的对象是Derived类型）。Derived类的析构函数会删除pD指向的动态变量，再自动调用基类Base的析构函数删除pB指向的动态变量。 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;class Base{public: Base() { baseData = new int; std::cout &lt;&lt; \"baseData allocated.\\n\"; } ~Base() { delete baseData; std::cout &lt;&lt; \"baseData deleted.\\n\"; }private: int *baseData;};class Derived : public Base{public: Derived() { derivedData = new int; std::cout &lt;&lt; \"derivedData allocated.\\n\"; } ~Derived() { delete derivedData; std::cout &lt;&lt; \"derivedData deleted.\\n\"; }private: int *derivedData;};int main(){ Base *base = new Derived; delete base;}/* OutputbaseData allocated.derivedData allocated.baseData deleted.*/ 将第11行的~Base()改为virtual ~Base()，程序输出为 123456/* OutputbaseData allocated.derivedData allocated.derivedData deleted.baseData deleted.*/ 后记参考：Walter Savitch《Problem Solving with C++, Tenth Edition》《Effective C++》。 《Effective C++》条款07：“为多态基类声明virtual析构函数”中提到： 带多态性质的基类应该声明一个virtual析构函数；如果类带有任何virtual函数，则它就应该拥有一个virtual析构函数。 类的设计目的如果不是作为基类使用，或不是为了具备多态性，就不该声明virtual析构函数。（如标准库input_iterator_tag等）","link":"/2020/02/10/C++%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E5%A4%9A%E6%80%81/"},{"title":"FJUTOJ-3682-LRU算法的实现2","text":"传送门 此题让我们实现一个LRU的模板类。本题较简便且高效的写法是维护一个std::list和一个std::unordered_map。 std::list 与 std::unordered_map 中存放的内容std::list中存放各key，类型为K。链表中各键码存放的顺序是按照访问顺序存放的。 std::unordered_map中以key为第一维，第二维为一个pair，其first和second分别为： first: 该key对应的value。 second:该key在std::list中的迭代器方便访问。 为方便，下面用“链表”来指代std::list，用“哈希表”来指代std::unordered_map。 各操作实现insert操作：用哈希表判断该键是否已经存在。若存在，先在链表中删除该key，然后再新加一个该key到链表尾部，并更新在哈希表中的value和链表的迭代器。若不存在，则直接加至链表尾部，并在哈希表中插入该key，伴随着对应的value和链表迭代器。 get操作：直接从哈希表中获得其value即可。代码实现未检测该key是否存在，严谨来说应该加上异常处理。 contains操作：直接在哈希表中查询是否存在该key即可。 vis操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，然后再将其加至链表尾部，并更新哈希表中对应链表迭代器。 pop操作：判断是否整个容器已经为空。若为空，则本操作无效。否则，将链表头部元素从链表中删除，并在哈希表中删除对应键值信息。 remove操作：用哈希表判断该键是否存在。若不存在，则本操作无效。否则，将该键从链表中删除，并在哈希表中删除对应键值信息。 empty操作：哈希表或链表判空即可。 size操作：取哈希表或链表大小即可。 clear操作：清空哈希表和链表即可。 时间复杂度各操作基于对链表和哈希表的修改。期望复杂度均为$O(1)$。 参考代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;list&gt;#include &lt;unordered_map&gt;template &lt;typename K, typename V&gt;class LRU {private: typedef typename std::list&lt;K&gt;::iterator listIter; typedef typename std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt;::iterator unorderedMapIter; std::list&lt;K&gt; lst; std::unordered_map&lt;K, std::pair&lt;V, listIter&gt;&gt; mp;public: void insert(const K &amp;key, const V &amp;value) { unorderedMapIter it = mp.find(key); if (it == mp.end()) { lst.emplace_back(key); mp.insert(std::make_pair(key, std::make_pair(value, --lst.end()))); } else { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second = std::make_pair(value, --lst.end()); } } // If Key doesn't exist, this will create one &lt;Key, zero&gt; V get(const K &amp;key) { return mp[key].first; } bool contains(const K &amp;key) { return mp.count(key) == 1; } void vis(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); lst.emplace_back(key); it-&gt;second.second = --lst.end(); } } void pop() { if (!lst.empty()) { mp.erase(lst.front()); lst.pop_front(); } } void remove(const K &amp;key) { unorderedMapIter it = mp.find(key); if (it != mp.end()) { lst.erase(it-&gt;second.second); mp.erase(it); } } bool emtpy() { // 本题要求此函数名为emtpy return lst.empty(); } unsigned long long size() { return lst.size(); } void clear() { lst.clear(); mp.clear(); }};","link":"/2019/03/16/FJUTOJ-3682-LRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B02/"},{"title":"C++引用的实现","text":"当我学习C++引用时，听到的第一句话是“引用是变量的别名，不像指针一样需要占用内存空间”。然而学到深处，发现此话并不完全正确。 本文主要介绍我如何通过实验来了解到C++引用的实现，其实引用的内部就是指针。当然这也于编译器有关，所以这里需要提及一下测试所用的编译器及环境。 测试环境是MinGW的g++ 8.1.0，64位编译器，64位的机子。所以指针的大小是8个字节，即64个bit。（注：因为目的是测试，所以测试时并没有处理对new操作符所产生对象的回收） 首先我写出了如下代码，试图通过指针偏移来获取有关引用的信息： 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int64_t x; string&amp; str = *new string(); int64_t y; str = \"123\"; // 对引用做一次操作，避免编译器把变量优化掉 cout &lt;&lt; &amp;x &lt;&lt; endl; cout &lt;&lt; &amp;y &lt;&lt; endl; return 0;} 然而，这个程序的输出如下： 120x61fe000x61fdf8 难道引用真的不占内存？编译器真的很聪明，可能优化掉了吧；经过一系列尝试，我写出了另外一段代码： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void foo(int64_t q, string&amp; s, int64_t r) { cout &lt;&lt; \"&amp;q: \" &lt;&lt; &amp;q &lt;&lt; endl; cout &lt;&lt; \"&amp;r: \" &lt;&lt; &amp;r &lt;&lt; endl; cout &lt;&lt; \"*(string**)(&amp;q + 1): \" &lt;&lt; *(string**)(&amp;q + 1) &lt;&lt; endl;}int main(){ string&amp; str = *new string(); cout &lt;&lt; \"main(): \" &lt;&lt; &amp;str &lt;&lt; endl; foo(0, str, 0); return 0;} 这段代码的输出是： 1234main(): 0x1e1bd0&amp;q: 0x61fde0&amp;r: 0x61fdf0*(string**)(&amp;q + 1): 0x1e1bd0 我们首先来看，q的地址是0x61fde0，r的地址是0x61fdf0。两个地址间相差16个字节！这里引用占用的内存出来了。显然引用对应的指针存储在q的8个字节之后。我们可以将q的地址加1，也就是加上8个字节，这里存储的就是引用的信息。我们假设它就是指针，那么我们来考虑：(&amp;q + 1)本身是一个指向string*的指针，也就是string**。所以我们要获取指针的值，要对这个值解一次引用，输出出来。（当然如果你想简单一点，可以直接把它转成int64_t然后用16进制输出） 至此真相大白，程序输出的最后一行0x1e1bd0与主函数中new出来的对象的地址（见输出第一行）一致。所以得出结论：引用是用指针实现的。用户对引用的访问操作都内含一次解引用，而这对用户来说是透明的。 不过需要提及的是，回想本文的第一个测试，发现引用的指针空间被优化掉了。所以引用有时也不一定会在栈上真正以指针体现出来。","link":"/2020/03/07/C++%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"STL中_Rb_tree的探索","text":"我们知道STL中我们常用的set与multiset和map与multimap都是基于红黑树。本文介绍了它们的在STL中的底层数据结构_Rb_tree的直接用法与部分函数。难点主要是_Rb_tree的各个参数的确定。 特别注意在如下代码的Selector类用于从Node中选出用于排序的key值，这个仿函数必须返回const int&amp;而不能是int，否则less&lt;int&gt;::operator(const int&amp;, const int&amp;)会抛出segmentation fault。由于源码中逻辑比较复杂，但是可以观察到内部涉及这方面的地方经常使用到指针。所以可以推测是因为引用了已经释放的局部变量所以才抛出的segmentation fault。一开始写成int，看了很多源码才发现是这个原因，一定要注意。 接下来是样例代码，里面都有注释了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;iomanip&gt;// 原则上不要直接引用这个头文件，这里只是为了测试#include &lt;bits/stl_tree.h&gt;using namespace std;struct Node { int first, second; Node(int _first, int _second) : first(_first), second(_second){}; friend ostream&amp; operator&lt;&lt;(ostream&amp; outs, const Node&amp; node) { outs &lt;&lt; '{' &lt;&lt; node.first &lt;&lt; ',' &lt;&lt; node.second &lt;&lt; '}'; return outs; }};template &lt;class T&gt;struct Selector { // MUST return const int&amp;, not int. // if return int, segmentation fault will occur. // I have spent much time because of this. const int&amp; operator()(const T&amp; obj) const { return obj.first; }};int main() { // _Rb_tree: red-black tree in STL. using tree_type = _Rb_tree&lt;int, Node, Selector&lt;Node&gt;, less&lt;int&gt;&gt;; using iterator_type = tree_type::iterator; using result_pair_type = pair&lt;tree_type::iterator, bool&gt;; tree_type tree; // 插入元素Node(1, 2) result_pair_type res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert address = \" &lt;&lt; res.first._M_node &lt;&lt; endl; cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // true iterator_type it = tree.begin(); cout &lt;&lt; \"begin address = \" &lt;&lt; it._M_node &lt;&lt; endl; it = tree.find(1); cout &lt;&lt; \"address = \" &lt;&lt; it._M_node &lt;&lt; \", value = \" &lt;&lt; *it &lt;&lt; endl; // 再插入元素Node(1, 2)但是因为调用的是insert_unique // 它不会添加重复值，所以插入会被拒绝 res = tree._M_insert_unique(Node(1, 2)); cout &lt;&lt; \"insert result = \" &lt;&lt; boolalpha &lt;&lt; res.second &lt;&lt; endl; // false // 再插入元素Node(1, 2)但这次调用insert_equal // multiset和multimap就是利用这个函数来插入重复值 // 也就是这个函数允许重复值，所以插入成功 tree._M_insert_equal(Node(1, 3)); cout &lt;&lt; \"size = \" &lt;&lt; tree.size() &lt;&lt; endl; // 大小就变为2 pair&lt;iterator_type, iterator_type&gt; result = tree.equal_range(1); for (iterator_type ite = result.first; ite != result.second; ++ite) { cout &lt;&lt; \"address = \" &lt;&lt; ite._M_node &lt;&lt; \", value = \" &lt;&lt; *ite &lt;&lt; endl; } return 0;} 程序的输出为（内存地址不定）： 12345678insert address = 0xf91be0insert result = truebegin address = 0xf91be0address = 0xf91be0, value = {1,2}insert result = falsesize = 2address = 0xf91be0, value = {1,2}address = 0xf91c10, value = {1,3}","link":"/2020/02/20/STL%E4%B8%AD_Rb_tree%E7%9A%84%E6%8E%A2%E7%B4%A2/"},{"title":"bitset","text":"用处一含有特定二进制位数 N 的容器，相当于 bool 数组，但压缩内存至每一个二进制位。 申明bitset&lt;N&gt; bset，其中 N 为字面常量，表示 bitset 中的二进制位个数。如 bitset&lt;10&gt; bset; 常用方法bitset(unsigned long val) 用 val 构造一个对应的 bitset (至 C++11 前) bitset(unsigned long long val) 用 val 构造一个对应的 bitset (自 C++11 始) bitset(string val) 用 val 构造一个对应的 bitset bool operator[] 获取特定二进制位的值 bool test(pos) 获取特定二进制位的值，但有越界检查：如果越界，抛出 std::out_of_range 异常。 bool all() 是否所有二进制位都是1 (自 C++11) bool any() 是否有二进制位是1 bool none() 是否所有二进制位都是0 size_t count() 返回二进制位是1的二进制位个数 size_t size() 返回 N bitset&lt;N&gt;&amp; operator&amp;=(const bitset&lt;N&gt;&amp; other) 与操作 bitset&lt;N&gt;&amp; operator|=(const bitset&lt;N&gt;&amp; other) 或操作 bitset&lt;N&gt;&amp; operator^=(const bitset&lt;N&gt;&amp; other) 异或操作 bitset&lt;N&gt; operator~() 非操作 bitset&lt;N&gt; operator&lt;&lt;(size_t pos) 左移 bitset&lt;N&gt;&amp; operator&lt;&lt;=(size_t pos) 自左移 bitset&lt;N&gt; operator&gt;&gt;(size_t pos) 右移 bitset&lt;N&gt;&amp; operator&gt;&gt;=(size_t pos) 自右移 bitset&lt;N&gt;&amp; set() 将全部位设为1 bitset&lt;N&gt;&amp; set(pos, value) 将pos位设为 value bitset&lt;N&gt;&amp; reset() 将全部位设为0 bitset&lt;N&gt;&amp; reset(pos) 将pos位设为0 bitset&lt;N&gt;&amp; flip() 翻转所有位（与 operator~ 类似，但是是直接在原数上进行） bitset&lt;N&gt; &amp;flip(pos) 翻转第pos位 string to_string(char zero = '0', char one = '1') 转为字符串 unsigned long to_ulong() 转为 unsigned long ，若溢出则抛出 std::overflow_error unsigned long long to_ullong() 转为 unsigned long long ，若溢出则抛出 std::overflow_error (自C++11) 代码示例12345678910#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() { bitset&lt;10&gt; bset(15); cout &lt;&lt; bset &lt;&lt; '\\n'; // output: 0000001111 return 0;}","link":"/2019/08/06/bitset/"},{"title":"multimap与multiset","text":"multimap介绍基本与 map 相同，但除去了 operator[]， 因为其特点是相同 key 的值在 multimap 中可以多个存在。需要强调的，与 map 有明显不同的常用方法： 常用方法iterator insert(value) 插入键值对，返回插入后该元素的迭代器 size_type erase(key) 删除所有关键字与 key 相等的键值对，返回删除的元素个数 void erase(iterator pos) 删除对应位置元素 size_type count(key) 统计关键字为 key 的元素个数 iterator find(key) 查找关键字与 key 相等的键值对，返回对应位置的迭代器。如果不存在则返回 end() 。如果有多个关键字与 key 相等的键值对，返回的迭代器指向哪一个不定。 pair&lt;iterator, iterator&gt; equal_range(key) 查找关键字与 key 相等的键值对，返回迭代器对，描述与 key 相等的键值对的区间 [first, last) 。 代码示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef multimap&lt;int, char&gt;::iterator iterType;int main() { multimap&lt;int, char&gt; mp; mp.insert(make_pair(1, 'A')); mp.insert(make_pair(2, 'B')); mp.insert(make_pair(2, 'C')); mp.insert(make_pair(2, 'D')); mp.insert(make_pair(4, 'E')); mp.insert(make_pair(3, 'F')); pair&lt;iterType, iterType&gt; range = mp.equal_range(2); for (iterType it = range.first; it != range.second; ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\\n'; } return 0;} 12345output2 B2 C2 D multiset介绍与上述 multimap 的用法基本相同，只是每个元素只有一个值 key，而没有对应的 value。","link":"/2019/08/06/multimap%E4%B8%8Emultiset/"},{"title":"二叉堆基础与优先队列","text":"堆是一种数据结构，而priority_queue (优先队列)是一个基于二叉堆的STL容器。 堆有很多种类，但以下提及的堆均为二叉堆。 以下是一个例子。将新元素20插入二叉堆： 所以对一个二叉堆，有3种基本操作： 插入：将 val 插入堆。 取堆顶：查看堆顶元素值。（即整个堆中最大或最小值） 出堆：将堆顶元素出堆。 大根堆参考实现代码： 1234567891011121314151617181920212223242526272829303132333435struct Heap { int heap[N], n; void clear() { n = 0; } void up(int p) { while (p &gt; 1) { if (heap[p] &gt; heap[p / 2]) { swap(heap[p], heap[p / 2]); p /= 2; } else { break; } } } void down(int p) { int s = p * 2; while (s &lt;= n) { if (s &lt; n &amp;&amp; heap[s] &lt; heap[s + 1]) ++s; if (heap[s] &gt; heap[p]) { swap(heap[s], heap[p]); p = s; s = p * 2; } else { break; } } } void insert(int val) { heap[++n] = val; up(n); } void pop() { heap[1] = heap[n--]; down(1); }}; 但在 C++ STL中，我们有 priority_queue 。所以我们通常就直接使用它，而不会手敲二叉堆（但是至少应该知道优先队列的工作原理）。 请注意 priority_queue 的堆顶默认是整个堆中的最大值（即默认大根堆，反过来的叫小根堆）。 priority_queue 有以下方法： push(val): 将 val 插入堆。$O(logN)$ top(): 查看堆顶元素值。（即整个堆中最大或最小值）$O(1)$ pop(): 将堆顶元素出堆。$O(logN)$ size(): 取堆大小。$O(1)$ empty(): 判断堆是否为空。$O(1)$ 有时我们需要（重新）定义小于号以使用 priority_queue 。有很多种方法可以实现对小于号的重载，如 bool operator&lt; friend bool operator&lt; bool operator() 以下是练习题： POJ-1338, HDOJ-4006, POJ-3253, HDOJ-1873, HDOJ-1509, POJ-1442, HDOJ-1896, POJ-1456 另外，与二叉堆关系密切的一个经典问题是: 哈夫曼树 (Huffman Tree). 如 T^TOJ-3810. 部分练习题参考代码 POJ-1338 [Ugly Numbers] 参考代码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; q;vector&lt;LL&gt; v;int main() { int n; q.push(1); while (q.size() &lt; 1500) { LL val = q.top(); q.pop(); if (!v.empty() &amp;&amp; v.back() == val) continue; v.push_back(val); q.push(val * 2); q.push(val * 3); q.push(val * 5); } while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { printf(\"%lld\\n\", v[n - 1]); } return 0;} HDOJ-4006 [The kth great number] 参考代码 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;int main() { int n, k, num; char op[3]; while (~scanf(\"%d %d\", &amp;n, &amp;k)) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; while (n--) { while (q.size() &gt; k) q.pop(); scanf(\"%s\", op); if (op[0] == 'I') { scanf(\"%d\", &amp;num); q.push(num); } else { printf(\"%d\\n\", q.top()); } } } return 0;}","link":"/2019/07/23/%E4%BA%8C%E5%8F%89%E5%A0%86%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"title":"后缀数组","text":"相关定义及其证明sa 后缀数组 suffix array保存 $0 \\sim n-1$ 的全排列，含义是把所有后缀按字典序排序后，后缀在原串中的位置。$suffix(sa[i]) &lt; suffix(sa[i + 1])$ $sa[,]$ 记录位置，即“排第i的后缀是谁”。 rk 名次数组 rank array保存 $0 \\sim n-1$ 的全排列，$rk[i]$ 的含义是 $suffix(i)$ 在所有后缀中按字典序排序的名次。 $rk[,]$ 记录排名，即“第以第i个字符起始的后缀子串在所有后缀子串中排第几”。 sa 与 rk 的关系$sa[,]$ 与 $rk[,]$ 是一一对应的关系，且互为逆运算。于是 可用 $rk[,]$ 推导 $sa[,]$： for (int i = 0; i &lt; n; ++i) sa[rk[i]] = i; 可用 $sa[,]$ 推导 $rk[,]$： for (int i = 0; i &lt; n; ++i) rk[sa[i]] = i; LCP 最长公共前缀LCP 即 Longest Common Prefix，最长公共前缀。 记 $LCP(i, j)$ 为 $suffix(sa[i])$ 与 $suffix(sa[j])$ 的最长公共前缀长度，即排序后第 $i$ 个后缀与第 $j$ 个后缀的最长公共前缀长度 LCP Lemma (LCP引理)若 $0 \\lt i \\lt j \\lt k \\le n-1$，则 $LCP(i, k) = min{LCP(i, j),,LCP(j, k)}$。 证明： 设 $p=min{LCP(i, j), LCP(j, k)}$ ，则 $LCP(i, j) \\ge p ,;LCP(j, k) \\ge p$。 又设 $suffix(sa[i])=u,;suffix(sa[j])=v,;suffix(sa[k])=w$ ①。 我们记 $a=_{len}b$表示字符串 $a$ 长度为 $len$ 的前缀与字符串 $b$ 的长度为 $len$ 的前缀相等。 则由 $u={LCP(i,j)}v$ 可得 $u={p}v, ; v=_{p}w$ 。 于是可得 $u=_{p}w$。即 $LCP(i, k) \\ge p = min{LCP(i, j),,LCP(j, k)}$。 现在我们再证 $LCP(i,k) \\gt p$ 是不可能的。 又设存在一个 $q \\gt p$，$LCP(i, k) = q$。 则可得 $u[i] = w[i]$ 对任意 $i \\in [1, q]$ 均成立。由于 $q \\gt p$，所以上式中的一个是 $u[p+1] = w[p+1]$。 由 ① 得 $u[p+1] \\leq v[p+1] \\leq w[p+1]$。结合上一行得 $u[p+1]=v[p+1]=w[p+1]$。 而 $p=min{LCP(i, j), LCP(j, k)}$，即 $u[p+1] \\neq v[p+1]$ 或 $v[p+1] \\ne w[p+1]$。 出现矛盾，故不存在 $q$ ，使得假设 $LCP(i, k) = q \\gt p$ 成立。即得 $LCP(i, k) \\le p$。 故得 $LCP(i, k) \\ge p$ 且 $LCP(i, k) \\le p$。 最后 $LCP(i, k) = min{LCP(i, j), LCP(j, k)}$。 LCP Theorem(LCP定理)若 $i \\lt j$ 则 $LCP(i, j) = min{LCP(k - 1, k)},;i \\lt k \\le j$ 证明：由 LCP Lemma 与数学归纳法可得。 height 高度数组$height[,]$ 是一个辅助数组，和最长公共前缀 (LCP) 相关。 令 $height[i]=LCP(i-1,i),;1 \\lt i \\le n$ ，即 $suffix(sa[i-1])$ 与 $suffix(sa[i])$ 的最长公共前缀长度。 为了描述方便，记 $h[i]$ 为 $height[rank[i]]$ ，即后缀 $suffix(i)$ 与 $suffix(sa[rank[i]-1])$ 的LCP长度。 有一个很重要的性质可以让我们在 $O(N)$ 的时间内求得 $height[]$ 数组：$h[i] \\ge h[i-1] - 1$ 。 证明： 设 $suffix(k)$ 是排在 $suffix(i-1)$ 前一名的后缀，则它们的LCP长度为 $h[i-1]$。两者都去掉第一个字符，得到 $suffix(k+1)$ 与 $suffix(i)$ 。 ① 若 $h[i-1] \\le 1$ ，即 $h[i-1]-1 \\le 0$ ，则 $h[i] \\ge h[i-1] - 1$ 显然成立。 ② 若 $h[i-1] \\gt 1$ ，则在上面去掉第一个字符的过程中是去掉的两者LCP中的第一个字符，那么 $suffix(k+1)$ 与 $suffix(i)$ 的LCP长度就至少为 $h[i] \\ge [h-1]-1$ 。 故 $h[i] \\ge h[i-1]-1$ 得证。 倍增+基数排序 求 sa, rk, height 三数组个人模板，供参考。设字符串长度为 $N$，则下面代码求三数组的复杂度为 $O(N;logN)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 50;char s[N];int sa[N], rk[N], cnt[N], height[N], t1[N], t2[N];void calcSA(char *s, int n) { int m = 256; int i, *x = t1, *y = t2; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i] = s[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (i = n - k + 1; i &lt;= n; ++i) y[++p] = i; for (i = 1; i &lt;= n; ++i) if (sa[i] &gt; k) y[++p] = sa[i] - k; for (i = 1; i &lt;= m; ++i) cnt[i] = 0; for (i = 1; i &lt;= n; ++i) ++cnt[x[i]]; for (i = 2; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i &gt;= 1; --i) sa[cnt[x[y[i]]]--] = y[i]; swap(x, y); x[sa[1]] = 1; p = 1; for (i = 2; i &lt;= n; ++i) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? p : ++p; if (p &gt;= n) break; m = p; } for (i = 1; i &lt;= n; ++i) rk[sa[i]] = i; for (int i = 1, k = 0; i &lt;= n; ++i) { if (rk[i] == 1) { height[rk[i]] = 0; } else { if (k) --k; int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) ++k; height[rk[i]] = k; } }}int main() { scanf(\"%s\", s + 1); int len = strlen(s + 1); calcSA(s, len); for (int i = 1; i &lt;= len; ++i) printf(\"%d \", sa[i]); return 0;} 后记https://www.cnblogs.com/ECJTUACM-873284962/p/6618870.html https://blog.csdn.net/qq_37774171/article/details/81776029 从上两文中做了一些参考，但部分证明感觉并不浅显易懂，在加以个人理解后最后形成此文。","link":"/2019/08/03/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"title":"高效随机数据生成-random与chrono","text":"请注意random库与chrono库均是C++11。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;chrono&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;// 生成 [a, b] 范围内的整数// 其中 INT_MIN &lt;= a &lt;= b &lt;= INT_MAXint rand(int a, int b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;int&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_INT_MAXunsigned rand(unsigned a, unsigned b) { static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;unsigned&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 LONG_LONG_MIN &lt;= a &lt;= b &lt;= LONG_LONG_MAXLL rand(LL a, LL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;LL&gt;(a, b)(rng);}// 生成 [a, b] 范围内的整数// 其中 0 &lt;= a &lt;= b &lt;= UNSIGNED_LONG_LONG_MAXULL rand(ULL a, ULL b) { static mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()); return uniform_int_distribution&lt;ULL&gt;(a, b)(rng);}int main() { const LL MAX = 1e10; cout &lt;&lt; rand(-MAX, MAX); return 0;}","link":"/2019/08/07/%E9%AB%98%E6%95%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90-random%E4%B8%8Echrono/"},{"title":"Golang中的匿名函数、闭包、defer、panic、recover","text":"匿名函数12345678910package mainimport \"fmt\"func main() { f := func() { fmt.Println(\"test\") } f()} 闭包下面代码中，输出的三个x的地址一定是一样的，它们引用同一个变量。 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() { f := closure(10) fmt.Println(f(1)) fmt.Println(f(2))}func closure(x int) func(int) int { fmt.Println(&amp;x) return func(y int) int { fmt.Println(&amp;x) return x + y }}/* possible output:0xc0000600680xc000060068110xc00006006812*/ defer 执行方式类似其它语言中的析构函数，在函数体执行结束后按照调用顺序的相反顺序逐个执行 即使函数发生严重错误也会执行 支持匿名函数的调用 常用于资源清理、文件关闭、解锁以及记录时间等操作 通过与匿名函数配合可在return之后修改函数计算结果 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时即已经获得了拷贝，否则则是引用某个变量的地址 下面这个代码中，defer时i就传值进去了。所以输出210。 123456789package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer fmt.Print(i) }} 下面这个代码中，由于闭包中的i是对main函数中局部变量i的引用。defer在main函数结束后执行，而main函数结束时i的值已经为3。所以输出3次3。 1234567891011package mainimport \"fmt\"func main() { for i := 0; i &lt; 3; i++ { defer func() { fmt.Println(i) }() }} 下面这个代码中，闭包里每一次传递的string事实上都不是同一个。所以输出的是ans2 ans1 ans0。 123456789101112131415package mainimport ( \"fmt\" \"strconv\")func main() { for i := 0; i &lt; 3; i++ { var t string = \"ans\" + strconv.Itoa(i) defer func() { fmt.Print(t + \" \") }() }} defer配合panic与recover123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"func main() { f1() f2() f3()}func f1() { fmt.Println(\"func f1\")}func f2() { // defer 一定要在 panic 之前, 因为 panic 触发时 // panic 所在函数就会立刻终止并倒序调用所有已经存在的defer // 若 defer 在 panic 之后, 程序根本不会知道后面有 defer defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (first)\") } }() defer func() { if err := recover(); err != nil { fmt.Println(\"err =\", err) fmt.Println(\"recover in f2 (second)\") } }() panic(\"panic in f2\")}func f3() { fmt.Println(\"func f3\")}/* output:func f1err = panic in f2recover in f2 (second)func f3*/","link":"/2020/03/05/Golang%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81defer%E3%80%81panic%E3%80%81recover/"}],"tags":[{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Go","slug":"Go","link":"/categories/Go/"}]}